<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Serie TV Tracker</title>
    <!-- PWA Configuration -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#2a9d8f">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="apple-touch-icon" href="icon.svg">

    <link rel="icon"
        href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><path fill="%232a9d8f" d="M592 0H48A48 48 0 0 0 0 48v320a48 48 0 0 0 48 48h160v32a32 32 0 0 0 32 32h160a32 32 0 0 0 32-32v-32h160a48 48 0 0 0 48-48V48a48 48 0 0 0 -48-48zm-16 352H64V64h512zM272 448h96v-32h-96z"/></svg>'
        type="image/svg+xml">

    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css">

    <!-- Firebase (Versione 8 - Stabile) -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>

    <style>
        :root {
            --primary: #2a9d8f;
            --secondary: #4ecdc4;
            --danger: #ff4444;
            --success: #2a9d8f;
            --warning: #f4a261;
            /* Arancione */
            --bg-color: #f4f7fa;
            --card-bg: white;
            --text-color: #1a1a1a;
            --text-secondary: #666;
            --border-color: #e0e0e0;
            --section-tint: rgba(42, 157, 143, 0.05);
            --progress-bg: #e0e0e0;
            --progress-fill: #66cc00;
            --progress-fill-ended: #9c04fc;
            --film-accent: #3A86FF;
        }

        body.dark {
            --bg-color: #121212;
            --card-bg: #1e1e1e;
            --text-color: #f5f5f5;
            --text-secondary: #aaa;
            --border-color: #333;
            --section-tint: rgba(42, 157, 143, 0.08);
            --progress-bg: #444;
        }

        .tracker-switch {
            display: flex;
            background-color: rgba(128, 128, 128, 0.1);
            border-radius: 8px;
            padding: 4px;
            border: 1px solid var(--border-color);
        }

        .tracker-switch-btn {
            padding: 0.25rem 0.75rem;
            text-decoration: none;
            color: var(--text-secondary);
            border-radius: 6px;
            transition: all 0.2s ease;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }

        .tracker-switch-btn.active {
            background: var(--primary);
            color: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .tracker-switch-btn:not(.active):hover {
            background-color: var(--section-tint);
            color: var(--text-color);
        }

        html {
            scroll-behavior: smooth;
        }

        /* Rendi la barra di scorrimento più sottile e moderna (stile app) */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-color);
        }

        ::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .loading-spinner {
            animation: spin 1s linear infinite;
        }

        .user-select-none {
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 1rem;
            background: var(--bg-color);
            color: var(--text-color);
            transition: background 0.3s, color 0.3s;
        }

        #appLoader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-color);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            transition: opacity 0.3s;
        }

        #appLoader i {
            font-size: 3rem;
            color: var(--primary);
        }

        .top-bar {
            position: sticky;
            top: 0;
            z-index: 100;
            background: rgba(30, 30, 30, 0.8);
            /* Colore scuro semi-trasparente */
            backdrop-filter: blur(15px);
            /* Sfocatura dello sfondo */
            -webkit-backdrop-filter: blur(15px);
            border-bottom: 1px solid var(--border-color);
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .top-bar-left {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .top-bar-left h1 {
            margin: 0;
            font-size: 1.75rem;
            letter-spacing: -1px;
            color: var(--primary);
        }

        .top-bar-right {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex-wrap: wrap;
        }

        .search-box {
            max-width: 300px;
        }

        .filter-select {
            max-width: 180px;
        }

        #mobileFilterBtn {
            display: none;
        }

        /* --- STATS PANEL (ICONS) --- */
        .stats-panel {
            background-color: var(--section-tint);
            padding: 1rem;
            border-radius: 12px;
            margin-bottom: 2rem;
        }

        .stats-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 1rem;
        }

        .stat-item {
            background: var(--card-bg);
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
            border: 1px solid var(--border-color);
            transition: background 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            position: relative;
            /* For tooltip positioning if needed, though title uses browser native */
        }

        .stat-item:hover {
            background: rgba(42, 157, 143, 0.15);
        }

        .stat-icon {
            font-size: 1.8rem;
            color: var(--primary);
            /* Teal color */
            margin-bottom: 0.25rem;
        }

        .stat-name {
            font-size: 0.9rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-color);
            line-height: 1;
        }

        /* Mobile: Hide text labels, keep icons */
        @media (max-width: 768px) {
            .stat-name {
                display: none;
            }

            .stat-icon {
                font-size: 1.5rem;
                margin-bottom: 0;
            }

            .stat-value {
                font-size: 1.2rem;
            }

            .stat-item {
                padding: 0.75rem;
                gap: 0.25rem;
            }
        }

        /* --- MEDIA CARD --- */
        .media-card {
            background: var(--card-bg);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            width: 180px;
            transition: transform 0.2s cubic-bezier(0.2, 0, 0, 1), box-shadow 0.2s;
            position: relative;
            border: 1px solid var(--border-color);
            animation: fadeIn 0.5s ease-out both;
            cursor: pointer;
            display: flex;
            flex-direction: column;
        }

        .media-card:hover {
            transform: translateY(-5px) scale(1.02);
            /* Sale e si ingrandisce leggermente */
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }

        .media-card.is-stat-contributor {
            border-top: 2px dashed var(--primary);
        }

        .media-card.is-duplicate {
            opacity: 0.65;
        }

        .media-poster {
            width: 100%;
            aspect-ratio: 2 / 3;
            object-fit: cover;
            object-position: center top;
            background-color: var(--border-color);
            display: block;
        }

        .media-info {
            padding: 0.75rem;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        .media-title {
            font-size: 0.9rem;
            margin: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            color: var(--text-color);
            font-weight: 600;
        }

        .media-meta {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .media-ratings {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
            flex-wrap: nowrap;
        }

        .rating-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.2rem;
            background: rgba(0, 0, 0, 0.05);
            padding: 0.2rem 0.4rem;
            border-radius: 12px;
            font-size: 0.75rem;
        }

        body.dark .rating-badge {
            background: rgba(255, 255, 255, 0.08);
        }

        .rating-icon {
            width: 14px;
            height: 14px;
            object-fit: contain;
        }

        .media-progress {
            margin-top: auto;
            padding-top: 0.75rem;
        }

        .progress-bar-container {
            width: 100%;
            background-color: var(--progress-bg);
            border-radius: 4px;
            height: 6px;
            overflow: hidden;
            margin-bottom: 0.25rem;
        }

        .progress-bar {
            height: 100%;
            background-color: var(--progress-fill);
            border-radius: 4px;
            transition: width 0.3s ease-out, background-color 0.3s;
        }

        .progress-bar.ended {
            background-color: var(--progress-fill-ended);
        }

        .progress-bar.dropped {
            background-color: var(--danger);
        }

        .progress-text {
            font-size: 0.75rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .progress-text .media-year-compact,
        .mobile-imdb-rating {
            display: none;
        }

        .card-actions {
            position: absolute;
            top: 8px;
            right: 8px;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            opacity: 0;
            transform: translateX(10px);
            transition: opacity 0.2s, transform 0.2s;
            pointer-events: none;
        }

        .media-card:hover .card-actions {
            opacity: 1;
            transform: translateX(0);
            pointer-events: all;
        }

        .card-btn {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border: none;
            cursor: pointer;
            font-size: 0.8rem;
            transition: background 0.2s;
        }

        .card-btn:hover {
            background: rgba(0, 0, 0, 0.8);
        }

        .favorite-btn {
            position: absolute;
            top: 8px;
            left: 8px;
            width: 30px;
            height: 30px;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            opacity: 0;
        }

        .media-card:hover .favorite-btn {
            opacity: 1;
        }

        .favorite-btn.is-favorite {
            background: rgba(255, 255, 255, 0.8);
            opacity: 1;
        }

        .favorite-btn i {
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .favorite-btn.is-favorite i {
            transform: scale(1.3);
            color: #e74c3c;
        }

        #detailsModalFavoriteBtn {
            background: transparent;
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }

        #detailsModalFavoriteBtn.is-favorite {
            background: #e74c3c;
            color: white;
            border-color: #e74c3c;
        }


        .media-section {
            background: var(--section-tint);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .media-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 1.5rem;
            margin-top: 1rem;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 0 0 1rem 0;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border-color);
            position: relative;
        }

        .section-header::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 0;
            width: 100px;
            height: 2px;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
        }

        .section-title {
            color: var(--text-color);
            margin: 0;
            font-size: 1.25rem;
            letter-spacing: -0.5px;
            font-weight: 700;
        }

        .btn {
            padding: 0.5rem 1rem;
            border-radius: 8px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            box-sizing: border-box;
            height: 38px;
        }

        .btn:active {
            transform: translateY(1px);
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-secondary {
            background: var(--secondary);
            color: white;
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn-warning {
            background: var(--warning);
            color: #1a1a1a;
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        .btn-small {
            padding: 0.25rem 0.75rem;
            height: auto;
            font-size: 0.8rem;
        }

        /* Stato base del modale (Invisibile) */
        .modal {
            display: none;
            /* Gestito dal JS */
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            z-index: 1000;
            justify-content: center;
            align-items: flex-end;
            /* Mobile: attacca al fondo */
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        /* Quando il modale è attivo */
        .modal.visible {
            opacity: 1;
        }

        /* Livello 1: Modali base (Dettagli serie, Episodi, Gestione) */
        .modal {
            z-index: 1000;
        }

        /* Livello 2: Menu e navigazione mobile */
        #mobileMenuModal,
        #filterSortModal,
        #categoryNavModal,
        #mobileNotificationsModal {
            z-index: 1100;
        }

        /* Livello 3: Centro Manutenzione, Storico, Calendario, Riepiloghi */
        #settingsModal,
        #historyModal,
        #calendarModal,
        #updateProgressModal,
        #updateSummaryModal {
            z-index: 1200 !important;
        }

        /* Livello 4: Conferme e Allerta (Sopra a TUTTO) */
        #confirmModal {
            z-index: 1500 !important;
        }

        /* Stile Switch Toggle */
        .switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 22px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        #settingsModal {
            z-index: 1200;
        }

        .settings-grid {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin: 1.5rem 0;
        }

        .settings-card {
            display: flex;
            align-items: center;
            padding: 1rem;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid var(--border-color);
        }

        .settings-card:active {
            transform: scale(0.97);
        }

        .settings-icon {
            width: 45px;
            height: 45px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            margin-right: 1rem;
        }

        .settings-info {
            display: flex;
            flex-direction: column;
        }

        .settings-title {
            font-weight: 700;
            font-size: 1rem;
        }

        .settings-desc {
            font-size: 0.75rem;
            opacity: 0.7;
        }

        /* Colori chiari e distinti */
        .export-card {
            background: rgba(34, 139, 34, 0.1);
            color: #228b22;
            border-color: rgba(34, 139, 34, 0.2);
        }

        .export-card .settings-icon {
            background: #228b22;
            color: white;
        }

        .import-card {
            background: rgba(58, 134, 255, 0.1);
            color: var(--primary);
            border-color: rgba(58, 134, 255, 0.2);
        }

        .import-card .settings-icon {
            background: var(--primary);
            color: white;
        }

        .reset-card {
            background: rgba(231, 76, 60, 0.1);
            color: #e74c3c;
            border-color: rgba(231, 76, 60, 0.2);
        }

        .reset-card .settings-icon {
            background: #e74c3c;
            color: white;
        }

        .last-backup-info {
            text-align: center;
            font-size: 0.8rem;
            color: var(--text-secondary);
            padding: 0.5rem;
            background: var(--section-tint);
            border-radius: 8px;
            margin-bottom: 0.5rem;
        }

        input:checked+.slider {
            background-color: var(--primary);
        }

        input:checked+.slider:before {
            transform: translateX(18px);
        }

        /* Fix per header calendario desktop */
        #calendarModal .modal-content {
            padding: 0;
            /* Rimuoviamo padding interno per gestire meglio l'header */
        }

        .calendar-day-group {
            margin-bottom: 2rem;
            padding: 0 1rem;
        }

        .calendar-date-header {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--primary);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.5rem;
            margin-bottom: 1rem;
            display: flex;
            justify-content: space-between;
        }

        .calendar-still {
            width: 100%;
            height: 100%;
            object-fit: cover;
            background-color: #2b2b2b;
            display: block;
        }

        .calendar-still-wrapper {
            background: linear-gradient(90deg, #222 25%, #333 50%, #222 75%);
            background-size: 200% 100%;
            animation: skeleton-loading 2s infinite linear;
            border-radius: 6px;
            overflow: hidden;
            width: 100px;
            height: 56px;
            flex-shrink: 0;
        }

        @keyframes skeleton-loading {
            0% {
                background-position: 200% 0;
            }

            100% {
                background-position: -200% 0;
            }
        }

        /* Forza il contenitore a non far uscire il contenuto */
        #calendarModal .modal-content {
            padding: 0 !important;
            display: flex;
            flex-direction: column;
            max-height: 85vh;
            /* Assicuriamo che non occupi tutto su desktop */
        }

        /* Il footer del calendario stile iOS sticky */
        .calendar-footer {
            padding: 1rem;
            background: var(--card-bg);
            border-top: 1px solid var(--border-color);
            margin-top: 0;
            width: 100%;
            box-sizing: border-box;
            display: flex;
            justify-content: center;
        }

        .full-width-btn {
            width: 100%;
            justify-content: center;
            height: 45px;
            font-size: 1rem;
            font-weight: 600;
        }

        #calendarList {
            padding: 1rem;
            padding-bottom: 2rem;
            flex: 1;
            overflow-y: auto;
        }

        .calendar-item {
            display: flex;
            gap: 1rem;
            background: var(--section-tint);
            border-radius: 10px;
            padding: 0.75rem;
            margin-bottom: 0.75rem;
            transition: transform 0.2s;
            cursor: pointer;
        }

        .calendar-item:active {
            transform: scale(0.98);
        }

        .calendar-still-wrapper {
            width: 120px;
            min-width: 120px;
            aspect-ratio: 16/9;
            border-radius: 6px;
            overflow: hidden;
            background: var(--border-color);
        }

        .calendar-still {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .calendar-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            min-width: 0;
        }

        .calendar-show-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .calendar-ep-title {
            font-size: 1rem;
            font-weight: 700;
            margin: 2px 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .calendar-ep-number {
            font-size: 0.85rem;
            color: var(--primary);
            font-weight: 600;
        }

        @media (max-width: 768px) {
            .calendar-still-wrapper {
                width: 100px;
                min-width: 100px;
            }

            .calendar-ep-title {
                font-size: 0.9rem;
            }
        }

        .modal-open {
            overflow: hidden;
        }

        /* Il contenuto del modale */
        .modal-content {
            background: var(--card-bg);
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;

            /* Animazione Mobile: sale dal basso */
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.25, 1, 0.5, 1);
            border-radius: 20px 20px 0 0;
            padding: 1.5rem;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }

        .modal.visible .modal-content {
            transform: translateY(0);
        }

        /* --- REGOLE DESKTOP --- */
        @media (min-width: 769px) {
            .modal {
                align-items: center;
                /* Centra nel desktop */
            }

            .modal-content {
                width: 90%;
                max-width: 800px;
                border-radius: 12px;
                /* Animazione Desktop: leggera comparsa con scala */
                transform: scale(0.9) translateY(20px);
                opacity: 0;
                transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.2s;
            }

            .modal.visible .modal-content {
                transform: scale(1) translateY(0);
                opacity: 1;
            }
        }

        #mediaManagementModal .modal-content {
            max-width: 800px;
        }

        #detailsModal .modal-content {
            max-width: 900px;
            padding: 0;
        }

        #episodesModal {
            z-index: 1001;
        }

        #episodesModal .modal-content {
            max-width: 1200px;
            height: 90vh;
            padding: 0;
        }

        #episodesModalContent {
            flex: 1;
            min-height: 0;
            overflow-y: auto;
        }

        #episodesModal h2 {
            margin: 1.5rem;
        }

        #actorModal {
            z-index: 1002;
        }

        #actorModal .modal-content {
            max-width: 700px;
            max-height: 80vh;
            overflow-y: auto;
        }

        #rewatchModal {
            z-index: 1003;
        }

        #rewatchModal .modal-content {
            max-width: 450px;
            text-align: center;
        }

        #updateProgressModal .modal-content {
            max-width: 500px;
            text-align: center;
        }

        #updateSummaryModal .modal-content {
            max-width: 500px;
        }

        #updateSummaryList {
            list-style: none;
            padding: 0;
            max-height: 40vh;
            overflow-y: auto;
        }

        #updateSummaryList li {
            padding: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        #updateSummaryList li:last-child {
            border-bottom: none;
        }


        input,
        select {
            padding: 0.5rem 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-color);
            color: var(--text-color);
            font-size: 1rem;
            box-sizing: border-box;
            margin: 0;
            height: 38px;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        input:focus,
        select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 2px rgba(42, 157, 143, 0.2);
        }

        .tmdb-results-container {
            max-height: 250px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 0.5rem;
            margin-top: 1rem;
        }

        .tmdb-result-item {
            display: flex;
            align-items: center;
            padding: 0.5rem;
            cursor: pointer;
            border-radius: 4px;
            margin-bottom: 0.25rem;
        }

        .tmdb-result-item:hover {
            background: rgba(0, 0, 0, 0.05);
        }

        .tmdb-poster-small {
            width: 40px;
            height: 60px;
            object-fit: cover;
            margin-right: 0.75rem;
            border-radius: 4px;
        }

        .empty-state {
            text-align: center;
            padding: 3rem 1rem;
            color: var(--text-secondary);
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            margin-top: 1rem;
        }

        .empty-state>i {
            font-size: 2.5rem;
            margin-bottom: 1rem;
        }

        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            background: var(--card-bg);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1002;
            display: none;
        }

        .notification.success {
            border-left: 4px solid var(--success);
        }

        .notification.error {
            border-left: 4px solid var(--danger);
        }

        .notification.warning {
            border-left: 4px solid var(--warning);
        }

        .modal-footer {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            margin-top: 1.5rem;
            padding: 1.5rem 1.5rem 0 1.5rem;
            border-top: 1px solid var(--border-color);
        }

        .details-backdrop {
            width: 100%;
            height: 250px;
            background-size: cover;
            background-position: center 25%;
            position: relative;
        }

        .details-backdrop::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(to top, var(--card-bg) 0%, rgba(0, 0, 0, 0.5) 100%);
        }

        .details-header {
            position: relative;
            display: flex;
            padding: 1.5rem;
            margin-top: -100px;
            z-index: 2;
        }

        #detailsModalPoster {
            width: 150px;
            height: 225px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            flex-shrink: 0;
            margin-right: 1.5rem;
        }

        .details-title-section {
            padding-top: 100px;
            display: flex;
            flex-direction: column;
            flex-grow: 1;
        }

        #detailsModalTitle {
            margin: 0;
            font-size: 1.75rem;
        }

        .details-ratings-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            margin-top: 0.75rem;
        }

        #detailsModalHeader-main {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 1rem;
        }

        #detailsModalMeta {
            margin-top: 0.5rem;
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .details-body {
            padding: 0 1.5rem 1.5rem 1.5rem;
        }

        .details-section-title {
            font-weight: 600;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.5rem;
            margin-bottom: 1rem;
            margin-top: 1.5rem;
        }

        #detailsModalOverview {
            line-height: 1.6;
        }

        .modal-close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            z-index: 3;
            cursor: pointer;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
        }

        .cast-scroller {
            display: flex;
            overflow-x: auto;
            gap: 1rem;
            padding-bottom: 1rem;
        }

        .actor-card {
            text-align: center;
            width: 100px;
            flex-shrink: 0;
            cursor: pointer;
        }

        .actor-photo {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            object-fit: cover;
            margin-bottom: 0.5rem;
            background-color: var(--border-color);
        }

        .actor-name,
        .actor-character {
            font-size: 0.8rem;
            user-select: text;
        }

        .actor-character {
            color: var(--text-secondary);
        }

        .seasons-container {
            display: flex;
            flex-direction: column;
        }

        .season-header {
            background-color: var(--section-tint);
            padding: 1rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            position: sticky;
            top: 0;
            z-index: 10;
            backdrop-filter: blur(10px);
        }

        .season-header:hover {
            background-color: rgba(42, 157, 143, 0.15);
        }

        .season-title-container {
            flex-grow: 1;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .season-title {
            font-weight: 700;
            font-size: 1.1rem;
        }

        /* New Badge for Season Rewatch */
        .season-rewatch-badge {
            color: var(--warning);
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .season-progress-text {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .season-actions {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .season-actions .btn {
            width: 32px;
            height: 32px;
            padding: 0;
            font-size: 0.9rem;
        }

        .season-episodes {
            display: block;
            overflow: hidden;
            transition: max-height 0.4s ease-in-out;
            max-height: 0;
        }

        .no-episodes-info {
            padding: 1rem;
            text-align: center;
            font-style: italic;
            color: var(--text-secondary);
        }

        /* --- NETFLIX STYLE EPISODE LIST (UPDATED) --- */
        .episode-item {
            display: flex;
            gap: 1rem;
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
            align-items: flex-start;
            cursor: pointer;
            transition: background 0.2s;
            position: relative;
        }

        .episode-item:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .episode-item:last-child {
            border-bottom: none;
        }

        .episode-still-wrapper {
            position: relative;
            width: 160px;
            min-width: 160px;
            aspect-ratio: 16/9;
            border-radius: 6px;
            overflow: hidden;
            background-color: var(--border-color);
            flex-shrink: 0;
        }

        .episode-still {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: filter 0.2s;
            display: block;
        }

        /* Overlay Checkmark */
        .episode-status-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .episode-status-overlay i {
            color: var(--primary);
            font-size: 2rem;
        }

        .episode-item.watched .episode-status-overlay {
            opacity: 1;
        }

        .episode-item.watched .episode-title {
            color: var(--primary);
        }

        /* Blur effect for spoilers logic */
        .episode-item .episode-overview,
        .episode-item .episode-still {
            transition: filter 0.3s;
        }

        .episode-title.spoiler {
            filter: blur(5px);
            user-select: none;
            cursor: default;
        }

        .episode-title.spoiler:hover {
            filter: blur(0);
            transition: filter 0.3s;
        }

        /* Blur overview if not watched */
        .episode-item:not(.watched) .episode-overview,
        .episode-item:not(.watched) .episode-still {
            filter: blur(4px);
        }

        .episode-item:not(.watched):hover .episode-overview,
        .episode-item:not(.watched):hover .episode-still {
            filter: blur(0);
        }

        .episode-details {
            flex-grow: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
        }

        .episode-meta-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .episode-number {
            font-weight: 700;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        /* --- CSS AGGIORNATO PER LISTA EPISODI --- */

        /* Contenitore sinistra: Numero Episodio + Data */
        .episode-meta-left {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        /* Contenitore destra: Solo Rewatch */
        .episode-meta-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Badge Data (Base) */
        .episode-date-badge {
            font-size: 0.7rem;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            gap: 3px;
            color: var(--text-secondary);
            /* Nessun bordo per la data normale per pulizia, o aggiungi border: 1px solid var(--border-color); */
        }

        .episode-date-badge i {
            font-size: 0.65rem;
        }

        /* Badge Countdown (Oggi, Domani, -3gg) */
        .episode-countdown-badge {
            font-size: 0.65rem;
            font-weight: 700;
            padding: 1px 5px;
            border-radius: 4px;
            text-transform: uppercase;
            margin-left: 2px;
            display: inline-block;
        }

        /* Colori Countdown */
        .episode-countdown-badge.today {
            background: rgba(42, 157, 143, 0.15);
            color: var(--success);
            border: 1px solid var(--success);
        }

        .episode-countdown-badge.future {
            background: rgba(244, 162, 97, 0.15);
            color: var(--warning);
            border: 1px solid var(--warning);
        }

        /* Badge Rewatch (Arancione) */
        .episode-rewatch-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 3px;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            border: 1px solid var(--warning);
            /* Bordo Arancione */
            background: rgba(244, 162, 97, 0.1);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
            min-width: 24px;
            /* Stabilità visiva */
            height: 20px;
        }

        .episode-rewatch-badge.zero-count {
            border-color: var(--border-color);
            background: transparent;
            opacity: 0.5;
        }

        .episode-rewatch-badge.zero-count:hover {
            opacity: 1;
            border-color: var(--warning);
            background: rgba(244, 162, 97, 0.1);
        }

        .episode-rewatch-badge .count {
            font-weight: 700;
            color: var(--warning);
        }

        .episode-rewatch-badge i {
            color: var(--warning);
            font-size: 0.7rem;
        }

        .episode-rewatch-badge:hover {
            background: rgba(244, 162, 97, 0.25);
        }

        /* Fix per mobile: Area di tocco più grande */
        @media (max-width: 768px) {
            .episode-rewatch-badge {
                padding: 4px 8px;
                /* Più facile da toccare */
            }
        }

        /* Runtime (Accanto al titolo) */
        .episode-runtime-badge {
            font-size: 0.7rem;
            color: var(--text-secondary);
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            gap: 3px;
            margin-left: 6px;
            opacity: 0.8;
        }

        .episode-runtime-badge i {
            font-size: 0.65rem;
        }

        .episode-title {
            font-weight: 700;
            font-size: 1.1rem;
            line-height: 1.2;
            transition: color 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .episode-overview {
            font-size: 0.85rem;
            color: var(--text-secondary);
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
            transition: filter 0.2s;
        }

        /* Hidden inputs needed for logic */
        .episode-item input[type="checkbox"] {
            display: none;
        }


        #rewatchModal .modal-footer {
            margin-top: 1.5rem;
        }

        #rewatchModal .custom-rewatch-container {
            margin-top: 1.5rem;
            justify-content: center;
            display: flex;
            align-items: center;
        }

        #rewatchQuickButtons {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
            margin-top: 1rem;
        }

        .quick-rewatch-btn {
            padding: 0;
            width: 45px;
            height: 45px;
            justify-content: center;
        }

        .quick-rewatch-btn.active {
            background: var(--primary);
            color: white;
        }

        .number-input-wrapper {
            position: relative;
            display: flex;
            align-items: center;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            height: 38px;
        }

        .number-input-wrapper input {
            border: none;
            text-align: center;
            flex: 1;
            width: 100%;
            padding-right: 25px;
            background: var(--card-bg);
            -moz-appearance: textfield;
        }

        .number-input-wrapper input::-webkit-outer-spin-button,
        .number-input-wrapper input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .number-input-controls {
            position: absolute;
            right: 1px;
            top: 1px;
            bottom: 1px;
            display: flex;
            flex-direction: column;
            width: 24px;
        }

        .num-spinner-btn {
            flex: 1;
            width: 100%;
            border: none;
            background-color: var(--bg-color);
            color: var(--text-color);
            cursor: pointer;
            font-size: 0.8rem;
            line-height: 1;
            padding: 0;
            height: 50%;
        }

        .num-spinner-btn:hover {
            background-color: var(--primary);
            color: white;
        }

        .num-spinner-btn.up {
            border-top-right-radius: 7px;
        }

        .num-spinner-btn.down {
            border-bottom-right-radius: 7px;
        }

        .management-tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 1.5rem;
        }

        .tab-btn {
            padding: 0.75rem 1.5rem;
            background: transparent;
            border: none;
            cursor: pointer;
            font-weight: 600;
            color: var(--text-secondary);
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .tab-btn.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .management-form {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .management-form input {
            flex: 1;
        }

        .management-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .management-card {
            display: flex;
            align-items: center;
            padding: 0.75rem;
            border-radius: 8px;
            background: var(--bg-color);
            margin-bottom: 0.5rem;
        }

        .management-card>div:first-child {
            flex: 1;
            display: flex;
            align-items: center;
        }

        .management-card-actions {
            display: flex;
            gap: 0.5rem;
        }

        .management-card-actions .btn {
            padding: 0;
            justify-content: center;
            height: 32px;
            width: 32px;
        }

        #categoriesList .management-card-actions .btn {
            background: var(--secondary);
            color: white;
            border: none;
        }

        #categoriesList .management-card-actions .btn.btn-danger {
            background: var(--danger);
        }

        #categoriesList .management-card-actions .btn:hover {
            opacity: 0.85;
        }

        .category-name,
        .friend-email {
            font-weight: 600;
        }

        .friend-id {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .category-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 0.75rem;
            flex-shrink: 0;
        }

        .category-dot-0 {
            background: #2a9d8f;
        }

        .category-dot-1 {
            background: #e76f51;
        }

        .category-dot-2 {
            background: #f4a261;
        }

        .category-dot-3 {
            background: #e9c46a;
        }

        .category-dot-4 {
            background: #8338ec;
        }

        .category-dot-5 {
            background: #3a86ff;
        }

        #friendsList .management-card-actions .btn {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            color: var(--text-color);
        }

        #friendsList .management-card-actions .btn.visit-friend-films-btn:hover {
            background-color: var(--film-accent);
            color: white;
            border-color: var(--film-accent);
        }

        #friendsList .management-card-actions .btn.visit-friend-tv-btn:hover {
            background-color: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        #friendsList .management-card-actions .btn.remove-friend-btn:hover {
            background-color: var(--danger);
            color: white;
            border-color: var(--danger);
        }

        .context-menu {
            position: fixed;
            background: var(--card-bg);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1001;
            min-width: 240px;
            padding: 0.5rem 0;
            border: 1px solid var(--border-color);
            opacity: 0;
            transform: translateY(-10px);
            transition: opacity 0.15s, transform 0.15s;
        }

        .context-menu.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .context-menu-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 0.9rem;
        }

        .context-menu-item i.fa-fw {
            width: 20px;
            text-align: center;
        }

        .context-menu-item:hover {
            background: var(--primary);
            color: white;
        }

        .context-menu-divider {
            height: 1px;
            background: var(--border-color);
            margin: 0.25rem 0;
        }

        #posterModal .modal-content {
            max-width: 90vw;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .poster-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 1rem;
            padding: 0.5rem;
        }

        .poster-option {
            position: relative;
            cursor: pointer;
            transition: transform 0.2s;
            border: 3px solid transparent;
            border-radius: 8px;
            overflow: hidden;
        }

        .poster-option:hover {
            transform: scale(1.05);
        }

        .poster-option.selected {
            border-color: var(--primary);
        }

        .poster-option img {
            width: 100%;
            height: auto;
            display: block;
        }

        .poster-language-badge {
            position: absolute;
            bottom: 5px;
            right: 5px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .auth-container {
            position: relative;
        }

        .auth-form {
            position: absolute;
            top: calc(100% + 8px);
            right: 0;
            background: var(--card-bg);
            border-radius: 12px;
            padding: 1.5rem;
            width: 300px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            z-index: 1001;
            display: none;
        }

        .auth-form.active {
            display: block;
        }

        .auth-tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 1rem;
        }

        .auth-tab {
            padding: 0.75rem 1rem;
            cursor: pointer;
            font-weight: 600;
            color: var(--text-secondary);
            border-bottom: 2px solid transparent;
        }

        .auth-tab.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
        }

        .auth-form-container {
            display: none;
        }

        .auth-form-container.active {
            display: block;
        }

        .auth-form-container input {
            width: 100%;
            margin-bottom: 1rem;
        }

        .auth-form-buttons {
            display: flex;
            justify-content: flex-end;
            margin-top: 1rem;
        }

        .notification-bell-container {
            position: relative;
        }

        .notification-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background-color: var(--danger);
            color: white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            font-size: 0.7rem;
            font-weight: 700;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 2px solid var(--bg-color);
            transform: scale(0);
            transition: transform 0.2s ease-out;
        }

        .notification-badge.visible {
            transform: scale(1);
        }

        .notification-dropdown {
            position: absolute;
            top: calc(100% + 8px);
            right: 0;
            background: var(--card-bg);
            border-radius: 12px;
            width: 350px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            z-index: 1001;
            display: none;
            border: 1px solid var(--border-color);
            overflow: hidden;
            max-height: 400px;
            flex-direction: column;
        }

        .notification-dropdown.visible {
            display: flex;
        }

        .notification-header {
            padding: 0.75rem 1rem;
            font-weight: 600;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .notification-list {
            flex: 1;
            max-height: 300px;
            overflow-y: auto;
        }

        .notification-item {
            padding: 0.75rem 1rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .notification-item:hover {
            background-color: var(--section-tint);
        }

        .notification-item i.film-notification {
            color: var(--film-accent);
        }

        .notification-item i.tv-notification {
            color: var(--primary);
        }

        .notification-item-text {
            flex: 1;
        }

        .no-notifications {
            padding: 1.5rem;
            text-align: center;
            color: var(--text-secondary);
        }

        .notification-footer {
            padding: 0.5rem;
            text-align: center;
            border-top: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .view-mode-banner {
            display: none;
            align-items: center;
            background: var(--primary);
            color: white;
            padding: 0.75rem 1.5rem;
            margin-bottom: 1.5rem;
            border-radius: 8px;
        }

        .actor-details-header {
            display: flex;
            gap: 1.5rem;
            margin-bottom: 1.5rem;
            align-items: flex-start;
        }

        .actor-details-photo {
            width: 120px;
            height: 180px;
            object-fit: cover;
            border-radius: 8px;
            flex-shrink: 0;
        }

        .actor-details-info ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .actor-details-info li {
            margin-bottom: 0.5rem;
        }

        .btn-imdb {
            background: #f5c518;
            color: #000;
            margin-top: 1rem;
        }

        .filmography-scroller {
            display: flex;
            overflow-x: auto;
            gap: 1rem;
            padding-bottom: 1rem;
        }

        .film-card-small {
            width: 120px;
            flex-shrink: 0;
            cursor: pointer;
        }

        .film-card-small img {
            width: 100%;
            height: 180px;
            object-fit: cover;
            border-radius: 4px;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .film-card-small:hover img {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .film-card-small-title {
            font-size: 0.8rem;
            margin-top: 0.5rem;
            white-space: normal;
            text-align: center;
        }

        .form-row {
            display: flex;
            gap: 0.75rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .form-row input[type="text"],
        .form-row select {
            flex: 1;
            min-width: 200px;
        }

        .form-row .btn {
            flex-shrink: 0;
        }

        #updateProgressModal .modal-content {
            max-width: 500px;
            text-align: center;
        }

        #updateProgressBar {
            width: 100%;
            height: 20px;
            background-color: var(--border-color);
            border-radius: 10px;
            overflow: hidden;
            margin: 1rem 0;
        }

        #updateProgressBarFill {
            width: 0%;
            height: 100%;
            background-color: var(--primary);
            transition: width 0.2s;
        }

        #updateProgressText {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        /* START: Bottom Navigation Bar Styles */
        .bottom-nav {
            display: none;
            /* Hidden by default, shown in media query */
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 60px;
            background-color: var(--card-bg);
            border-top: 1px solid var(--border-color);
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
            z-index: 999;
            justify-content: space-around;
            align-items: center;
        }

        .bottom-nav-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex-grow: 1;
            height: 100%;
            font-size: 0.7rem;
            cursor: pointer;
            transition: color 0.2s;
            position: relative;
        }

        .bottom-nav-btn i {
            font-size: 1.25rem;
            margin-bottom: 0.2rem;
        }

        .bottom-nav-btn.active,
        .bottom-nav-btn:hover {
            color: var(--primary);
        }

        .bottom-nav-btn.add-btn {
            color: white;
            background-color: var(--primary);
            width: 56px;
            height: 56px;
            border-radius: 50%;
            margin-bottom: 25px;
            box-shadow: 0 4px 12px rgba(42, 157, 143, 0.4);
            flex-grow: 0;
        }

        .bottom-nav-btn.add-btn i {
            font-size: 1.5rem;
            margin: 0;
        }

        .notification-badge-mobile {
            position: absolute;
            top: 2px;
            right: 15px;
            background-color: var(--danger);
            color: white;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            font-size: 0.7rem;
            font-weight: 700;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 2px solid var(--card-bg);
            transform: scale(0);
            transition: transform 0.2s ease-out;
        }

        .notification-badge-mobile.visible {
            transform: scale(1);
        }

        /* END: Bottom Navigation Bar Styles */

        /* START: Mobile Menu and Notifications Modals Styles */
        #mobileMenuModal .modal-content,
        #filterSortModal .modal-content,
        #categoryNavModal .modal-content {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            border-radius: 20px 20px 0 0;
            transform: translateY(100%);
            transition: transform 0.3s ease-out;
            margin: 0;
            width: 100%;
            box-sizing: border-box;
        }

        #mobileMenuModal,
        #filterSortModal,
        #categoryNavModal {
            align-items: flex-end;
            background: rgba(0, 0, 0, 0.4);
        }

        #mobileMenuModal.visible .modal-content,
        #filterSortModal.visible .modal-content,
        #categoryNavModal.visible .modal-content {
            transform: translateY(0);
        }

        .mobile-menu-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .mobile-menu-list .btn {
            width: 100%;
            justify-content: flex-start;
            background-color: var(--section-tint);
            color: var(--text-color);
        }

        .mobile-menu-list .btn i {
            width: 24px;
            text-align: center;
            color: var(--primary);
        }

        .update-section {
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border-color);
            text-align: center;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .update-section .btn {
            width: 100%;
            margin-top: 0.5rem;
        }

        #mobileNotificationsModal {
            align-items: flex-end;
            /* Position modal at the bottom */
            background: rgba(0, 0, 0, 0.4);
        }

        #mobileNotificationsModal .modal-content {
            width: 100%;
            max-width: none;
            height: 75vh;
            border-radius: 16px 16px 0 0;
            margin: 0;
            box-shadow: 0 -5px 20px rgba(0, 0, 0, 0.15);
            transform: translateY(100%);
            transition: transform 0.3s ease-out;
        }

        #mobileNotificationsModal.visible .modal-content {
            transform: translateY(0);
        }

        .filter-modal-section {
            margin-bottom: 1rem;
        }

        .filter-modal-section label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }

        .filter-modal-section select {
            width: 100%;
        }

        /* END: Mobile Menu and Notifications Modals Styles */
    </style>

    <style>
        @media (max-width: 768px) {
            body {
                padding: 0.5rem;
                padding-bottom: 80px;
                /* Spazio per la bottom nav */
                -webkit-text-size-adjust: 100%;
            }

            /* 1. NASCONDI TUTTA LA PARTE DESTRA (Pulsanti Desktop) */
            .top-bar-right {
                display: none !important;
            }

            /* 2. SISTEMA LA BARRA SUPERIORE */
            .top-bar {
                padding: 0.5rem 0.75rem;
                margin-bottom: 0.5rem;
                height: auto;
                min-height: 60px;
                display: flex;
                align-items: center;
            }

            /* 3. RIGA UNICA: Switch - Search - Filter */
            .top-bar-left {
                display: flex !important;
                flex-direction: row !important;
                flex-wrap: nowrap !important;
                width: 100% !important;
                gap: 10px !important;
                align-items: center !important;
                justify-content: space-between !important;
            }

            /* Lo Switch a sinistra */
            .tracker-switch {
                flex-shrink: 0 !important;
                order: 1;
            }

            /* La barra di ricerca al centro che si espande */
            .search-box {
                flex-grow: 1 !important;
                min-width: 0 !important;
                /* Permette il restringimento */
                width: 100% !important;
                max-width: none !important;
                margin: 0 !important;
                order: 2;
                height: 40px;
            }

            /* Il tasto filtro a destra */
            #mobileFilterBtn {
                display: flex !important;
                flex-shrink: 0 !important;
                order: 3;
                width: 40px;
                height: 40px;
                padding: 0;
                justify-content: center;
                align-items: center;
            }

            /* Nascondi titoli e select nativi */
            #topBarTitle,
            .top-bar-left h1,
            .top-bar-left .filter-select {
                display: none !important;
            }

            /* --- STATS MOBILE: 12-COLUMN GRID FOR FULLWIDTH --- */
            .stats-panel {
                padding: 0.75rem;
                margin-bottom: 1rem;
            }

            .stats-container {
                display: grid;
                grid-template-columns: repeat(12, 1fr);
                /* 12 columns total */
                gap: 0.8rem;
                /* Increased gap to match desktop spacing */
                padding-bottom: 0;
            }

            .stat-item {
                padding: 0.5rem 0.2rem;
                width: 100%;
                /* Occupy full cell width */
                min-height: 60px;
                border-radius: 12px;
            }

            .stat-value {
                font-size: 1.3rem;
            }

            .stat-label::after {
                font-size: 1.1rem;
            }

            /* Row 1: 4 items (3 cols each -> 12 total) */
            .stat-item:nth-child(1),
            .stat-item:nth-child(2),
            .stat-item:nth-child(3),
            .stat-item:nth-child(4) {
                grid-column: span 3;
            }

            /* Row 2: 4 items (3 cols each -> 12 total) */
            .stat-item:nth-child(5),
            .stat-item:nth-child(6),
            .stat-item:nth-child(7),
            .stat-item:nth-child(8) {
                grid-column: span 3;
            }

            /* --- GRIGLIA SERIE --- */
            .media-section {
                padding: 0;
                background: transparent;
                margin-bottom: 1rem;
            }

            .section-header {
                padding: 0 0.5rem 0.5rem 0.5rem;
                margin-bottom: 0.5rem;
            }

            .media-grid {
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
                gap: 0.75rem;
                padding: 0 0.25rem;
            }

            .media-card {
                width: auto;
                box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
            }

            .media-title {
                font-size: 0.8rem;
            }

            .media-meta,
            .media-ratings {
                display: none;
            }

            .progress-text {
                display: flex;
                justify-content: space-between;
                font-size: 0.7rem;
                color: var(--text-secondary);
                margin-top: 2px;
            }

            .progress-text .mobile-imdb-rating {
                display: inline-block;
            }

            .progress-bar-container {
                height: 3px;
                margin-top: 4px;
            }

            /* --- MODALE DETTAGLI SERIE (CENTRATO) --- */
            #detailsModal .modal-content {
                padding: 0;
                width: 100%;
                height: 100vh;
                border-radius: 0;
                overflow-y: auto;
            }

            .details-header {
                flex-direction: column;
                align-items: center;
                margin-top: -90px;
                padding: 1rem;
                text-align: center;
            }

            #detailsModalPoster {
                width: 130px;
                height: 195px;
                margin: 0 0 1rem 0;
                border: 2px solid rgba(255, 255, 255, 0.2);
                box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
            }

            .details-title-section {
                padding: 0;
                width: 100%;
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            #detailsModalHeader-main {
                flex-direction: column;
                width: 100%;
                gap: 0.5rem;
                align-items: center;
            }

            #detailsModalTitle {
                font-size: 1.75rem;
                text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
                text-align: center;
                width: 100%;
                line-height: 1.2;
            }

            .details-ratings-container {
                justify-content: center;
                margin-bottom: 1rem;
                width: 100%;
            }

            #detailsModalHeader-main>div:last-child {
                display: flex;
                justify-content: center;
                gap: 1rem;
                width: 100%;
                margin-top: 0.5rem;
            }

            #detailsModalHeader-main>div:last-child .btn {
                flex: 0 1 auto;
                padding: 0.6rem 1.2rem;
            }

            #detailsModalMeta {
                justify-content: center;
                font-size: 0.8rem;
                opacity: 0.8;
            }

            .details-body {
                padding: 0 1rem 2rem 1rem;
            }

            /* --- LISTA EPISODI --- */
            #episodesModal .modal-content {
                height: 100vh;
                width: 100%;
                border-radius: 0;
                padding: 0;
                display: flex;
                flex-direction: column;
            }

            #episodesModalContent {
                padding: 0;
                overflow-y: auto;
                flex: 1;
            }

            .season-header {
                position: sticky;
                top: 0;
                z-index: 10;
                border-radius: 0;
                margin: 0;
                padding: 1rem;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            }

            .episode-item {
                padding: 0.75rem;
                gap: 0.75rem;
            }

            .episode-still-wrapper {
                width: 130px;
                min-width: 130px;
            }

            .episode-title {
                font-size: 0.9rem;
            }

            .episode-overview {
                -webkit-line-clamp: 2;
                font-size: 0.8rem;
            }

            /* --- HIDE CLOSE BUTTONS ON MOBILE (USE BACK GESTURE) --- */
            #detailsModal .modal-close-btn,
            #episodesModal .modal-close-btn,
            #actorModal .modal-close-btn,
            #posterModal .modal-close-btn {
                display: none;
            }


            /* --- NOTIFICHE --- */
            #mobileNotificationsModal {
                justify-content: flex-end;
                background: rgba(0, 0, 0, 0.6);
            }

            #mobileNotificationsModal .modal-content {
                width: 95%;
                margin: 0 auto 85px auto;
                border-radius: 16px;
                height: auto;
                max-height: 60vh;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            }

            .notification-list {
                max-height: 40vh;
            }

            .notification-item {
                padding: 1rem;
                border-bottom: 1px solid var(--border-color);
            }

            /* --- BOTTOM NAV --- */
            .bottom-nav {
                display: flex;
                height: 60px;
                background: var(--card-bg);
                border-top: 1px solid var(--border-color);
            }

            .bottom-nav-btn.add-btn {
                transform: translateY(-15px);
                border: 4px solid var(--bg-color);
                width: 56px;
                height: 56px;
                margin-bottom: 25px;
                border-radius: 50%;
                box-shadow: 0 4px 12px rgba(42, 157, 143, 0.4);
            }
        }
    </style>
    <!-- END: Mobile-Friendly CSS Rules -->
</head>

<body class="dark user-select-none">

    <div id="appLoader"><i class="fas fa-spinner loading-spinner"></i></div>

    <div id="viewModeBanner" class="view-mode-banner">
        <i class="fas fa-eye" style="margin-right: 0.75rem;"></i>
        <span id="viewModeUserEmail">Stai visualizzando una libreria condivisa</span>
        <button id="closeViewBtn" class="btn btn-danger" style="margin-left:auto"><i class="fas fa-times"></i>
            Esci</button>
    </div>

    <div class="top-bar">
        <div class="top-bar-left">
            <h1 id="topBarTitle"><i class="fas fa-tv"></i> Serie TV</h1>
            <div class="tracker-switch">
                <a href="index.html" class="tracker-switch-btn" title="Vai a Film Tracker"><i
                        class="fas fa-film"></i></a>
                <a href="serietv_tracker.html" class="tracker-switch-btn active" title="Vai a Serie TV Tracker"><i
                        class="fas fa-tv"></i></a>
            </div>

            <!-- Spostato qui: tra lo switch e il tasto filtro -->
            <input type="text" id="searchInput" class="search-box" placeholder="Cerca...">

            <button id="mobileFilterBtn" class="btn btn-secondary"><i class="fas fa-filter"></i></button>
            <select id="categoryFilter" class="filter-select">
                <option value="all">Tutte le categorie</option>
                <option value="favorites">Solo Preferiti</option>
            </select>
            <select id="sortFilter" class="filter-select">
                <option value="added" selected>Ultime attività</option>
                <option value="alpha">Alfabetico</option>
                <option value="rating">Valutazione</option>
                <option value="year">Anno di uscita</option>
            </select>
        </div>
        <div class="top-bar-right">
            <button id="mediaManagementBtn" class="btn btn-primary" title="Gestione"><i
                    class="fas fa-plus"></i></button>

            <!-- AGGIUNTO IL CALENDARIO ANCHE SU DESKTOP -->
            <button id="calendarBtn" class="btn btn-secondary" title="Calendario Uscite"><i
                    class="fas fa-calendar-alt"></i></button>

            <button id="settingsBtn" class="btn btn-secondary" title="Impostazioni Dati">
                <i class="fas fa-cog"></i>
            </button>

            <div class="notification-bell-container" id="notificationBellContainer" style="display: none;">
                <button id="bellIcon" class="btn btn-secondary" title="Notifiche"><i class="fas fa-bell"></i></button>
                <div id="notificationBadge" class="notification-badge">0</div>
                <div id="notificationDropdown" class="notification-dropdown"></div>
            </div>

            <button id="shareBtn" class="btn btn-secondary" title="Condividi Libreria"><i
                    class="fas fa-share-alt"></i></button>

            <button id="themeToggle" class="btn btn-secondary" title="Cambia Tema"><i class="fas fa-moon"></i></button>

            <div id="userInfo" style="display:none;"><button id="logoutBtn" class="btn btn-danger" title="Logout"><i
                        class="fas fa-sign-out-alt"></i></button></div>
            <button id="authToggle" class="btn btn-secondary" title="Login / Registrati"><i
                    class="fas fa-user"></i></button>
        </div>
    </div>

    <!-- STATS PANEL (ICONS) -->
    <div class="stats-panel">
        <div class="stats-container">
            <div class="stat-item" title="Totale">
                <i class="fas fa-tv stat-icon"></i>
                <span class="stat-name">Totale</span>
                <div class="stat-value" id="statTotal">0</div>
            </div>
            <div class="stat-item" title="Da Vedere">
                <i class="fas fa-bookmark stat-icon"></i>
                <span class="stat-name">Da Vedere</span>
                <div class="stat-value" id="statDaVedere">0</div>
            </div>
            <div class="stat-item" title="In Corso">
                <i class="fas fa-play-circle stat-icon"></i>
                <span class="stat-name">In Corso</span>
                <div class="stat-value" id="statInCorso">0</div>
            </div>
            <div class="stat-item" title="Completate">
                <i class="fas fa-check-circle stat-icon"></i>
                <span class="stat-name">Completate</span>
                <div class="stat-value" id="statCompletate">0</div>
            </div>
            <div class="stat-item" title="In Pausa / Droppata">
                <i class="fas fa-pause-circle stat-icon"></i>
                <span class="stat-name">In Pausa / Droppata</span>
                <div class="stat-value" id="statInPausaDroppata">0</div>
            </div>
            <div class="stat-item" title="Episodi Visti">
                <i class="fas fa-eye stat-icon"></i>
                <span class="stat-name">Episodi Visti</span>
                <div class="stat-value" id="statEpisodiVisti">0</div>
            </div>
            <div class="stat-item" title="Episodi Rivisti">
                <i class="fas fa-sync-alt stat-icon"></i>
                <span class="stat-name">Episodi Rivisti</span>
                <div class="stat-value" id="statEpisodiRivisti">0</div>
            </div>
            <div class="stat-item" title="Tempo Totale">
                <i class="fas fa-clock stat-icon"></i>
                <span class="stat-name">Tempo Totale</span>
                <div class="stat-value" id="statTempoTotale">0h</div>
            </div>
        </div>
    </div>

    <div id="mediaSectionsContainer"></div>

    <div class="modal" id="mediaManagementModal">
        <div class="modal-content">
            <div class="management-tabs">
                <button class="tab-btn active" data-tab="add-media"><i class="fas fa-plus"></i> Aggiungi
                    Serie</button>
                <button class="tab-btn" data-tab="manage-categories"><i class="fas fa-list-ol"></i> Gestisci
                    Categorie</button>
                <button class="tab-btn" data-tab="manage-friends"><i class="fas fa-user-friends"></i> Amici</button>
            </div>
            <div class="tab-content active" id="add-media-tab">
                <h2>Aggiungi una nuova Serie TV</h2>
                <div class="add-media-form">
                    <div class="form-row">
                        <input type="text" id="mediaTitle" placeholder="Titolo serie TV...">
                        <select id="addMediaCategorySelect"></select>
                        <button id="searchTMDbBtn" class="btn btn-secondary"><i class="fas fa-search"></i>
                            Cerca</button>
                    </div>
                    <div id="tmdbResults" class="tmdb-results-container"></div>
                </div>
            </div>
            <div class="tab-content" id="manage-categories-tab">
                <h2>Gestisci Categorie</h2>
                <div class="management-form">
                    <input type="text" id="newCategoryName" placeholder="Nuova categoria">
                    <button id="addCategoryBtn" class="btn btn-primary"><i class="fas fa-plus"></i>
                        Aggiungi</button>
                </div>
                <div class="management-list" id="categoriesList"></div>
            </div>
            <div class="tab-content" id="manage-friends-tab">
                <div id="myIdContainer" class="management-section"
                    style="padding: 1rem; border: 1px solid var(--border-color); border-radius: 8px; text-align: center; margin-bottom: 1.5rem;">
                    <h4>Il tuo ID univoco</h4>
                    <p style="font-size: 0.9rem; color: var(--text-secondary);">Condividi questo ID con i tuoi amici
                        per
                        permettergli di seguirti.</p>
                    <div style="display: flex; gap: 0.5rem; justify-content: center;">
                        <input type="text" id="myIdInput" readonly
                            style="text-align: center; background-color: var(--bg-color);">
                        <button id="copyMyIdBtn" class="btn btn-primary"><i class="fas fa-copy"></i> Copia</button>
                    </div>
                </div>
                <div class="management-section">
                    <div class="management-form">
                        <input type="text" id="friendIdInput" placeholder="Incolla l'ID di un amico">
                        <button id="addFriendBtn" class="btn btn-primary"><i class="fas fa-user-plus"></i>
                            Aggiungi</button>
                    </div>
                    <div class="management-list" id="friendsList"></div>
                </div>
            </div>
            <div class="update-section" id="updateSectionDesktop" style="display: none;">
                <p id="lastUpdateTimestampDesktop"></p>
                <button id="forceUpdateBtnDesktop" class="btn btn-secondary">Forza Aggiornamento Giornaliero</button>
                <button id="viewHistoryBtnDesktop" class="btn btn-primary" style="margin-top: 0.5rem; width: 100%;">
                    <i class="fas fa-history"></i> Cronologia Aggiornamenti
                </button>
            </div>
            <div class="modal-footer" style="border-top: none; padding-top: 0; justify-content: flex-end;">
                <button id="closeManagementModal" class="btn btn-danger">Chiudi</button>
                <button id="addShowBtn" class="btn btn-primary"><i class="fas fa-plus"></i> Aggiungi Serie</button>
            </div>
        </div>
    </div>

    <div class="modal" id="detailsModal">
        <div class="modal-content"><button class="modal-close-btn" id="detailsModalClose"><i
                    class="fas fa-times"></i></button>
            <div id="detailsModalContent"></div>
        </div>
    </div>
    <div class="modal" id="episodesModal">
        <div class="modal-content"><button class="modal-close-btn" id="episodesModalClose"><i
                    class="fas fa-times"></i></button>
            <div id="episodesModalContent"></div>
        </div>
    </div>
    <div class="modal" id="actorModal">
        <div class="modal-content"><button class="modal-close-btn" id="actorModalClose"><i
                    class="fas fa-times"></i></button>
            <div id="actorModalContent"></div>
        </div>
    </div>
    <div class="modal" id="posterModal">
        <div class="modal-content">
            <h2 id="posterModalTitle">Cambia Copertina</h2>
            <div class="poster-grid" id="posterGrid"></div>
            <div class="modal-footer" style="padding: 1.5rem 0 0 0;"><button id="cancelPosterChange"
                    class="btn btn-danger">Annulla</button><button id="savePosterChange" class="btn btn-primary">Salva
                    Selezione</button></div>
        </div>
    </div>
    <div class="modal" id="confirmModal">
        <div class="modal-content" style="max-width: 400px;">
            <h2 id="confirmModalTitle"></h2>
            <p id="confirmModalBody"></p>
            <div id="confirmModalButtons" style="display:flex; justify-content:flex-end; gap:0.5rem; margin-top:1rem;">
                <button id="confirmModalCancel" class="btn btn-secondary">Annulla</button><button
                    id="confirmModalConfirm" class="btn btn-danger">Conferma</button>
            </div>
        </div>
    </div>
    <div class="modal" id="shareModal">
        <div class="modal-content" style="max-width: 450px;">
            <h2>Condividi la tua libreria</h2>
            <p>Chiunque abbia questo link potrà vedere la tua lista in tempo reale (sola lettura).</p><input type="text"
                id="shareLinkInput" readonly style="width:100%">
            <div style="display: flex; gap: 0.5rem; margin-top: 1rem;"><button id="copyShareLinkBtn"
                    class="btn btn-primary">Copia Link</button><button id="closeShareModalBtn"
                    class="btn btn-danger">Chiudi</button></div>
        </div>
    </div>
    <div class="modal" id="dropModal">
        <div class="modal-content" style="max-width: 400px;">
            <h2>Segna come Droppata</h2>
            <p>In quale categoria vuoi spostare questa serie?</p>
            <select id="dropCategorySelect" class="form-control" style="margin-bottom: 1.5rem;"></select>
            <div class="modal-footer">
                <button id="cancelDropBtn" class="btn btn-danger">Annulla</button>
                <button id="confirmDropBtn" class="btn btn-primary">Conferma</button>
            </div>
        </div>
    </div>

    <div class="modal" id="rewatchModal">
        <div class="modal-content">
            <h2 id="rewatchModalTitle">Modifica Rewatch</h2>
            <p>Specifica il numero di volte che hai rivisto (0 = visto una sola volta).</p>
            <div id="rewatchQuickButtons">
                <button class="btn btn-secondary quick-rewatch-btn" data-count="0">0</button>
                <button class="btn btn-secondary quick-rewatch-btn" data-count="1">1</button>
                <button class="btn btn-secondary quick-rewatch-btn" data-count="2">2</button>
                <button class="btn btn-secondary quick-rewatch-btn" data-count="3">3</button>
                <button class="btn btn-secondary quick-rewatch-btn" data-count="4">4</button>
                <button class="btn btn-secondary quick-rewatch-btn" data-count="5">5</button>
            </div>
            <div class="custom-rewatch-container">
                <label for="rewatchCountInput">Numero custom:</label>
                <div class="number-input-wrapper" style="width: 120px;">
                    <input type="number" id="rewatchCountInput" min="0" value="0">
                    <div class="number-input-controls">
                        <button class="num-spinner-btn up" data-target="rewatchCountInput">+</button>
                        <button class="num-spinner-btn down" data-target="rewatchCountInput">-</button>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button id="cancelRewatchBtn" class="btn btn-danger">Annulla</button>
                <button id="confirmRewatchBtn" class="btn btn-primary">Salva</button>
            </div>
        </div>
    </div>

    <div class="modal" id="updateProgressModal">
        <div class="modal-content">
            <h2 id="updateProgressTitle">Aggiornamento in corso...</h2>
            <div id="updateProgressBar">
                <div id="updateProgressBarFill"></div>
            </div>
            <p id="updateProgressText">Inizializzazione...</p>
        </div>
    </div>

    <!-- Mobile "More Options" Modal -->
    <div class="modal" id="mobileMenuModal">
        <div class="modal-content">
            <h2 style="text-align: center; margin-top: 0;">Altre Opzioni</h2>
            <div class="mobile-menu-list">
                <button class="btn" id="mobileMenuUserActionBtn"><i class="fas fa-user"></i><span>Login /
                        Registrati</span></button>
                <button class="btn" id="mobileMenuShareBtn"><i class="fas fa-share-alt"></i>Condividi
                    Libreria</button>
                <button class="btn" id="mobileSettingsBtn">
                    <i class="fas fa-cog"></i>Gestione Dati & Backup
                </button>
                <button class="btn" id="mobileMenuThemeBtn"><i class="fas fa-moon"></i>Cambia Tema</button>
            </div>
            <div class="update-section">
                <p id="lastUpdateTimestampMobile"></p>
                <button id="forceUpdateBtnMobile" class="btn btn-secondary">Forza Aggiornamento Giornaliero</button>
                <button id="viewHistoryBtnMobile" class="btn btn-primary" style="margin-top: 0.5rem; width: 100%;">
                    <i class="fas fa-history"></i> Cronologia Aggiornamenti
                </button>
            </div>
            <div class="modal-footer" style="border: none; padding-bottom: 0;">
                <button id="mobileMenuCloseBtn" class="btn btn-danger">Chiudi</button>
            </div>
        </div>
    </div>

    <!-- Mobile Notifications Modal -->
    <div class="modal" id="mobileNotificationsModal">
        <div class="modal-content">
            <div class="notification-header" style="text-align:center; position:relative;">
                Notifiche Amici
                <button class="modal-close-btn" id="mobileNotificationsCloseBtn"
                    style="background:none; color:var(--text-color); top:0.5rem; right:0.5rem;"><i
                        class="fas fa-times"></i></button>
            </div>
            <div class="notification-list" id="notificationListMobile"></div>
            <div class="notification-footer">
                <button id="markAllReadMobileBtn" class="btn btn-primary btn-small"><i class="fas fa-check-double"></i>
                    Segna tutte come lette</button>
            </div>
        </div>
    </div>

    <!-- Mobile Filter & Sort Modal -->
    <div class="modal" id="filterSortModal">
        <div class="modal-content">
            <h2 style="text-align: center; margin-top: 0;">Filtra e Ordina</h2>
            <div class="filter-modal-section">
                <label for="mobileCategoryFilter">Categoria</label>
                <select id="mobileCategoryFilter"></select>
            </div>
            <div class="filter-modal-section">
                <label for="mobileSortFilter">Ordina per</label>
                <select id="mobileSortFilter">
                    <option value="added" selected>Ultime attività</option>
                    <option value="alpha">Alfabetico</option>
                    <option value="rating">Valutazione</option>
                    <option value="year">Anno di uscita</option>
                </select>
            </div>
            <div class="modal-footer" style="border: none; padding-bottom: 0;">
                <button id="applyFiltersBtn" class="btn btn-primary">Applica</button>
            </div>
        </div>
    </div>

    <!-- Update Summary Modal -->
    <div class="modal" id="updateSummaryModal">
        <div class="modal-content">
            <h2 style="text-align:center; margin-top: 0;">Riepilogo Aggiornamenti</h2>
            <ul id="updateSummaryList"></ul>
            <div class="modal-footer" style="padding-top: 1rem; border: none;">
                <button id="closeSummaryBtn" class="btn btn-primary">OK</button>
            </div>
        </div>
    </div>

    <!-- Auth Modal -->
    <div class="modal" id="authModal">
        <div class="modal-content" style="max-width: 350px;">
            <h2 style="text-align: center; margin-top: 0;">Accedi</h2>

            <div class="auth-tabs">
                <div class="auth-tab active" data-tab="login">Login</div>
                <div class="auth-tab" data-tab="register">Registrati</div>
            </div>

            <div id="loginForm" class="auth-form-container active">
                <input type="email" id="loginEmail" placeholder="Email" style="width: 100%; margin-bottom: 1rem;">
                <input type="password" id="loginPassword" placeholder="Password"
                    style="width: 100%; margin-bottom: 1rem;">
                <button id="loginBtn" class="btn btn-primary" style="width: 100%;"><i class="fas fa-sign-in-alt"></i>
                    Login</button>
            </div>

            <div id="registerForm" class="auth-form-container">
                <input type="email" id="registerEmail" placeholder="Email" style="width: 100%; margin-bottom: 1rem;">
                <input type="password" id="registerPassword" placeholder="Password (min. 6 car.)"
                    style="width: 100%; margin-bottom: 1rem;">
                <input type="password" id="registerConfirmPassword" placeholder="Conferma Password"
                    style="width: 100%; margin-bottom: 1rem;">
                <button id="registerBtn" class="btn btn-primary" style="width: 100%;"><i class="fas fa-user-plus"></i>
                    Registrati</button>
            </div>

            <div class="modal-footer">
                <button class="btn btn-danger"
                    onclick="closeModal(document.getElementById('authModal'))">Chiudi</button>
            </div>
        </div>
    </div>

    <div id="notification" class="notification"><span id="notificationText"></span></div>

    <!-- Category Navigation Modal (Mobile) -->
    <div class="modal" id="categoryNavModal">
        <div class="modal-content">
            <h2 style="text-align: center; margin-top: 0;">Vai a Categoria</h2>
            <div id="categoryNavList" class="mobile-menu-list">
                <!-- Categories will be dynamically populated here -->
            </div>
            <div class="modal-footer" style="border: none; padding-bottom: 0;">
                <button id="closeCategoryNavBtn" class="btn btn-danger">Chiudi</button>
            </div>
        </div>
    </div>

    <!-- Bottom Navigation Bar for Mobile -->
    <div class="bottom-nav" id="bottomNav">
        <button class="bottom-nav-btn active" id="bottomNavHome" title="Liste">
            <i class="fas fa-list-ul"></i>
            <span>Liste</span>
        </button>

        <!-- Inseriamo qui il tasto Calendario al posto di Cerca -->
        <button class="bottom-nav-btn" id="bottomNavCalendar" title="Calendario">
            <i class="fas fa-calendar-day"></i>
            <span>Calendario</span>
        </button>

        <button class="bottom-nav-btn add-btn" id="bottomNavAdd" title="Aggiungi Serie">
            <i class="fas fa-plus"></i>
        </button>

        <button class="bottom-nav-btn" id="bottomNavNotifications" title="Notifiche">
            <i class="fas fa-bell"></i>
            <span class="notification-badge-mobile" id="notificationBadgeMobile">0</span>
            <span>Notifiche</span>
        </button>

        <button class="bottom-nav-btn" id="bottomNavManage" title="Altro">
            <i class="fas fa-ellipsis-h"></i>
            <span>Altro</span>
        </button>
    </div>

    <div class="modal" id="settingsModal">
        <div class="modal-content" style="max-width: 500px;">
            <h2 style="text-align: center; margin-top: 0;">Centro Manutenzione</h2>

            <div class="settings-grid">
                <!-- EXPORT -->
                <div class="settings-card export-card" id="exportAction">
                    <div class="settings-icon"><i class="fas fa-download"></i></div>
                    <div class="settings-info">
                        <span class="settings-title">Esporta Dati</span>
                        <span class="settings-desc">Scarica un backup locale (JSON)</span>
                    </div>
                </div>

                <!-- IMPORT -->
                <div class="settings-card import-card" id="importAction">
                    <div class="settings-icon"><i class="fas fa-upload"></i></div>
                    <div class="settings-info">
                        <span class="settings-title">Importa Dati</span>
                        <span class="settings-desc">Ripristina da un file salvato</span>
                    </div>
                </div>

                <!-- RESET -->
                <div class="settings-card reset-card" id="resetAction">
                    <div class="settings-icon"><i class="fas fa-trash-alt"></i></div>
                    <div class="settings-info">
                        <span class="settings-title">Resetta Tracker</span>
                        <span class="settings-desc">Cancella tutto (Azione irreversibile)</span>
                    </div>
                </div>
                <!-- Spostato qui per assicurarne il caricamento -->
                <input type="file" id="importFile" accept=".json" style="display: none;">
            </div>

            <div id="lastBackupBadge" class="last-backup-info">
                <i class="fas fa-history"></i> Ultimo backup: <span>Mai eseguito</span>
            </div>

            <div class="modal-footer" style="border-top: none;">
                <button onclick="closeModal(document.getElementById('settingsModal'))" class="btn btn-secondary"
                    style="width: 100%;">Chiudi</button>
            </div>
        </div>
    </div>

    <script>
        const OMDb_API_KEY = "2526ef70";
        const TMDB_KEY = atob("MmNkOGJiNDgzYWIxMjE0ZDY2MDIwZTcwYjBhMzZmYTQ=");
        const MDBLIST_PROXY_URL = "https://serietvtracker.amrit-singh99mail-5e3.workers.dev";

        const DEFAULT_POSTER = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMDAiIGhlaWdodD0iNDUwIiB2aWV3Qm94PSIwIDAgMzAwIDQ1MCI+PHJlY3Qgd2lkdGg9IjMwMCIgaGVpZ2h0PSI0NTAiIGZpbGw9IiNkZGQiLz48dGV4dCB4PSIxNTAiIHk9IjIyNSIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjE2IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSIjNjY2Ij5OZXNzYSBpbWFnaW5lPC90ZXh0Pjwvc3ZnPg==";
        const DEFAULT_ACTOR_PHOTO = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI4MCIgaGVpZ2h0PSI4MCIgdmlld0JveD0iMCAwIDgwIDgwIj48cmVjdCB3aWR0aD0iODAiIGhlaWdodD0iODAiIGZpbGw9IiNkZGQiLz48cGF0aCBkPSJtNDAgMzZhNC44IDQuOCAwIDEgMCAwLTkuNiA0LggNC44IDAgMCAwIDAgOS42em0wIDEuNmMtNC40MiAwLTgtMy41OC04LThzMy41OC04IDgtOCA4IDMuNTggOCA4LTMuNTggOC04IDh6bS0xMy4zMyAxNC44N2ExMi4wMiAxMi4wMiAwIDAgMCAyNi42NiAwYy0uNDctMi4wMi0yLjY4LTMuNTgtNS4zMy00LjA3LTEuMy0uMjUtMi42Ny0uNS00LS43My0xLjMzLS4yMy0yLjctLjMzLTQtLjMzcy0yLjY3LjEtNCwuMzNjLTEuMzMuMjItMi43LjQ4LTQgLjczLTIuNjUuNS00Ljg2IDIuMDYtNS4zMyA0LjA3eiIgZmlsbD0iIzY2NiIvPjwvc3ZnPg==";
        const EMPTY_STILL_PLACEHOLDER = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMDAiIGhlaWdodD0iMTY5IiB2aWV3Qm94PSIwIDAgMzAwIDE2OSI+PHJlY3Qgd2lkdGg9IjMwMCIgaGVpZ2h0PSIxNjkiIGZpbGw9IiMyYjJiMmIiLz48cGF0aCBkPSJNMTQwIDg1bDUtNXYxMGwtNS01em0yNSAwbC01LTV2MTBsNS01eiIgZmlsbD0iIzQ0NCIvPjwvc3ZnPg==";
        const IMDB_STAR_ICON = "https://upload.wikimedia.org/wikipedia/commons/2/29/Gold_Star.svg";
        const ROTTEN_TOMATOES_ICONS = { certified: "https://upload.wikimedia.org/wikipedia/uk/b/b2/Certified_Fresh_2018.svg", fresh: "https://upload.wikimedia.org/wikipedia/commons/5/5b/Rotten_Tomatoes.svg", rotten: "https://upload.wikimedia.org/wikipedia/commons/5/52/Rotten_Tomatoes_rotten.svg" };
        const POPCORN_ICONS = { positive: "https://upload.wikimedia.org/wikipedia/commons/d/da/Rotten_Tomatoes_positive_audience.svg", negative: "https://upload.wikimedia.org/wikipedia/commons/6/63/Rotten_Tomatoes_negative_audience.svg" };
        const LETTERBOXD_ICON = "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTH45TgrphrMnMTlMx9wpG_Jj7JoBzrI9zAfg&s";
        const METACRITIC_ICON = "https://upload.wikimedia.org/wikipedia/commons/f/f2/Metacritic_M.png";
        const firebaseConfig = { apiKey: "AIzaSyDm946nISfZs8ugkuYPraNTzFhvgQmnMUk", authDomain: "gametrackerdb.firebaseapp.com", databaseURL: "https://gametrackerdb-default-rtdb.europe-west1.firebasedatabase.app", projectId: "gametrackerdb" };
        const MAX_LOG_SIZE = 15;
        const MAX_NOTIFICATIONS = 50;

        const DEFAULT_CATEGORIES = ["In Corso", "Completate", "Da Vedere"];
        let mediaList = [], categories = [], currentTMDbSelection = null, debounceTimeout, lazyLoadObserver, currentShowCache = null;
        let calendarOnlyInCorso = true;
        let updateHistory = JSON.parse(localStorage.getItem('updateHistory') || "[]");
        let currentUser = null, isViewMode = false, followedFriends = [], friendListeners = {};
        let lastCheckedTimestamps = {};
        let statContributorIds = new Set();
        let ignoredDuplicateIds = new Set();
        let currentRewatchContext = {};
        let isUpdateInProgress = false; // Il nostro "semaforo" per gli aggiornamenti

        const getDefaultShowProps = () => ({
            category: 'Da Vedere', addedAt: new Date().toISOString(), lastActivityAt: null, poster: "",
            year: "", imdbID: null, tmdbID: null, imdbRating: "N/A", rottenTomatoes: "N/A", popcornRating: "N/A", metacriticRating: "N/A", letterboxdRating: "N/A", status: "Unknown",
            seasons: {}, progress: {}, rewatches: {}, isFavorite: false, italianTitle: null,
            includeSpecialsInProgress: false // Nuova proprietà per la logica degli speciali
        });

        const elements = {
            appLoader: document.getElementById("appLoader"), mediaManagementBtn: document.getElementById("mediaManagementBtn"),
            settingsBtn: document.getElementById("settingsBtn"),
            mobileSettingsBtn: document.getElementById("mobileSettingsBtn"),
            importFile: document.getElementById("importFile"),
            themeToggle: document.getElementById("themeToggle"), searchInput: document.getElementById("searchInput"),
            categoryFilter: document.getElementById("categoryFilter"), sortFilter: document.getElementById("sortFilter"),
            statTotal: document.getElementById("statTotal"), statFollowing: document.getElementById("statInCorso"),
            statCompleted: document.getElementById("statCompletate"), statToWatch: document.getElementById("statDaVedere"),
            statPaused: document.getElementById("statInPausaDroppata"),
            statEpisodes: document.getElementById("statEpisodiVisti"),
            statEpisodiRivisti: document.getElementById("statEpisodiRivisti"), // NEW STATISTIC
            statHours: document.getElementById("statTempoTotale"),
            mediaSectionsContainer: document.getElementById("mediaSectionsContainer"), mediaManagementModal: document.getElementById("mediaManagementModal"),
            mediaTitle: document.getElementById("mediaTitle"), searchTMDbBtn: document.getElementById("searchTMDbBtn"), tmdbResults: document.getElementById("tmdbResults"),
            addShowBtn: document.getElementById("addShowBtn"), closeManagementModal: document.getElementById("closeManagementModal"), notification: document.getElementById("notification"), notificationText: document.getElementById("notificationText"),
            detailsModal: document.getElementById('detailsModal'), detailsModalContent: document.getElementById('detailsModalContent'), detailsModalClose: document.getElementById('detailsModalClose'),
            episodesModal: document.getElementById('episodesModal'), episodesModalContent: document.getElementById('episodesModalContent'), episodesModalClose: document.getElementById('episodesModalClose'),
            actorModal: document.getElementById('actorModal'), actorModalContent: document.getElementById('actorModalContent'), actorModalClose: document.getElementById('actorModalClose'),
            posterModal: document.getElementById('posterModal'), posterGrid: document.getElementById('posterGrid'), savePosterChange: document.getElementById('savePosterChange'),
            cancelPosterChange: document.getElementById('cancelPosterChange'), confirmModal: document.getElementById("confirmModal"), confirmModalTitle: document.getElementById("confirmModalTitle"),
            confirmModalBody: document.getElementById("confirmModalBody"), confirmModalConfirm: document.getElementById("confirmModalConfirm"), confirmModalCancel: document.getElementById("confirmModalCancel"),
            categoriesList: document.getElementById("categoriesList"),
            newCategoryName: document.getElementById("newCategoryName"), addCategoryBtn: document.getElementById("addCategoryBtn"),
            addMediaCategorySelect: document.getElementById("addMediaCategorySelect"),
            authModal: document.getElementById('authModal'), authToggle: document.getElementById('authToggle'),
            loginBtn: document.getElementById('loginBtn'), registerBtn: document.getElementById('registerBtn'),
            logoutBtn: document.getElementById('logoutBtn'), userInfo: document.getElementById('userInfo'),
            shareBtn: document.getElementById('shareBtn'), shareModal: document.getElementById('shareModal'),
            copyShareLinkBtn: document.getElementById('copyShareLinkBtn'), closeShareModalBtn: document.getElementById('closeShareModalBtn'),
            viewModeBanner: document.getElementById('viewModeBanner'), viewModeUserEmail: document.getElementById('viewModeUserEmail'), closeViewBtn: document.getElementById('closeViewBtn'),
            addFriendBtn: document.getElementById('addFriendBtn'), friendsList: document.getElementById('friendsList'), friendIdInput: document.getElementById('friendIdInput'),
            myIdInput: document.getElementById('myIdInput'), copyMyIdBtn: document.getElementById('copyMyIdBtn'),
            notificationBellContainer: document.getElementById('notificationBellContainer'), bellIcon: document.getElementById('bellIcon'),
            notificationDropdown: document.getElementById('notificationDropdown'),
            notificationBadge: document.getElementById('notificationBadge'),
            rewatchModal: document.getElementById("rewatchModal"), rewatchModalTitle: document.getElementById("rewatchModalTitle"),
            rewatchCountInput: document.getElementById("rewatchCountInput"), confirmRewatchBtn: document.getElementById("confirmRewatchBtn"), cancelRewatchBtn: document.getElementById("cancelRewatchBtn"),
            dropModal: document.getElementById("dropModal"), dropCategorySelect: document.getElementById("dropCategorySelect"),
            confirmDropBtn: document.getElementById("confirmDropBtn"), cancelDropBtn: document.getElementById("cancelDropBtn"),
            updateProgressModal: document.getElementById('updateProgressModal'),
            updateProgressBarFill: document.getElementById('updateProgressBarFill'),
            updateProgressText: document.getElementById('updateProgressText'),
            updateProgressTitle: document.getElementById('updateProgressTitle'),
            updateSummaryModal: document.getElementById('updateSummaryModal'),
            updateSummaryList: document.getElementById('updateSummaryList'),
            closeSummaryBtn: document.getElementById('closeSummaryBtn'),
            // Bottom Nav Bar Elements
            bottomNavAdd: document.getElementById('bottomNavAdd'),
            bottomNavManage: document.getElementById('bottomNavManage'),
            bottomNavCalendar: document.getElementById('bottomNavCalendar'),
            bottomNavNotifications: document.getElementById('bottomNavNotifications'),
            bottomNavHome: document.getElementById('bottomNavHome'),
            notificationBadgeMobile: document.getElementById('notificationBadgeMobile'),
            // Mobile Modals and Buttons
            mobileMenuModal: document.getElementById('mobileMenuModal'),
            mobileMenuCloseBtn: document.getElementById('mobileMenuCloseBtn'),
            mobileMenuUserActionBtn: document.getElementById('mobileMenuUserActionBtn'),
            mobileMenuShareBtn: document.getElementById('mobileMenuShareBtn'),
            mobileMenuExportBtn: document.getElementById('mobileMenuExportBtn'),
            mobileMenuImportBtn: document.getElementById('mobileMenuImportBtn'),
            mobileMenuThemeBtn: document.getElementById('mobileMenuThemeBtn'),
            mobileMenuResetBtn: document.getElementById('mobileMenuResetBtn'),
            mobileNotificationsModal: document.getElementById('mobileNotificationsModal'),
            mobileNotificationsCloseBtn: document.getElementById('mobileNotificationsCloseBtn'),
            notificationListMobile: document.getElementById('notificationListMobile'),
            markAllReadMobileBtn: document.getElementById('markAllReadMobileBtn'),
            // Filter Modal
            filterSortModal: document.getElementById('filterSortModal'),
            mobileFilterBtn: document.getElementById('mobileFilterBtn'),
            mobileCategoryFilter: document.getElementById('mobileCategoryFilter'),
            mobileSortFilter: document.getElementById('mobileSortFilter'),
            applyFiltersBtn: document.getElementById('applyFiltersBtn'),
            // Update Section
            forceUpdateBtnDesktop: document.getElementById('forceUpdateBtnDesktop'),
            forceUpdateBtnMobile: document.getElementById('forceUpdateBtnMobile'),
            lastUpdateTimestampDesktop: document.getElementById('lastUpdateTimestampDesktop'),
            lastUpdateTimestampMobile: document.getElementById('lastUpdateTimestampMobile'),
            updateSectionDesktop: document.getElementById('updateSectionDesktop'),
            // Category Navigation Modal
            categoryNavModal: document.getElementById('categoryNavModal'),
            categoryNavList: document.getElementById('categoryNavList'),
            closeCategoryNavBtn: document.getElementById('closeCategoryNavBtn')
        };

        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();

        document.addEventListener("DOMContentLoaded", init);

        function init() {
            setupEventListeners();
            loadTheme();
            loadSortOrder();
            updateSwitcherLinksInViewMode();
            handleViewMode() || setupAuthListeners();
        }

        function updateSwitcherLinksInViewMode() {
            const params = new URLSearchParams(window.location.search);
            const viewId = params.get('view');
            if (viewId) {
                const filmTrackerLink = document.querySelector('.tracker-switch-btn[href="index.html"]');
                const tvTrackerLink = document.querySelector('.tracker-switch-btn[href="serietv_tracker.html"]');
                if (filmTrackerLink) filmTrackerLink.href = `index.html?view=${viewId}`;
                if (tvTrackerLink) tvTrackerLink.href = `serietv_tracker.html?view=${viewId}`;
            }
        }

        function addToUpdateHistory(changes) {
            if (!changes || changes.length === 0) return;

            const newEntry = {
                timestamp: new Date().toISOString(),
                items: changes // l'array di stringhe con i cambiamenti
            };

            updateHistory.unshift(newEntry); // Aggiunge in cima
            updateHistory = updateHistory.slice(0, 50); // Mantiene solo gli ultimi 50 aggiornamenti

            localStorage.setItem('updateHistory', JSON.stringify(updateHistory));

            // Se l'utente è loggato, salviamo anche su Firebase
            if (currentUser) {
                const path = `users/${currentUser.uid}/updateHistory`;
                db.ref(path).set(updateHistory);
            }
        }

        function renderUpdateHistory() {
            const container = document.getElementById('historyList');
            if (!container) return;

            if (updateHistory.length === 0) {
                container.innerHTML = `<p style="text-align:center; color:var(--text-secondary); padding: 2rem;">Nessun aggiornamento registrato.</p>`;
                return;
            }

            container.innerHTML = updateHistory.map(entry => `
                <div style="margin-bottom: 1.5rem; border-bottom: 1px solid var(--border-color); padding-bottom: 0.5rem;">
                    <div style="font-size: 0.8rem; color: var(--primary); font-weight: bold; margin-bottom: 0.5rem;">
                        <i class="fas fa-clock"></i> ${new Date(entry.timestamp).toLocaleString('it-IT')}
                    </div>
                    <ul style="margin: 0; padding-left: 1.2rem; font-size: 0.9rem;">
                        ${entry.items.map(item => `<li style="margin-bottom: 0.3rem;">${item}</li>`).join('')}
                    </ul>
                </div>
            `).join('');
        }

        function hideLoader() { elements.appLoader.style.opacity = '0'; setTimeout(() => elements.appLoader.style.display = 'none', 300); }

        function loadData() {
            if (!currentUser) return;
            const path = `users/${currentUser.uid}`;
            db.ref(`${path}/tvShowTracker`).on("value", snapshot => {
                const data = snapshot.val() || {};
                mediaList = (data.mediaList || []).map(item => {
                    const cleanItem = { ...getDefaultShowProps(), ...item };
                    if (typeof cleanItem.seasons !== 'object' || cleanItem.seasons === null) {
                        cleanItem.seasons = {}; // Bonifica dati vecchi
                    }
                    return cleanItem;
                });
                categories = (data.categories || DEFAULT_CATEGORIES.map(name => ({ name, hideProgress: false }))).map(cat => (typeof cat === 'string') ? { name: cat, hideProgress: false } : cat);
                if (!isViewMode) {
                    renderFullUI();
                    triggerNewEpisodeCheck();
                    updateAllShowsInBackground();
                }
            });

            db.ref(`${path}/social`).once("value", snapshot => {
                const data = snapshot.val() || {};
                followedFriends = data.followedFriends || [];
                lastCheckedTimestamps = data.lastCheckedTimestamps || {};
                if (!isViewMode) {
                    setupFriendListeners();
                    renderFriendsList();
                }
            });

            // Sincronizzazione Storico Firebase
            db.ref(`${path}/updateHistory`).on("value", snapshot => {
                if (snapshot.exists()) {
                    updateHistory = snapshot.val();
                    localStorage.setItem('updateHistory', JSON.stringify(updateHistory));
                }
            });

            hideLoader();
        }

        function renderCalendar() {
            const container = document.getElementById('calendarList');
            if (!container) return;
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            let allEpisodes = [];

            mediaList.forEach(show => {
                // FILTRO: Se lo switch è attivo, mostra solo "In Corso"
                if (calendarOnlyInCorso && show.category !== "In Corso") return;

                // Escludiamo comunque le droppate a prescindere
                if (show.isDropped) return;

                Object.keys(show.seasons).forEach(sNum => {
                    const season = show.seasons[sNum];
                    (season.episodes || []).forEach(ep => {
                        if (!ep.air_date) return;

                        const airDate = new Date(ep.air_date);
                        const diffTime = airDate - today;
                        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

                        // Mostriamo da 2 giorni fa a 30 giorni nel futuro
                        if (diffDays >= -2 && diffDays <= 30) {
                            allEpisodes.push({
                                showId: show.id,
                                showTitle: show.title,
                                season: sNum,
                                episode: ep.episode_number,
                                name: ep.name,
                                airDate: ep.air_date,
                                dateObj: airDate,
                                still: ep.still_path ? `https://image.tmdb.org/t/p/w300${ep.still_path}` : EMPTY_STILL_PLACEHOLDER,
                                diffDays: diffDays
                            });
                        }
                    });
                });
            });

            allEpisodes.sort((a, b) => a.dateObj - b.dateObj);

            if (allEpisodes.length === 0) {
                container.innerHTML = `<div class="empty-state" style="text-align:center; padding: 3rem; color: var(--text-secondary);">
                    <i class="fas fa-calendar-times" style="font-size: 3rem; margin-bottom: 1rem; opacity: 0.5;"></i>
                    <p>Nessun episodio trovato con questi filtri.</p>
                </div>`;
                return;
            }

            let html = '';
            let currentDay = '';

            allEpisodes.forEach(ep => {
                const epDateStr = ep.dateObj.toLocaleDateString('it-IT', { weekday: 'long', day: 'numeric', month: 'long' });

                if (epDateStr !== currentDay) {
                    if (currentDay !== '') html += `</div>`;
                    html += `
                        <div class="calendar-day-group">
                            <div class="calendar-date-header">
                                <span>${epDateStr}</span>
                                <span style="font-size: 0.75rem; font-weight: 500; text-transform: uppercase;">${getRelativeDayLabel(ep.diffDays)}</span>
                            </div>`;
                    currentDay = epDateStr;
                }

                html += `
                    <div class="calendar-item" onclick="closeModal(document.getElementById('calendarModal')); setTimeout(() => showDetailsModal('${ep.showId}'), 300)">
                        <div class="calendar-still-wrapper">
                            <img src="${ep.still}" class="calendar-still" onerror="this.src='${EMPTY_STILL_PLACEHOLDER}'">
                        </div>
                        <div class="calendar-info">
                            <div class="calendar-show-title">${ep.showTitle}</div>
                            <div class="calendar-ep-title">${ep.name || 'Episodio ' + ep.episode}</div>
                            <div class="calendar-ep-number">S${ep.season} · Episodio ${ep.episode}</div>
                        </div>
                    </div>`;
            });

            html += '</div>';
            container.innerHTML = html;
        }

        function getRelativeDayLabel(diff) {
            if (diff === 0) return "OGGI";
            if (diff === 1) return "DOMANI";
            if (diff === -1) return "IERI";
            if (diff < 0) return `${Math.abs(diff)} GIORNI FA`;
            return `TRA ${diff} GIORNI`;
        }

        function loadLocalData() {
            try {
                const localList = JSON.parse(localStorage.getItem("tvShowList") || "[]");
                mediaList = localList.map(item => {
                    const cleanItem = { ...getDefaultShowProps(), ...item };
                    if (typeof cleanItem.seasons !== 'object' || cleanItem.seasons === null) {
                        cleanItem.seasons = {}; // Bonifica dati vecchi
                    }
                    return cleanItem;
                });
                const storedCategories = JSON.parse(localStorage.getItem("tvShowCategories") || JSON.stringify(DEFAULT_CATEGORIES.map(name => ({ name, hideProgress: false }))));
                categories = storedCategories.map(cat => (typeof cat === 'string') ? { name: cat, hideProgress: false } : cat);
                renderFullUI();
                updateAllShowsInBackground();
            } catch (err) {
                mediaList = [];
                categories = DEFAULT_CATEGORIES.map(name => ({ name, hideProgress: false }));
                renderFullUI();
            }
        }

        async function saveData() {
            if (isViewMode) return;
            if (currentUser) {
                return db.ref(`users/${currentUser.uid}/tvShowTracker`).set({ mediaList, categories });
            } else {
                try {
                    localStorage.setItem("tvShowList", JSON.stringify(mediaList));
                    localStorage.setItem("tvShowCategories", JSON.stringify(categories));
                } catch (err) {
                    showNotification("Errore nel salvataggio dei dati", "error");
                }
                return Promise.resolve();
            }
        }

        function saveSocialData() {
            if (isViewMode || !currentUser) return;
            return db.ref(`users/${currentUser.uid}/social`).set({ followedFriends, lastCheckedTimestamps });
        }

        function renderFullUI() {
            renderCategorySections();
            updateCategoryFilter();
            updateStats();
            renderMedia();
            displayLastUpdateTime();
        }

        function calculateProgress(show) {
            const watchedEpisodes = Object.keys(show.progress || {}).length;

            // Se la modalità speciale è attiva, calcola il totale includendo TUTTI gli speciali
            if (show.includeSpecialsInProgress) {
                return {
                    watchedEpisodes,
                    totalEpisodes: Object.values(show.seasons || {}).reduce((sum, season) => sum + (season.episodes || []).length, 0)
                };
            }

            // Altrimenti, calcola il totale standard (solo stagioni > 0)
            const totalEpisodes = Object.entries(show.seasons || {})
                .filter(([seasonNum]) => parseInt(seasonNum) > 0)
                .reduce((sum, [, season]) => sum + (season.episodes || []).length, 0);

            return { watchedEpisodes, totalEpisodes };
        }


        function getRottenTomatoesState(score) { if (!score || score === "N/A") return null; const value = parseInt(String(score).replace('%', '')); return isNaN(value) ? null : value >= 75 ? "certified" : value >= 60 ? "fresh" : "rotten"; }
        function getPopcornState(score) { if (!score || score === "N/A") return null; const value = parseInt(String(score).replace('%', '')); return isNaN(value) ? null : value >= 60 ? "positive" : "negative"; }

        function sanitizeForId(text) {
            return text.replace(/[^a-zA-Z0-9]/g, '');
        }

        function updateStats() {
            statContributorIds.clear();
            ignoredDuplicateIds.clear();
            const processed = new Set();
            mediaList.forEach(media => {
                const uniqueId = (media.imdbID || media.tmdbID) || media.title.toLowerCase().trim();
                if (!uniqueId || processed.has(uniqueId)) return;
                processed.add(uniqueId);
                const instances = mediaList.filter(m => ((m.imdbID && m.imdbID === media.imdbID) || (m.tmdbID && m.tmdbID === media.tmdbID)) || (!m.imdbID && !m.tmdbID && m.title.toLowerCase() === media.title.toLowerCase()));
                let contributor = instances.find(m => DEFAULT_CATEGORIES.includes(m.category)) || instances[0];
                if (contributor) {
                    statContributorIds.add(contributor.id);
                    instances.forEach(inst => {
                        if (inst.id !== contributor.id) ignoredDuplicateIds.add(inst.id);
                    });
                }
            });

            const stats = { InCorso: 0, Completate: 0, DaVedere: 0, InPausaDroppata: 0, episodesWatched: 0, episodesRewatched: 0, minutesWatched: 0 };
            statContributorIds.forEach(id => {
                const show = mediaList.find(m => m.id === id);
                if (!show) return;

                if (show.isDropped) {
                    stats.InPausaDroppata++;
                } else {
                    const categoryKey = sanitizeForId(show.category);
                    if (stats.hasOwnProperty(categoryKey)) {
                        stats[categoryKey]++;
                    }
                }

                // Usiamo il conteggio degli episodi visti per le statistiche generali
                const watchedEpisodes = Object.keys(show.progress || {}).length;
                stats.episodesWatched += watchedEpisodes;

                // Calcolo episodi rivisti (somma dei conteggi)
                if (show.rewatches) {
                    const totalRewatches = Object.values(show.rewatches).reduce((sum, count) => sum + count, 0);
                    stats.episodesRewatched += totalRewatches;
                }

                if (show.seasons) {
                    Object.keys(show.progress).forEach(progressKey => {
                        const [seasonNum, episodeNum] = progressKey.split('-').map(Number);
                        const season = show.seasons[seasonNum];
                        if (season && season.episodes) {
                            const episode = season.episodes.find(e => e.episode_number == episodeNum);
                            if (episode && episode.runtime) {
                                const rewatches = show.rewatches?.[progressKey] || 0;
                                stats.minutesWatched += episode.runtime * (1 + rewatches);
                            }
                        }
                    });
                }
            });

            elements.statTotal.textContent = statContributorIds.size;
            elements.statFollowing.textContent = stats.InCorso || 0;
            elements.statCompleted.textContent = stats.Completate || 0;
            elements.statToWatch.textContent = stats.DaVedere || 0;
            elements.statPaused.textContent = stats.InPausaDroppata || 0;
            elements.statEpisodes.textContent = stats.episodesWatched;
            elements.statEpisodiRivisti.textContent = stats.episodesRewatched;

            const hours = Math.floor(stats.minutesWatched / 60);
            const minutes = stats.minutesWatched % 60;
            elements.statHours.textContent = `${hours}h ${minutes}m`;
        }

        function renderMedia() {
            const selectedCategory = elements.categoryFilter.value;
            const searchTerm = elements.searchInput.value.toLowerCase();
            const sortBy = elements.sortFilter.value;

            document.querySelectorAll(".media-section").forEach(s => s.style.display = 'block');
            document.querySelectorAll(".media-grid").forEach(g => g.innerHTML = '');

            let filteredMedia = [...mediaList];

            if (searchTerm) {
                filteredMedia = filteredMedia.filter(m =>
                    m.title.toLowerCase().includes(searchTerm) ||
                    (m.italianTitle && m.italianTitle.toLowerCase().includes(searchTerm))
                );
            }

            if (selectedCategory === 'favorites') {
                filteredMedia = filteredMedia.filter(m => m.isFavorite);
            } else if (selectedCategory !== 'all') {
                filteredMedia = filteredMedia.filter(m => m.category === selectedCategory);
            }

            filteredMedia.sort((a, b) => {
                switch (sortBy) {
                    case "alpha": return a.title.localeCompare(b.title);
                    case "rating": return (parseFloat(b.imdbRating) || 0) - (parseFloat(a.imdbRating) || 0);
                    case "year": return (b.year.split('–')[0] || 0) - (a.year.split('–')[0] || 0);
                    case "added":
                    default:
                        // Sort dropped shows to the bottom
                        if (a.isDropped && !b.isDropped) return 1;
                        if (!a.isDropped && b.isDropped) return -1;
                        return new Date(b.lastActivityAt || b.addedAt) - new Date(a.lastActivityAt || a.addedAt);
                }
            });

            filteredMedia.forEach(media => {
                const gridId = sanitizeForId(media.category) + "Grid";
                const grid = document.getElementById(gridId);
                if (grid) {
                    grid.appendChild(createMediaCard(media));
                }
            });

            let hasContent = false;
            categories.forEach(catObj => {
                const categoryName = catObj.name;
                const section = document.querySelector(`.media-section[data-category="${categoryName}"]`);
                if (!section) return;

                const grid = section.querySelector('.media-grid');
                const countEl = section.querySelector('.category-count');

                const count = grid.children.length;
                if (countEl) countEl.textContent = count;

                if (selectedCategory !== 'all' && selectedCategory !== 'favorites' && categoryName !== selectedCategory) {
                    section.style.display = 'none';
                } else if (count === 0 && selectedCategory === 'favorites') {
                    section.style.display = 'none';
                } else {
                    section.style.display = 'block';
                    hasContent = true;
                    if (grid.children.length === 0) {
                        grid.innerHTML = `<div class="empty-state"><i class="fas fa-tv"></i><p>Nessuna serie TV qui.</p></div>`;
                    }
                }
            });

            if (selectedCategory === 'favorites' && !filteredMedia.length) {
                renderCategorySections();
                elements.mediaSectionsContainer.innerHTML = `<div class="media-section"><div class="empty-state"><i class="fas fa-heart-crack"></i><p>Nessun preferito aggiunto.</p></div></div>`;
            } else if (selectedCategory === 'favorites' && filteredMedia.length > 0) {
                document.querySelectorAll('.media-section').forEach(s => {
                    if (s.querySelector('.media-grid').children.length === 0) s.style.display = 'none';
                })
            }

            setupLazyLoading();
        }


        function createMediaCard(show) {
            const card = document.createElement("div");
            card.className = "media-card";
            card.dataset.id = show.id;
            if (statContributorIds.has(show.id)) card.classList.add("is-stat-contributor");
            if (ignoredDuplicateIds.has(show.id)) card.classList.add("is-duplicate");

            card.addEventListener('click', (e) => {
                if (e.target.closest('.favorite-btn') || e.target.closest('.card-actions')) return;
                showDetailsModal(show.id)
            });
            card.addEventListener('contextmenu', e => { e.preventDefault(); showContextMenu(show, { x: e.clientX, y: e.clientY }); });
            const { watchedEpisodes, totalEpisodes } = calculateProgress(show);
            const percentage = totalEpisodes > 0 ? (watchedEpisodes / totalEpisodes) * 100 : 0;

            const rtState = getRottenTomatoesState(show.rottenTomatoes);
            const popcornState = getPopcornState(show.popcornRating);

            let progressBarClass = "progress-bar";
            if (show.status === "Ended" || show.status === "Canceled") {
                progressBarClass += " ended";
            }
            if (show.isDropped) {
                card.classList.add('dropped');
                progressBarClass += " dropped";
                // Force red counter for dropped shows
                const counter = card.querySelector('.unwatched-counter');
                if (counter) counter.style.backgroundColor = 'var(--danger)';
            }
            if (show.category === 'In Pausa / Droppata') {
                progressBarClass += " dropped";
            }

            let ratingsHTML = '';
            if (show.imdbRating && show.imdbRating !== "N/A") { ratingsHTML += `<span class="rating-badge"><img src="${IMDB_STAR_ICON}" class="rating-icon">&nbsp;${show.imdbRating}</span>`; }
            if (rtState) { ratingsHTML += `<span class="rating-badge"><img src="${ROTTEN_TOMATOES_ICONS[rtState]}" class="rating-icon">&nbsp;${show.rottenTomatoes}</span>`; }
            if (popcornState) { ratingsHTML += `<span class="rating-badge"><img src="${POPCORN_ICONS[popcornState]}" class="rating-icon">&nbsp;${show.popcornRating}</span>`; }

            const actionsHTML = isViewMode ? '' : `
        <div class="card-actions">
            <button class="card-btn" data-action="move" title="Sposta in..."><i class="fas fa-folder-open"></i></button>
            <button class="card-btn" data-action="delete" title="Elimina"><i class="fas fa-trash"></i></button>
        </div>`;

            const categoryObject = categories.find(c => c.name === show.category);
            const progressHTML = (categoryObject && categoryObject.hideProgress) ? '' : `
        <div class="media-progress">
          <div class="progress-bar-container"><div class="${progressBarClass}" style="width: ${percentage}%;"></div></div>
          <div class="progress-text">
            <span>${watchedEpisodes}/${totalEpisodes}</span>
            <span class="media-year-compact">${show.year}</span>
            ${(show.imdbRating && show.imdbRating !== "N/A") ? `<span class="mobile-imdb-rating"><i class="fas fa-star" style="color: #f5c518; font-size: 0.7rem;"></i> ${show.imdbRating}</span>` : ''}
          </div>
        </div>`;

            card.innerHTML = `
        <div class="poster-container">
            <img data-src="${show.poster || DEFAULT_POSTER}" class="media-poster lazy" onerror="this.src='${DEFAULT_POSTER}'">
            <button class="favorite-btn ${show.isFavorite ? 'is-favorite' : ''}" title="Aggiungi ai preferiti"><i class="fas fa-heart"></i></button>
            ${actionsHTML}
        </div>
        <div class="media-info">
          <h3 class="media-title" title="${show.title}">${show.title}</h3>
          <div class="media-meta">
            <span>${show.year}</span>
          </div>
          <div class="media-ratings">${ratingsHTML}</div>
          ${progressHTML}
        </div>`;

            card.querySelector('.favorite-btn').addEventListener('click', (e) => { e.stopPropagation(); toggleFavorite(show.id); });
            if (!isViewMode) {
                card.querySelector('[data-action="move"]').addEventListener("click", e => { e.stopPropagation(); showContextMenu(show, { x: e.clientX, y: e.clientY }); });
                card.querySelector('[data-action="delete"]').addEventListener("click", e => { e.stopPropagation(); deleteShow(show.id); });
            }
            return card;
        }

        function refreshSingleMedia(id) {
            const show = mediaList.find(m => m.id === id);
            if (!show) return;
            const oldCard = document.querySelector(`.media-card[data-id="${id}"]`);
            if (oldCard) {
                const oldCategory = oldCard.closest('.media-section').dataset.category;
                if (oldCategory !== show.category) {
                    renderMedia();
                } else {
                    const newCard = createMediaCard(show);
                    oldCard.parentElement.replaceChild(newCard, oldCard);
                    if (lazyLoadObserver) lazyLoadObserver.observe(newCard.querySelector(".lazy"));
                }
            } else {
                renderMedia();
            }
            updateStats();
        }

        async function addNewMedia(tmdbId) {
            showNotification("Recupero dettagli della serie...", "warning");
            try {
                const [enDetails, itDetails] = await Promise.all([
                    fetchFullTMDbDetails(tmdbId, 'en-US'),
                    fetchFullTMDbDetails(tmdbId, 'it-IT')
                ]);

                if (!enDetails) {
                    return showNotification("Dettagli della serie non trovati su TMDb.", "error");
                }

                const imdbID = enDetails.external_ids.imdb_id || null;
                const category = elements.addMediaCategorySelect.value;
                localStorage.setItem("lastUsedTvShowCategory", category);

                const isDuplicateInDefaultCategory = mediaList.some(m =>
                    ((imdbID && m.imdbID === imdbID) || m.tmdbID === tmdbId) && DEFAULT_CATEGORIES.includes(m.category)
                );
                if (DEFAULT_CATEGORIES.includes(category) && isDuplicateInDefaultCategory) {
                    return showNotification("Questa serie è già in una categoria principale.", "warning");
                }

                const isDuplicateInSameCategory = mediaList.some(m =>
                    ((imdbID && m.imdbID === imdbID) || m.tmdbID === tmdbId) && m.category === category
                );
                if (isDuplicateInSameCategory) {
                    return showNotification(`Questa serie è già in "${category}"`, "warning");
                }

                let newShow = {
                    ...getDefaultShowProps(),
                    id: Date.now().toString(),
                    title: enDetails.name,
                    italianTitle: itDetails ? itDetails.name : enDetails.name,
                    imdbID: imdbID,
                    tmdbID: tmdbId,
                    category: category,
                    poster: enDetails.poster_path ? `https://image.tmdb.org/t/p/w500${enDetails.poster_path}` : DEFAULT_POSTER,
                    addedAt: new Date().toISOString(),
                    lastActivityAt: new Date().toISOString()
                };

                const existingShow = mediaList.find(m => (imdbID && m.imdbID === imdbID) || (m.tmdbID === tmdbId));
                if (existingShow) {
                    newShow.progress = JSON.parse(JSON.stringify(existingShow.progress));
                    newShow.rewatches = JSON.parse(JSON.stringify(existingShow.rewatches || {}));
                }

                let omdbDetails = null;
                let mdbListRatings = null;
                if (newShow.imdbID) {
                    [omdbDetails, mdbListRatings] = await Promise.all([
                        getOMDbShowDetails(newShow.imdbID),
                        fetchMDBListRatings(newShow.imdbID)
                    ]);
                }

                const firstYear = enDetails.first_air_date ? enDetails.first_air_date.split('-')[0] : '';
                const status = enDetails.status;
                const lastYear = (status === 'Ended' || status === 'Canceled') && enDetails.last_air_date ? enDetails.last_air_date.split('-')[0] : '';

                if (firstYear && lastYear && firstYear !== lastYear) {
                    newShow.year = `${firstYear}–${lastYear}`;
                } else if (firstYear && (status === 'Returning Series' || status === 'In Production' || status === 'Planned')) {
                    newShow.year = `${firstYear} – In corso`;
                } else {
                    newShow.year = firstYear;
                }

                newShow.status = status;
                newShow.imdbRating = (omdbDetails?.imdbRating && omdbDetails.imdbRating !== "N/A") ? omdbDetails.imdbRating : (enDetails.vote_average ? enDetails.vote_average.toFixed(1) : "N/A");

                // Per le nuove serie, scarica solo le stagioni regolari per evitare di aggiungere speciali non richiesti
                const seasonPromises = enDetails.seasons
                    .filter(s => s.season_number > 0)
                    .map(s => fetchTMDbSeasonDetailsWithFallback(enDetails.id, s.season_number));

                const seasonsData = await Promise.all(seasonPromises);
                seasonsData.forEach(season => {
                    if (season) {
                        newShow.seasons[season.season_number] = {
                            name: season.name,
                            episodes: (season.episodes || []).map(ep => ({
                                name: ep.name,
                                overview: ep.overview,
                                episode_number: ep.episode_number,
                                runtime: ep.runtime || 0,
                                still_path: ep.still_path,
                                air_date: ep.air_date
                            }))
                        };
                    }
                });

                if (category === "Completate" && !existingShow) {
                    Object.keys(newShow.seasons).forEach(seasonNum => {
                        (newShow.seasons[seasonNum].episodes || []).forEach(ep => {
                            newShow.progress[`${seasonNum}-${ep.episode_number}`] = true;
                        });
                    });
                }

                if (mdbListRatings) {
                    const rtRating = mdbListRatings.find(r => r.source === 'tomatoes');
                    const popcornRating = mdbListRatings.find(r => r.source === 'tomatoesaudience');
                    const letterboxdRating = mdbListRatings.find(r => r.source === 'letterboxd');
                    const metacriticRating = mdbListRatings.find(r => r.source === 'metacritic');

                    if (rtRating) newShow.rottenTomatoes = rtRating.value;
                    if (popcornRating) newShow.popcornRating = popcornRating.value;
                    if (letterboxdRating) newShow.letterboxdRating = letterboxdRating.value;
                    if (metacriticRating) newShow.metacriticRating = metacriticRating.value;

                } else if (omdbDetails && omdbDetails.Ratings) {
                    const rt = omdbDetails.Ratings.find(r => r.Source === 'Rotten Tomatoes');
                    if (rt) newShow.rottenTomatoes = rt.Value;
                }

                mediaList.push(newShow);
                await logActivity('add_show', newShow.title, `alla categoria '${newShow.category}'`);
                await saveData();

                renderFullUI();
                showNotification(`"${newShow.title}" aggiunto!`, "success");
                closeModal(elements.mediaManagementModal);
            } catch (error) {
                console.error("Errore durante l'aggiunta della serie:", error);
                showNotification("Errore nel recuperare i dettagli della serie.", "error");
            }
        }

        async function getOMDbShowDetails(imdbId) { if (!imdbId) return null; const res = await fetch(`https://www.omdbapi.com/?apikey=${OMDb_API_KEY}&i=${imdbId}`); return res.ok ? await res.json() : null; }

        async function fetchTMDbDetailsWithFallback(imdbId) {
            let details = await fetchTMDbShowDetailsByIMDb(imdbId, 'it-IT');
            if (details && !details.overview) {
                const en_details = await fetchTMDbShowDetailsByIMDb(imdbId, 'en-US');
                if (en_details) details.overview = en_details.overview;
            }
            return details;
        }

        async function fetchTMDbShowDetailsByIMDb(imdbId, lang = 'it-IT') {
            if (!imdbId) return null;
            const findRes = await fetch(`https://api.themoviedb.org/3/find/${imdbId}?api_key=${TMDB_KEY}&external_source=imdb_id`);
            if (!findRes.ok) return null;
            const findData = await findRes.json();
            const tmdbShow = findData.tv_results[0];
            if (!tmdbShow) return null;
            return await fetchFullTMDbDetails(tmdbShow.id, lang);
        }

        async function fetchFullTMDbDetails(tmdbId, lang = 'en-US') {
            const detailsRes = await fetch(`https://api.themoviedb.org/3/tv/${tmdbId}?api_key=${TMDB_KEY}&language=${lang}&append_to_response=credits,external_ids`);
            return detailsRes.ok ? await detailsRes.json() : null;
        }

        async function fetchTMDbSeasonDetailsWithFallback(tvId, seasonNumber) {
            let season = await fetchTMDbSeasonDetails(tvId, seasonNumber, 'it-IT');
            if (season && (!season.overview || (season.episodes && season.episodes.some(e => !e.name || !e.overview)))) {
                const en_season = await fetchTMDbSeasonDetails(tvId, seasonNumber, 'en-US');
                if (en_season) {
                    if (!season.overview) season.overview = en_season.overview;
                    if (season.episodes) {
                        season.episodes.forEach((ep, index) => {
                            if (!ep.name && en_season.episodes[index]) ep.name = en_season.episodes[index].name;
                            if (!ep.overview && en_season.episodes[index]) ep.overview = en_season.episodes[index].overview;
                        });
                    }
                }
            }
            return season;
        }
        async function fetchTMDbSeasonDetails(tvId, seasonNumber, lang = 'it-IT') {
            const res = await fetch(`https://api.themoviedb.org/3/tv/${tvId}/season/${seasonNumber}?api_key=${TMDB_KEY}&language=${lang}`);
            return res.ok ? await res.json() : null;
        }

        async function fetchMDBListRatings(imdbId) {
            if (!imdbId || !MDBLIST_PROXY_URL || MDBLIST_PROXY_URL === "INCOLLA_L_URL_DEL_TUO_WORKER_QUI") return null;
            try {
                const res = await fetch(`${MDBLIST_PROXY_URL}?i=${imdbId}`);
                if (!res.ok) return null;
                const data = await res.json();
                return data.ratings || null;
            } catch (error) {
                console.error("Errore nel recupero dati da MDBList:", error);
                return null;
            }
        }

        async function fetchBestTMDbDetails(show) {
            let details = null;
            if (show.tmdbID) {
                details = await fetchFullTMDbDetails(show.tmdbID, 'it-IT');
                if (details && !details.overview) {
                    const en_details = await fetchFullTMDbDetails(show.tmdbID, 'en-US');
                    if (en_details) details.overview = en_details.overview;
                }
            } else if (show.imdbID) {
                details = await fetchTMDbDetailsWithFallback(show.imdbID);
            }
            return details;
        }

        async function forceRefreshShow(showId) {
            await showDetailsModal(showId, true);
        }

        async function showDetailsModal(showId, force = false) {
            const show = mediaList.find(m => m.id === showId);
            if (!show) return;

            if (!force) {
                openModal(elements.detailsModal);
                elements.detailsModalContent.innerHTML = `<div style="text-align: center; padding: 4rem;"><i class="fas fa-spinner fa-3x loading-spinner"></i></div>`;
            }

            const tmdbDetails = await fetchBestTMDbDetails(show);
            if (!tmdbDetails) {
                elements.detailsModalContent.innerHTML = "<p>Dettagli non trovati.</p>";
                return [];
            }

            let hasUpdates = false;
            let updateSummary = [];

            const firstYear = tmdbDetails.first_air_date ? tmdbDetails.first_air_date.split('-')[0] : '';
            const status = tmdbDetails.status;
            const lastYear = (status === 'Ended' || status === 'Canceled') && tmdbDetails.last_air_date ? tmdbDetails.last_air_date.split('-')[0] : '';
            let newYear = firstYear;
            if (firstYear && lastYear && firstYear !== lastYear) {
                newYear = `${firstYear}–${lastYear}`;
            } else if (firstYear && (status === 'Returning Series' || status === 'In Production' || status === 'Planned')) {
                newYear = `${firstYear} – In corso`;
            }
            if (show.year !== newYear) {
                show.year = newYear;
                hasUpdates = true;
            }
            if (show.status !== status) {
                show.status = status;
                hasUpdates = true;
                updateSummary.push(`<strong>${show.title}</strong>: Stato aggiornato a "${status}"`);
            }

            // --- SYNC LOGIC: Remove local seasons not on TMDb ---
            const apiSeasonNumbers = new Set(tmdbDetails.seasons.map(s => s.season_number));
            Object.keys(show.seasons).forEach(localSeasonNum => {
                const sNum = parseInt(localSeasonNum);
                if (!apiSeasonNumbers.has(sNum) && sNum !== 0) {
                    delete show.seasons[localSeasonNum];
                    hasUpdates = true;
                    updateSummary.push(`<strong>${show.title}</strong>: Rimossa Stagione ${sNum} (non più presente su TMDb)`);

                    // Pulizia dei progressi legati a quella stagione
                    if (show.progress) {
                        Object.keys(show.progress).forEach(progressKey => {
                            if (progressKey.startsWith(`${localSeasonNum}-`)) {
                                delete show.progress[progressKey];
                            }
                        });
                    }
                }
            });

            // CORREZIONE: Filtra le stagioni da aggiornare. Aggiorna solo gli speciali (stagione 0) SE esistono già nei dati locali.
            const seasonDetailPromises = tmdbDetails.seasons
                .filter(s => s.season_number > 0 || (show.seasons && show.seasons[s.season_number]))
                .map(s => fetchTMDbSeasonDetailsWithFallback(tmdbDetails.id, s.season_number));

            const allSeasonDetails = await Promise.all(seasonDetailPromises);

            allSeasonDetails.forEach(seasonDetails => {
                if (seasonDetails) {
                    const seasonNumber = seasonDetails.season_number;
                    const localSeason = show.seasons[seasonNumber];
                    const newEpisodeCount = (seasonDetails.episodes || []).length;
                    const oldEpisodeCount = (localSeason?.episodes || []).length;

                    if (!localSeason) {
                        updateSummary.push(`<strong>${show.title}</strong>: Aggiunta Stagione ${seasonNumber}`);
                    } else if (newEpisodeCount > oldEpisodeCount) {
                        updateSummary.push(`<strong>${show.title}</strong>: ${newEpisodeCount - oldEpisodeCount} nuovi episodi nella Stagione ${seasonNumber}`);
                    }

                    if (!localSeason || oldEpisodeCount !== newEpisodeCount || force) {
                        show.seasons[seasonNumber] = {
                            name: seasonDetails.name,
                            episodes: (seasonDetails.episodes || []).map(ep => ({
                                name: ep.name,
                                overview: ep.overview,
                                episode_number: ep.episode_number,
                                runtime: ep.runtime || 0,
                                still_path: ep.still_path,
                                air_date: ep.air_date
                            }))
                        };
                        hasUpdates = true;
                    }
                }
            });

            if (hasUpdates) {
                await saveData();
                renderMedia();
                updateStats();
                if (force) showNotification(`Dati aggiornati per ${show.title}!`, "success");
            }

            currentShowCache = { show, tmdbDetails };
            if (elements.detailsModal.style.display === 'flex') {
                populateDetailsModal(tmdbDetails, show);
            }

            return updateSummary;
        }

        function populateDetailsModal(details, media) {
            const backdropUrl = details.backdrop_path ? `https://image.tmdb.org/t/p/w1280${details.backdrop_path}` : '';
            const posterUrl = media.poster || (details.poster_path ? `https://image.tmdb.org/t/p/w500${details.poster_path}` : DEFAULT_POSTER);
            const genres = details.genres.map(g => g.name).join(', ');

            const rtState = getRottenTomatoesState(media.rottenTomatoes);
            const popcornState = getPopcornState(media.popcornRating);

            let ratingsHTML = '';
            if (media.imdbRating && media.imdbRating !== "N/A") { ratingsHTML += `<span class="rating-badge"><img src="${IMDB_STAR_ICON}" class="rating-icon">&nbsp;${media.imdbRating}</span>`; }
            if (rtState) { ratingsHTML += `<span class="rating-badge"><img src="${ROTTEN_TOMATOES_ICONS[rtState]}" class="rating-icon">&nbsp;${media.rottenTomatoes}</span>`; }
            if (popcornState) { ratingsHTML += `<span class="rating-badge"><img src="${POPCORN_ICONS[popcornState]}" class="rating-icon">&nbsp;${media.popcornRating}</span>`; }
            if (media.metacriticRating && media.metacriticRating !== "N/A") { ratingsHTML += `<span class="rating-badge"><img src="${METACRITIC_ICON}" class="rating-icon">&nbsp;${media.metacriticRating}</span>`; }
            if (media.letterboxdRating && media.letterboxdRating !== "N/A") { ratingsHTML += `<span class="rating-badge"><img src="${LETTERBOXD_ICON}" class="rating-icon">&nbsp;${media.letterboxdRating}</span>`; }

            const castHTML = details.credits.cast.slice(0, 15).map(actor => `
            <div class="actor-card" data-person-id="${actor.id}">
                <img src="${actor.profile_path ? `https://image.tmdb.org/t/p/w200${actor.profile_path}` : DEFAULT_ACTOR_PHOTO}" class="actor-photo" onerror="this.src='${DEFAULT_ACTOR_PHOTO}'">
                <div class="actor-name">${actor.name}</div>
                <div class="actor-character">${actor.character}</div>
            </div>
        `).join('');

            elements.detailsModalContent.innerHTML = `
            <div class="details-backdrop" style="background-image: url(${backdropUrl})"></div>
            <div class="details-header">
                <img id="detailsModalPoster" src="${posterUrl}" onerror="this.src='${DEFAULT_POSTER}'">
                <div class="details-title-section">
                    <div id="detailsModalHeader-main">
                        <div>
                            <h2 id="detailsModalTitle">${media.title}</h2>
                            <div class="details-ratings-container">${ratingsHTML || '<span style="font-size: 0.9rem; color: var(--text-secondary);">Nessuna valutazione disponibile</span>'}</div>
                        </div>
                        <div style="display: flex; gap: 0.5rem; align-self: flex-start; flex-shrink: 0;">
                             <button id="detailsModalFavoriteBtn" class="btn ${media.isFavorite ? 'is-favorite' : ''}" title="Aggiungi ai preferiti"><i class="fas fa-heart"></i></button>
                             <button id="refreshShowBtn" class="btn btn-secondary" title="Aggiorna Dati Serie"><i class="fas fa-sync-alt"></i></button>
                             <button id="showEpisodesBtn" class="btn btn-primary" style="flex-shrink: 0;"><i class="fas fa-list-check"></i> Episodi</button>
                        </div>
                    </div>
                    <div id="detailsModalMeta">
                        <span><i class="fas fa-calendar-alt"></i> ${media.year}</span>
                        <span><i class="fas fa-satellite-dish"></i> ${details.status}</span>
                        ${genres ? `<span><i class="fas fa-film"></i> ${genres}</span>` : ''}
                    </div>
                </div>
            </div>
            <div class="details-body">
                <h3 class="details-section-title">Trama</h3>
                <p id="detailsModalOverview">${details.overview || 'Trama non disponibile.'}</p>
                <h3 class="details-section-title">Cast Principale</h3>
                <div class="cast-scroller" id="detailsModalCast">
                    ${castHTML}
                </div>
            </div>
        `;

            elements.detailsModalContent.querySelectorAll('.actor-card').forEach(card => {
                card.addEventListener('click', (e) => {
                    e.preventDefault();
                    showActorModal(card.dataset.personId);
                });
            });

            elements.detailsModalContent.querySelector('#refreshShowBtn').addEventListener('click', () => forceRefreshShow(media.id));
            elements.detailsModalContent.querySelector('#showEpisodesBtn').addEventListener('click', () => showEpisodesModal(media));
            elements.detailsModalContent.querySelector('#detailsModalFavoriteBtn').addEventListener('click', () => toggleFavorite(media.id));
        }

        function showEpisodesModal(show) {
            currentShowCache = { show };
            populateEpisodesModal();
            openModal(elements.episodesModal);
        }

        function populateEpisodesModal() {
            const { show } = currentShowCache;

            const sortedSeasonNumbers = Object.keys(show.seasons || {}).map(Number).sort((a, b) => {
                if (a === 0) return 1;
                if (b === 0) return -1;
                return a - b;
            });

            const seasonsHTML = sortedSeasonNumbers.map(seasonNum => {
                const season = show.seasons[seasonNum];
                return createSeasonBlockHTML(show, { ...season, season_number: seasonNum });
            }).join('');

            elements.episodesModalContent.innerHTML = `<h2>Progresso episodi: ${show.title}</h2><div class="seasons-container">${seasonsHTML}</div>`;

            sortedSeasonNumbers.forEach(setupSeasonEventListeners);

            // --- AUTO SCROLL LOGIC ---
            if (show.category === 'In Corso' && show.seasons) {
                setTimeout(() => {
                    let firstUnwatchedId = null;
                    let targetSeasonNum = null;

                    // Find first unwatched
                    for (const seasonNum of sortedSeasonNumbers) {
                        const season = show.seasons[seasonNum];
                        if (!season.episodes) continue;
                        for (const ep of season.episodes) {
                            if (!show.progress[`${seasonNum}-${ep.episode_number}`]) {
                                firstUnwatchedId = `item-${show.id}-${seasonNum}-${ep.episode_number}`;
                                targetSeasonNum = seasonNum;
                                break;
                            }
                        }
                        if (firstUnwatchedId) break;
                    }

                    if (firstUnwatchedId && targetSeasonNum !== null) {
                        // Expand the season block
                        const episodesContainer = document.getElementById(`season-episodes-${targetSeasonNum}`);
                        if (episodesContainer) {
                            episodesContainer.style.maxHeight = episodesContainer.scrollHeight + 'px';
                        }

                        // Scroll to episode
                        const episodeEl = document.getElementById(firstUnwatchedId);
                        if (episodeEl) {
                            episodeEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                    }
                }, 300); // Slight delay for DOM rendering
            }
        }

        function formatAirDate(airDateString) {
            if (!airDateString) return '';
            const airDate = new Date(airDateString + 'T00:00:00Z');
            const today = new Date();
            today.setUTCHours(0, 0, 0, 0);

            // Calcolo differenza giorni
            const diffTime = airDate.getTime() - today.getTime();
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

            const options = { day: 'numeric', month: 'short', year: '2-digit' };
            const dateStr = airDate.toLocaleDateString('it-IT', options);

            // HTML Base della data
            const baseDateHTML = `<span class="episode-date-badge"><i class="fas fa-calendar-alt"></i> ${dateStr}</span>`;

            // Aggiunta Badge Countdown
            if (diffDays === 0) {
                return `${baseDateHTML} <span class="episode-countdown-badge today">Oggi</span>`;
            } else if (diffDays === 1) {
                return `${baseDateHTML} <span class="episode-countdown-badge future">Domani</span>`;
            } else if (diffDays > 1 && diffDays <= 30) {
                return `${baseDateHTML} <span class="episode-countdown-badge future">-${diffDays}gg</span>`;
            } else {
                return baseDateHTML;
            }
        }


        function createSeasonBlockHTML(show, season) {
            const seasonNumber = season.season_number;
            const episodes = season.episodes || [];

            const watchedInSeason = Object.keys(show.progress).filter(key => key.startsWith(`${seasonNumber}-`)).length;
            const episodeCount = episodes.length;
            const isSeasonComplete = watchedInSeason === episodeCount && episodeCount > 0;
            const hasEpisodes = episodeCount > 0;

            // Check if WHOLE season is rewatched (all eps have rewatch > 0)
            let isSeasonRewatched = false;
            if (hasEpisodes && show.rewatches) {
                isSeasonRewatched = episodes.every(ep => (show.rewatches[`${seasonNumber}-${ep.episode_number}`] || 0) > 0);
            }

            const markAllButtonHTML = isSeasonComplete
                ? `<button class="btn btn-warning season-toggle-all-btn" title="Segna tutti come non visti" data-show-id="${show.id}" data-season-number="${seasonNumber}" data-action="unwatch"><i class="fas fa-times"></i></button>`
                : `<button class="btn btn-success season-toggle-all-btn" title="Segna tutti come visti" data-show-id="${show.id}" data-season-number="${seasonNumber}" data-action="watch"><i class="fas fa-check-double"></i></button>`;

            const seasonRewatchBtnHTML = `<button class="btn btn-secondary season-rewatch-btn" title="Imposta rewatch per la stagione" data-show-id="${show.id}" data-season-number="${seasonNumber}"><i class="fas fa-sync-alt"></i></button>`;

            let firstUnwatchedFound = false;

            const allSeasonEpisodes = hasEpisodes ? episodes.map(ep => {
                const isWatched = show.progress[`${seasonNumber}-${ep.episode_number}`];
                const rewatchCount = show.rewatches?.[`${seasonNumber}-${ep.episode_number}`] || 0;
                let titleSpoilerClass = '';

                if (!isWatched) {
                    if (!firstUnwatchedFound) {
                        firstUnwatchedFound = true; // This is the NEXT episode to watch, so show title
                    } else {
                        titleSpoilerClass = 'spoiler'; // Future episodes are spoilers
                    }
                }

                return `
            <div class="episode-item ${isWatched ? 'watched' : ''}" id="item-${show.id}-${seasonNumber}-${ep.episode_number}" onclick="toggleEpisodeWatched('${show.id}', '${seasonNumber}', '${ep.episode_number}')">
                <div class="episode-still-wrapper">
                     <img data-src="${ep.still_path ? `https://image.tmdb.org/t/p/w300${ep.still_path}` : EMPTY_STILL_PLACEHOLDER}" class="episode-still lazy" onerror="this.src='${EMPTY_STILL_PLACEHOLDER}'">
                     <div class="episode-status-overlay"><i class="fas fa-check"></i></div>
                </div>
                <div class="episode-details">
                    <div class="episode-meta-row">
                        <!-- SINISTRA: Numero + Data + Countdown -->
                        <div class="episode-meta-left">
                            <span class="episode-number">${seasonNumber > 0 ? `S${seasonNumber}` : 'SP'} E${ep.episode_number}</span>
                            ${formatAirDate(ep.air_date)}
                        </div>

                        <!-- DESTRA: Solo Rewatch (se presente) -->
                        <div class="episode-meta-right">
                             <div class="episode-rewatch-badge ${rewatchCount === 0 ? 'zero-count' : ''}" onclick="event.stopPropagation(); openRewatchModal({showId: '${show.id}', seasonNumber: '${seasonNumber}', episodeNumber: '${ep.episode_number}'})">
                                <i class="fas fa-sync-alt"></i>
                                ${rewatchCount > 0 ? `<span class="count">${rewatchCount}</span>` : ''}
                             </div>
                        </div>
                    </div>
                    
                    <!-- TITOLO + DURATA -->
                    <div class="episode-title ${titleSpoilerClass}">
                        ${ep.name || `Episodio ${ep.episode_number}`}
                        ${ep.runtime ? `<span class="episode-runtime-badge"><i class="fas fa-clock"></i> ${ep.runtime}m</span>` : ''}
                    </div>
                    <p class="episode-overview">${ep.overview || 'Nessuna trama disponibile.'}</p>
                </div>
            </div>`;
            }).join('') : '<div class="no-episodes-info">Dettagli episodi non ancora disponibili.</div>';

            return `
        <div class="season-block" id="season-block-${seasonNumber}">
            <div class="season-header" data-season-target="${seasonNumber}">
                <div class="season-title-container">
                    <span class="season-title">${season.name}</span>
                    ${isSeasonRewatched ? '<span class="season-rewatch-badge" title="Stagione rivista"><i class="fas fa-sync-alt"></i></span>' : ''}
                    <div class="season-progress-text" style="margin-left:auto; margin-right:10px;">${watchedInSeason} / ${episodeCount}</div>
                </div>
                <div class="season-actions">${hasEpisodes ? seasonRewatchBtnHTML + markAllButtonHTML : ''}</div>
            </div>
            <div class="season-episodes" id="season-episodes-${seasonNumber}">${allSeasonEpisodes}</div>
        </div>`;
        }

        function setupSeasonEventListeners(seasonNumber) {
            const seasonBlock = document.getElementById(`season-block-${seasonNumber}`);
            if (!seasonBlock) return;

            setupLazyLoading();

            seasonBlock.querySelector('.season-header').addEventListener('click', e => {
                if (!e.target.closest('.season-actions')) {
                    const target = document.getElementById(`season-episodes-${seasonNumber}`);
                    const isExpanded = target.style.maxHeight && target.style.maxHeight !== '0px';
                    if (isExpanded) {
                        target.style.maxHeight = null;
                    } else {
                        target.style.maxHeight = target.scrollHeight + 'px';
                    }
                }
            });

            const toggleAllBtn = seasonBlock.querySelector('.season-toggle-all-btn');
            if (toggleAllBtn) {
                toggleAllBtn.addEventListener('click', e => {
                    const { showId, seasonNumber, action } = e.currentTarget.dataset;
                    toggleSeasonWatched(showId, seasonNumber, action === 'watch');
                });
            }

            const seasonRewatchBtn = seasonBlock.querySelector('.season-rewatch-btn');
            if (seasonRewatchBtn) {
                seasonRewatchBtn.addEventListener('click', (e) => {
                    const { showId, seasonNumber } = e.currentTarget.dataset;
                    openRewatchModal({ showId, seasonNumber });
                });
            }
        }

        async function showActorModal(personId) {
            openModal(elements.actorModal);
            elements.actorModalContent.innerHTML = '<div style="text-align: center; padding: 4rem;"><i class="fas fa-spinner fa-3x loading-spinner"></i></div>';
            const actorDetails = await fetchTMDbActorDetailsWithFallback(personId);
            if (actorDetails) {
                populateActorModal(actorDetails);
            } else {
                elements.actorModalContent.innerHTML = '<p style="text-align: center; padding: 2rem;">Dettagli attore non trovati.</p>';
            }
        }

        async function fetchTMDbActorDetailsWithFallback(personId) {
            let details = await fetchTMDbActorDetails(personId, 'it-IT');
            if (details && !details.biography) {
                const en_details = await fetchTMDbActorDetails(personId, 'en-US');
                if (en_details) details.biography = en_details.biography;
            }
            return details;
        }

        async function fetchTMDbActorDetails(personId, lang = 'it-IT') {
            try {
                const [detailsRes, creditsRes] = await Promise.all([
                    fetch(`https://api.themoviedb.org/3/person/${personId}?api_key=${TMDB_KEY}&language=${lang}`),
                    fetch(`https://api.themoviedb.org/3/person/${personId}/tv_credits?api_key=${TMDB_KEY}&language=${lang}`)
                ]);
                if (!detailsRes.ok || !creditsRes.ok) return null;

                const details = await detailsRes.json();
                const credits = await creditsRes.json();
                credits.cast.sort((a, b) => (b.vote_average || 0) - (a.vote_average || 0));

                return { ...details, tv_credits: credits };
            } catch (err) {
                console.error("Error fetching actor details:", err);
                return null;
            }
        }

        function populateActorModal(details) {
            const photoUrl = details.profile_path ? `https://image.tmdb.org/t/p/w500${details.profile_path}` : DEFAULT_ACTOR_PHOTO;
            const filmographyHTML = (details.tv_credits?.cast || []).slice(0, 15).map(show => {
                if (!show.poster_path) return '';
                return `
            <div class="film-card-small" data-imdb-id="${show.id}" title="${show.name}">
                <img src="https://image.tmdb.org/t/p/w200${show.poster_path}" onerror="this.src='${DEFAULT_POSTER}'">
                <div class="film-card-small-title">${show.name}</div>
            </div>`;
            }).join('');

            elements.actorModalContent.innerHTML = `
            <div class="actor-details-header">
                <img src="${photoUrl}" class="actor-details-photo" onerror="this.src='${DEFAULT_ACTOR_PHOTO}'">
                <div class="actor-details-info">
                    <h2>${details.name}</h2>
                    <ul>
                        <li><strong>Nascita:</strong> ${details.birthday ? new Date(details.birthday).toLocaleDateString('it-IT') : 'N/A'}</li>
                        <li><strong>Luogo:</strong> ${details.place_of_birth || 'N/A'}</li>
                    </ul>
                    ${details.imdb_id ? `<a href="https://www.imdb.com/name/${details.imdb_id}/" target="_blank" class="btn btn-imdb"><i class="fab fa-imdb"></i> Vedi su IMDb</a>` : ''}
                </div>
            </div>
            <div>
                ${filmographyHTML ? `<h3 class="details-section-title">Filmografia Selezionata (TV)</h3><div class="filmography-scroller">${filmographyHTML}</div>` : ''}
                <h3 class="details-section-title">Biografia</h3>
                <p>${details.biography || 'Biografia non disponibile.'}</p>
            </div>
        `;
        }

        async function toggleSeasonWatched(showId, seasonNumber, watch) {
            const show = mediaList.find(m => m.id === showId);
            if (!show) return;

            // 1. Aggiorna i dati in memoria
            const duplicates = mediaList.filter(d => (d.imdbID && d.imdbID === show.imdbID) || (d.tmdbID && d.tmdbID === show.tmdbID));

            duplicates.forEach(dup => {
                if (dup.seasons[seasonNumber] && dup.seasons[seasonNumber].episodes) {
                    dup.seasons[seasonNumber].episodes.forEach(ep => {
                        const key = `${seasonNumber}-${ep.episode_number}`;
                        if (watch) dup.progress[key] = true;
                        else delete dup.progress[key];
                    });
                    updateShowCategoryAndTimestamps(dup, true);
                }
            });

            if (watch) await logActivity('complete_season', show.title, `la stagione ${seasonNumber}`);

            currentShowCache.show = show;

            // 2. Aggiorna il DOM (Interfaccia)
            const seasonBlock = document.getElementById(`season-block-${seasonNumber}`);

            // Controllo se il modale è aperto e il blocco esiste
            if (seasonBlock && elements.episodesModal.style.display === 'flex') {
                // Memorizza se la stagione era aperta
                const episodesDiv = seasonBlock.querySelector('.season-episodes');
                const isExpanded = episodesDiv && episodesDiv.style.maxHeight && episodesDiv.style.maxHeight !== '0px';

                // Crea il nuovo HTML
                const newSeasonHTML = createSeasonBlockHTML(show, { ...show.seasons[seasonNumber], season_number: seasonNumber });

                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = newSeasonHTML;

                // --- FIX IMPORTANTE ---
                // Usa firstElementChild invece di firstChild per ignorare gli spazi vuoti/testo
                const newBlock = tempDiv.firstElementChild;

                if (newBlock) {
                    // Sostituisci il blocco vecchio con quello nuovo
                    seasonBlock.parentNode.replaceChild(newBlock, seasonBlock);
                    setupSeasonEventListeners(seasonNumber);

                    // Ripristina lo stato di apertura (se era aperta, riaprila)
                    if (isExpanded) {
                        const newEpisodesContainer = newBlock.querySelector('.season-episodes');
                        if (newEpisodesContainer) {
                            newEpisodesContainer.style.maxHeight = newEpisodesContainer.scrollHeight + 'px';
                        }
                    }
                }
            }

            // 3. Salva e aggiorna statistiche
            await saveData();
            updateStats();
        }

        function toggleEpisodeWatched(showId, season, episode) {
            // Find the show
            const show = mediaList.find(m => m.id === showId);
            if (!show) return;

            // Determine current state from data (not HTML)
            const key = `${season}-${episode}`;
            const wasWatched = show.progress[key] ? true : false;
            const isWatched = !wasWatched; // Toggle state

            // UI Optimistic Update (Instant Feedback)
            const item = document.getElementById(`item-${showId}-${season}-${episode}`);
            if (item) {
                if (isWatched) {
                    item.classList.add('watched');
                } else {
                    item.classList.remove('watched');
                }
            }

            // Update Logic for all duplicates
            const duplicates = mediaList.filter(d => (d.imdbID && d.imdbID === show.imdbID) || (d.tmdbID && d.tmdbID === show.tmdbID));

            duplicates.forEach(dup => {
                if (isWatched) dup.progress[key] = true;
                else delete dup.progress[key];
                updateShowCategoryAndTimestamps(dup);
            });

            // Debounce save to avoid spamming if user clicks fast
            if (debounceTimeout) clearTimeout(debounceTimeout);
            debounceTimeout = setTimeout(() => {
                saveData();
                updateStats();
                // Don't refresh media cards here - it causes the modal season to disappear
                // duplicates.forEach(dup => refreshSingleMedia(dup.id));
            }, 500);

            currentShowCache.show = show;

            // Update Season Header Progress Text
            const seasonBlock = document.getElementById(`season-block-${season}`);
            if (seasonBlock) {
                const watchedInSeason = Object.keys(show.progress).filter(k => k.startsWith(`${season}-`)).length;
                const episodeCount = (show.seasons[season]?.episodes || []).length;
                seasonBlock.querySelector('.season-progress-text').textContent = `${watchedInSeason} / ${episodeCount}`;

                // Toggle the 'Mark All' button state
                const isSeasonComplete = watchedInSeason === episodeCount && episodeCount > 0;
                const actionButton = seasonBlock.querySelector('.season-toggle-all-btn');
                if (actionButton) {
                    actionButton.className = `btn season-toggle-all-btn ${isSeasonComplete ? 'btn-warning' : 'btn-success'}`;
                    actionButton.title = isSeasonComplete ? 'Segna tutti come non visti' : 'Segna tutti come visti';
                    actionButton.dataset.action = isSeasonComplete ? 'unwatch' : 'watch';
                    actionButton.innerHTML = `<i class="fas ${isSeasonComplete ? 'fa-times' : 'fa-check-double'}"></i>`;
                }
            }
        }


        function updateShowCategoryAndTimestamps(show, forceLog = false) {
            show.lastActivityAt = new Date().toISOString();
            show.lastActivityAt = new Date().toISOString();

            const isCustomCategory = !DEFAULT_CATEGORIES.includes(show.category);
            if (isCustomCategory) return;

            const { watchedEpisodes, totalEpisodes } = calculateProgress(show);
            const oldCategory = show.category;

            if (watchedEpisodes === 0) show.category = "Da Vedere";
            else if (watchedEpisodes >= totalEpisodes && totalEpisodes > 0) {
                // Check if rewatching
                const hasRewatches = show.rewatches && Object.values(show.rewatches).some(c => c > 0);

                // If currently In Corso and has rewatches, don't move to Completate
                if (oldCategory === 'In Corso' && hasRewatches) {
                    // Keep in In Corso
                    show.category = "In Corso";
                } else {
                    show.category = "Completate";
                    if (oldCategory !== 'Completate' || forceLog) {
                        showNotification(`Hai completato ${show.title}!`, "success");
                        logActivity('complete_show', show.title, '');
                    }
                }
            }
            else show.category = "In Corso";
        }

        async function moveShowToCategory(showId, newCategory) {
            const show = mediaList.find(m => m.id === showId);
            if (show && show.category !== newCategory) {
                const oldCategory = show.category;
                show.category = newCategory;
                if (newCategory === 'Completate') {
                    Object.keys(show.seasons).forEach(seasonNum => {
                        (show.seasons[seasonNum].episodes || []).forEach(ep => {
                            show.progress[`${seasonNum}-${ep.episode_number}`] = true;
                        });
                    });
                }
                show.lastActivityAt = new Date().toISOString();
                await logActivity('move_show', show.title, `da '${oldCategory}' a '${newCategory}'`);
                await saveData();
                renderFullUI();
                showNotification(`"${show.title}" spostato in ${newCategory}.`, "success");
            }
        }

        async function markAsCompleted(showId) {
            const show = mediaList.find(m => m.id === showId);
            if (show && show.category !== 'Completate') {
                const oldCategory = show.category;
                show.category = 'Completate';
                show.lastActivityAt = new Date().toISOString();
                await logActivity('mark_completed', show.title, `dalla categoria '${oldCategory}'`);
                await saveData();
                renderFullUI();
                showNotification(`"${show.title}" segnato come completato.`, "success");
            }
        }

        function showContextMenu(show, pos) {
            if (isViewMode) return;
            document.querySelectorAll(".context-menu").forEach(m => m.remove());
            const menu = document.createElement("div");
            menu.className = "context-menu";
            const hide = () => menu.remove();
            setTimeout(() => document.addEventListener("click", hide, { once: true }), 0);



            const header = document.createElement("div");
            header.className = "context-menu-item";
            header.innerHTML = '<i class="fas fa-folder-open fa-fw"></i> <strong>Sposta in...</strong>';
            header.style.cssText = "color: var(--text-secondary); cursor: default; background: rgba(128,128,128,0.1);";
            menu.appendChild(header);

            categories.map(c => c.name).filter(c => c !== show.category).forEach(cat => {
                const item = document.createElement("div");
                item.className = "context-menu-item";
                const catIndex = categories.findIndex(c => c.name === cat);
                const dotClass = `category-dot-${catIndex % 6}`;
                item.innerHTML = `<span class="category-dot ${dotClass}"></span> ${cat}`;
                item.addEventListener("click", () => { moveShowToCategory(show.id, cat); hide(); });
                menu.appendChild(item);
            });
            menu.appendChild(document.createElement("div")).className = "context-menu-divider";

            if (show.category !== 'Completate') {
                const markCompletedItem = document.createElement("div");
                markCompletedItem.className = "context-menu-item";
                markCompletedItem.innerHTML = '<i class="fas fa-check-double fa-fw"></i> Segna come completata';
                markCompletedItem.addEventListener("click", () => { markAsCompleted(show.id); hide(); });
                menu.appendChild(markCompletedItem);
            }

            // Dropped Toggle Button (Moved below Completed)
            const droppedItem = document.createElement('div');
            droppedItem.className = "context-menu-item";
            droppedItem.innerHTML = show.isDropped ? '<i class="fas fa-play fa-fw"></i> Riprendi Serie' : '<i class="fas fa-ban fa-fw"></i> Segna come Droppata';
            droppedItem.addEventListener("click", () => { toggleDroppedStatus(show); hide(); });
            menu.appendChild(droppedItem);
            menu.appendChild(document.createElement("div")).className = "context-menu-divider";

            const changePosterItem = document.createElement("div");
            changePosterItem.className = "context-menu-item";
            changePosterItem.innerHTML = '<i class="fas fa-image fa-fw"></i> Cambia Copertina';
            changePosterItem.addEventListener("click", () => { showPosterModal(show.id); hide(); });
            menu.appendChild(changePosterItem);

            const toggleSpecialsItem = document.createElement("div");
            toggleSpecialsItem.className = "context-menu-item";
            if (show.seasons && show.seasons[0]) {
                toggleSpecialsItem.innerHTML = '<i class="fas fa-trash-alt fa-fw"></i> Rimuovi Speciali';
                toggleSpecialsItem.addEventListener("click", () => { removeSpecials(show.id); hide(); });
            } else {
                toggleSpecialsItem.innerHTML = '<i class="fas fa-plus-circle fa-fw"></i> Aggiungi Speciali';
                toggleSpecialsItem.addEventListener("click", () => { addSpecials(show.id); hide(); });
            }
            menu.appendChild(toggleSpecialsItem);

            const deleteItem = document.createElement("div");
            deleteItem.className = "context-menu-item";
            deleteItem.innerHTML = '<i class="fas fa-trash fa-fw"></i> Elimina';
            deleteItem.style.color = "var(--danger)";
            deleteItem.addEventListener("click", () => { deleteShow(show.id); hide(); });
            menu.appendChild(deleteItem);

            document.body.appendChild(menu);
            const rect = menu.getBoundingClientRect();
            let x = pos.x, y = pos.y;
            if (x + rect.width > window.innerWidth) x = window.innerWidth - rect.width - 5;
            if (y + rect.height > window.innerHeight) y = window.innerHeight - rect.height - 5;
            menu.style.left = `${x}px`;
            menu.style.top = `${y}px`;
            requestAnimationFrame(() => menu.classList.add('visible'));
        }

        async function addSpecials(showId) {
            const show = mediaList.find(m => m.id === showId);
            if (!show || !show.tmdbID) return;

            showNotification("Recupero episodi speciali...", "warning");
            const specialsData = await fetchTMDbSeasonDetailsWithFallback(show.tmdbID, 0);
            if (specialsData && specialsData.episodes && specialsData.episodes.length > 0) {
                show.seasons[0] = {
                    name: specialsData.name || "Speciali",
                    episodes: specialsData.episodes.map(ep => ({
                        name: ep.name,
                        overview: ep.overview,
                        episode_number: ep.episode_number,
                        runtime: ep.runtime || 0,
                        still_path: ep.still_path,
                        air_date: ep.air_date
                    }))
                };
                await saveData();
                refreshSingleMedia(showId);
                showNotification("Episodi speciali aggiunti!", "success");
            } else {
                showNotification("Nessun episodio speciale trovato per questa serie.", "error");
            }
        }

        async function removeSpecials(showId) {
            const show = mediaList.find(m => m.id === showId);
            if (!show || !show.seasons || !show.seasons[0]) return;

            // Rimuovi i progressi legati agli speciali
            Object.keys(show.progress).forEach(key => {
                if (key.startsWith('0-')) {
                    delete show.progress[key];
                }
            });

            delete show.seasons[0];
            await saveData();
            refreshSingleMedia(showId);
            showNotification("Episodi speciali rimossi.", "success");
        }

        function toggleDroppedStatus(show) {
            if (!show.isDropped) {
                // Show Drop Modal to select category
                elements.dropCategorySelect.innerHTML = categories.map(c => {
                    const name = typeof c === 'string' ? c : c.name;
                    return `<option value="${name}" ${name === show.category ? 'selected' : ''}>${name}</option>`;
                }).join('');

                openModal(elements.dropModal);

                // Handle Confirm
                const confirmHandler = async () => {
                    closeModal(elements.dropModal); // Close immediately
                    closeModal(elements.detailsModal); // Close details if open

                    const selectedCategory = elements.dropCategorySelect.value;
                    show.isDropped = true;
                    show.category = selectedCategory;

                    await saveData();
                    renderFullUI();

                    await logActivity('mark_dropped', show.title, `spostata in '${selectedCategory}'`);
                    showNotification(`"${show.title}" segnata come droppata in ${selectedCategory}.`, "success");

                    cleanup();
                };

                // Handle Cancel
                const cancelHandler = () => {
                    closeModal(elements.dropModal);
                    cleanup();
                };

                const cleanup = () => {
                    elements.confirmDropBtn.removeEventListener('click', confirmHandler);
                    elements.cancelDropBtn.removeEventListener('click', cancelHandler);
                };

                elements.confirmDropBtn.addEventListener('click', confirmHandler);
                elements.cancelDropBtn.addEventListener('click', cancelHandler);

            } else {
                // Resume Show
                show.isDropped = false;
                saveData();
                renderFullUI();
                closeModal(elements.detailsModal);

                logActivity('resume_show', show.title, 'ripresa');
                showNotification(`"${show.title}" ripresa!`, "success");
            }
        }

        function deleteShow(showId) {
            if (isViewMode) return;
            const show = mediaList.find(m => m.id === showId);
            if (!show) return;
            showConfirmModal("Elimina Serie TV", `Sei sicuro di voler eliminare "${show.title}"?`, async () => {
                await logActivity('delete_show', show.title, `dalla categoria '${show.category}'`);
                mediaList = mediaList.filter(m => m.id !== showId);
                await saveData();
                renderFullUI();
            });
        }

        async function showPosterModal(id) {
            const show = mediaList.find(m => m.id === id);
            if (!show || (!show.imdbID && !show.tmdbID)) return showNotification("Nessun ID valido (TMDb/IMDb) trovato per questa serie.", "warning");
            elements.posterModal.dataset.mediaId = id;
            elements.posterGrid.innerHTML = `<div style="text-align:center;"><i class="fas fa-spinner loading-spinner"></i></div>`;
            openModal(elements.posterModal);

            const posters = await fetchPosters(show);
            if (posters.length === 0) {
                elements.posterGrid.innerHTML = "<p>Nessuna copertina alternativa trovata.</p>";
                return;
            }
            elements.posterGrid.innerHTML = posters.map(p => `
            <div class="poster-option" data-url="${p.url}">
                <img src="${p.url}" onerror="this.src='${DEFAULT_POSTER}'">
                <div class="poster-language-badge">${p.iso_639_1 || 'N/A'}</div>
            </div>`).join('');
            elements.posterGrid.querySelectorAll('.poster-option').forEach(el =>
                el.addEventListener('click', () => {
                    document.querySelectorAll(".poster-option.selected").forEach(s => s.classList.remove('selected'));
                    el.classList.add('selected');
                })
            );
        }

        async function fetchPosters(show) {
            try {
                const tmdbId = show.tmdbID || (await fetchTMDbShowDetailsByIMDb(show.imdbID))?.id;
                if (!tmdbId) return [];

                const imagesRes = await fetch(`https://api.themoviedb.org/3/tv/${tmdbId}/images?api_key=${TMDB_KEY}`);
                const imagesData = await imagesRes.json();
                const langScore = (lang) => (lang === 'it') ? 3 : (lang === 'en') ? 2 : (lang === null) ? 1 : 0;
                return imagesData.posters
                    .filter(p => ['it', 'en', null].includes(p.iso_639_1))
                    .sort((a, b) => langScore(b.iso_639_1) - langScore(a.iso_639_1))
                    .slice(0, 30)
                    .map(p => ({ url: `https://image.tmdb.org/t/p/w500${p.file_path}`, iso_639_1: p.iso_639_1 ? p.iso_639_1.toUpperCase() : null }));
            } catch (err) {
                console.error("Error fetching posters:", err);
                return [];
            }
        }

        function changePoster(id, url) {
            const show = mediaList.find(m => m.id === id);
            if (show) {
                const duplicates = mediaList.filter(s => (s.imdbID && s.imdbID === show.imdbID) || (s.tmdbID && s.tmdbID === show.tmdbID));
                duplicates.forEach(dup => {
                    dup.poster = url;
                });
                saveData();
                renderMedia();
                closeModal(elements.posterModal);
                showNotification("Copertina aggiornata per tutte le copie!", "success");
            }
        }

        function renderCategoriesList() {
            const list = elements.categoriesList;
            list.innerHTML = "";
            categories.forEach((catObj, index) => {
                const card = document.createElement("div");
                card.className = "management-card";
                const isDefault = DEFAULT_CATEGORIES.includes(catObj.name);
                const dotClass = `category-dot-${index % 6}`;
                const count = mediaList.filter(m => m.category === catObj.name).length;
                card.innerHTML = `
                <div>
                    <span class="category-dot ${dotClass}"></span>
                    <div>
                        <div class="category-name">${catObj.name}</div>
                    </div>
                </div>
                <div class="management-card-actions">
                    <button class="btn move-up-btn" ${index === 0 ? "disabled" : ""} title="Sposta su"><i class="fas fa-arrow-up"></i></button>
                    <button class="btn move-down-btn" ${index === categories.length - 1 ? "disabled" : ""} title="Sposta giù"><i class="fas fa-arrow-down"></i></button>
                    ${!isDefault ? `
                        <button class="btn toggle-progress-btn" title="Mostra/Nascondi progresso"><i class="fas ${catObj.hideProgress ? 'fa-eye-slash' : 'fa-eye'}"></i></button>
                        <button class="btn rename-category-btn" title="Rinomina"><i class="fas fa-pencil-alt"></i></button>
                        <button class="btn btn-danger delete-category-btn" title="Elimina"><i class="fas fa-trash"></i></button>
                    ` : ''}
                </div>`;
                card.querySelector('.move-up-btn').addEventListener('click', () => moveCategory(catObj.name, -1));
                card.querySelector('.move-down-btn').addEventListener('click', () => moveCategory(catObj.name, 1));
                if (!isDefault) {
                    card.querySelector('.delete-category-btn').addEventListener('click', () => deleteCategory(catObj.name));
                    card.querySelector('.rename-category-btn').addEventListener('click', (e) => {
                        e.stopPropagation();
                        const nameEl = e.currentTarget.closest(".management-card").querySelector(".category-name");
                        renameCategory(catObj.name, nameEl);
                    });
                    card.querySelector('.toggle-progress-btn').addEventListener('click', () => toggleCategoryProgress(catObj.name));
                }
                list.appendChild(card);
            });
        }

        function toggleCategoryProgress(catName) {
            const category = categories.find(c => c.name === catName);
            if (category) {
                category.hideProgress = !category.hideProgress;
                saveData();
                renderCategoriesList();
                renderMedia();
            }
        }

        function renameCategory(oldName, nameEl) {
            const input = document.createElement("input");
            input.type = "text";
            input.value = oldName;
            input.className = "category-name-input";
            nameEl.parentElement.replaceChild(input, nameEl);
            input.focus();
            const save = () => {
                const newName = input.value.trim();
                const catIndex = categories.findIndex(c => c.name === oldName);
                if (newName && newName !== oldName && !categories.some(c => c.name === newName)) {
                    mediaList.forEach(m => { if (m.category === oldName) m.category = newName; });
                    categories[catIndex].name = newName;
                    saveData();
                    renderFullUI();
                    renderCategoriesList();
                    showNotification(`Categoria rinominata in "${newName}"`, "success");
                } else {
                    renderCategoriesList(); // Revert if invalid
                }
            };
            input.addEventListener("blur", save);
            input.addEventListener("keydown", e => { if (e.key === "Enter") input.blur(); });
        }

        function addCategory() {
            const name = elements.newCategoryName.value.trim();
            if (!name) return showNotification("Inserisci un nome per la categoria", "warning");
            if (categories.some(c => c.name.toLowerCase() === name.toLowerCase())) {
                return showNotification("Questa categoria esiste già.", "warning");
            }
            categories.push({ name: name, hideProgress: false });
            saveData();
            renderFullUI();
            renderCategoriesList();
            elements.newCategoryName.value = "";
            showNotification(`Categoria "${name}" aggiunta!`, "success");
        }

        function deleteCategory(catName) {
            if (DEFAULT_CATEGORIES.includes(catName)) return;
            showConfirmModal("Elimina Categoria", `Sei sicuro di voler eliminare la categoria "${catName}"? Le serie in questa categoria verranno spostate in "Da Vedere".`, () => {
                mediaList.forEach(m => { if (m.category === catName) m.category = "Da Vedere"; });
                categories = categories.filter(c => c.name !== catName);
                saveData();
                renderFullUI();
                renderCategoriesList();
                closeModal(elements.mediaManagementModal);
                showNotification(`Categoria "${catName}" eliminata.`, "success");
            });
        }

        function moveCategory(catName, direction) {
            const index = categories.findIndex(c => c.name === catName);
            const newIndex = index + direction;
            if (newIndex >= 0 && newIndex < categories.length) {
                [categories[index], categories[newIndex]] = [categories[newIndex], categories[index]];
                saveData();
                renderFullUI();
                renderCategoriesList();
            }
        }

        function resetApp() { if (isViewMode) return; showConfirmModal("Resetta Tracker", "Sei sicuro di voler resettare l'applicazione? Tutti i dati andranno persi.", () => { mediaList = []; categories = DEFAULT_CATEGORIES.map(name => ({ name, hideProgress: false })); saveData(); renderFullUI(); showNotification("Tracker resettato con successo.", "success"); }); }
        function fixPosterUrl(url) { return (url && url.startsWith("https://")) ? url : DEFAULT_POSTER; }

        function populateCategoryFilter(selectElement) {
            const currentVal = selectElement.value;
            selectElement.innerHTML = `<option value="all">Tutte le categorie</option><option value="favorites">Solo Preferiti</option>${categories.map(cat => `<option value="${cat.name}">${cat.name}</option>`).join("")}`;
            if (Array.from(selectElement.options).some(opt => opt.value === currentVal)) {
                selectElement.value = currentVal;
            } else {
                selectElement.value = 'all';
            }
        }

        function updateCategoryFilter() {
            populateCategoryFilter(elements.categoryFilter);
            populateCategoryFilter(elements.mobileCategoryFilter);
        }

        function populateAddMediaCategorySelect() {
            const lastUsed = localStorage.getItem("lastUsedTvShowCategory");
            elements.addMediaCategorySelect.innerHTML = categories.map(cat => `<option value="${cat.name}">${cat.name}</option>`).join("");
            if (lastUsed && categories.some(c => c.name === lastUsed)) {
                elements.addMediaCategorySelect.value = lastUsed;
            } else if (categories.some(c => c.name === "Da Vedere")) {
                elements.addMediaCategorySelect.value = "Da Vedere";
            }
        }

        function renderCategorySections() {
            elements.mediaSectionsContainer.innerHTML = categories.map(cat => `
            <div class="media-section" id="${sanitizeForId(cat.name)}Section" data-category="${cat.name}">
                <div class="section-header">
                    <h2 class="section-title user-select-none">${cat.name}</h2>
                    <span id="${sanitizeForId(cat.name)}Count" class="category-count"></span>
                </div>
                <div class="media-grid" id="${sanitizeForId(cat.name)}Grid"></div>
            </div>`).join("");
        }

        function populateCategoryNavModal() {
            const container = elements.categoryNavList;
            container.innerHTML = '';

            // Add all categories (including default ones like watchlist and watched)
            categories.forEach((cat) => {
                const btn = document.createElement('button');
                btn.className = 'btn';

                // Determine icon and display name based on category
                let icon = 'fa-folder';
                let displayName = cat.name;

                if (cat.name === 'Da Vedere') {
                    icon = 'fa-bookmark';
                } else if (cat.name === 'In Corso') {
                    icon = 'fa-play-circle';
                } else if (cat.name === 'Completate') {
                    icon = 'fa-check-circle';
                }

                btn.innerHTML = `<i class="fas ${icon}"></i> ${displayName}`;
                btn.addEventListener('click', () => {
                    closeModal(elements.categoryNavModal);
                    setTimeout(() => {
                        const section = document.getElementById(`${sanitizeForId(cat.name)}Section`);
                        if (section) {
                            const headerOffset = 80; // Adjust for sticky header or top bar if needed
                            const elementPosition = section.getBoundingClientRect().top;
                            const offsetPosition = elementPosition + window.pageYOffset - headerOffset;

                            window.scrollTo({
                                top: offsetPosition,
                                behavior: "smooth"
                            });
                        }
                    }, 300);
                });
                container.appendChild(btn);
            });
        }

        function closeModal(modal) {
            if (modal && (modal.classList.contains('visible') || modal.style.display === 'flex')) {
                // Se il modale è attivo, torniamo indietro nella cronologia.
                // Questo attiverà il popstate che gestisce la chiusura pulita.
                history.back();
            }
        }
        function showNotification(text, type = "success") { elements.notificationText.textContent = text; elements.notification.className = `notification ${type}`; elements.notification.style.display = "block"; setTimeout(() => elements.notification.style.display = "none", 3000); }
        function showConfirmModal(title, body, onConfirm) { elements.confirmModalTitle.textContent = title; elements.confirmModalBody.textContent = body; openModal(elements.confirmModal); const confirmHandler = () => { closeModal(elements.confirmModal); onConfirm(); cleanup(); }; const cancelHandler = () => { closeModal(elements.confirmModal); cleanup(); }; const cleanup = () => { elements.confirmModalConfirm.removeEventListener("click", confirmHandler); elements.confirmModalCancel.removeEventListener("click", cancelHandler); }; elements.confirmModalConfirm.addEventListener("click", confirmHandler); elements.confirmModalCancel.addEventListener("click", cancelHandler); }
        function setupLazyLoading() { if (lazyLoadObserver) lazyLoadObserver.disconnect(); lazyLoadObserver = new IntersectionObserver((entries, observer) => { entries.forEach(entry => { if (entry.isIntersecting) { const img = entry.target; img.src = img.dataset.src; img.classList.remove("lazy"); observer.unobserve(img); } }); }, { rootMargin: "200px" }); document.querySelectorAll(".lazy").forEach(img => lazyLoadObserver.observe(img)); }
        function loadSortOrder() { elements.sortFilter.value = localStorage.getItem("tvShowSortOrder") || "added"; }
        function loadTheme() { const theme = localStorage.getItem("theme") || "dark"; document.body.classList.toggle("dark", theme === "dark"); elements.themeToggle.innerHTML = `<i class="fas fa-${theme === "dark" ? "sun" : "moon"}"></i>`; elements.mobileMenuThemeBtn.innerHTML = `<i class="fas fa-${theme === "dark" ? "sun" : "moon"}"></i>Cambia Tema`; }

        async function searchTMDb() {
            const title = elements.mediaTitle.value.trim();
            if (!title) return;
            elements.tmdbResults.innerHTML = `<div style="text-align:center;"><i class="fas fa-spinner loading-spinner"></i></div>`;
            try {
                const res = await fetch(`https://api.themoviedb.org/3/search/tv?api_key=${TMDB_KEY}&query=${encodeURIComponent(title)}&language=it-IT&include_adult=false`);
                const data = await res.json();
                if (data.results && data.results.length > 0) {
                    elements.tmdbResults.innerHTML = data.results.map(r => `
                    <div class="tmdb-result-item" data-tmdb-id="${r.id}" data-title="${r.name}">
                        <img src="${r.poster_path ? `https://image.tmdb.org/t/p/w200${r.poster_path}` : DEFAULT_POSTER}" class="tmdb-poster-small" onerror="this.src='${DEFAULT_POSTER}'">
                        <div>
                            <strong>${r.name}</strong> (${r.first_air_date ? r.first_air_date.split('-')[0] : 'N/D'})
                            <div style="font-size:0.8rem; color: var(--text-secondary)">${r.original_name}</div>
                        </div>
                    </div>`).join('');
                    document.querySelectorAll(".tmdb-result-item").forEach(item => item.addEventListener("click", () => {
                        currentTMDbSelection = { tmdbId: item.dataset.tmdbId };
                        elements.mediaTitle.value = item.dataset.title;
                        showNotification(`"${item.dataset.title}" selezionato.`, "success");
                    }));
                } else {
                    elements.tmdbResults.innerHTML = `<p>Nessun risultato</p>`;
                }
            } catch (err) {
                elements.tmdbResults.innerHTML = "<p>Errore di rete</p>";
            }
        }

        function triggerNewEpisodeCheck() {
            const now = new Date().getTime();
            const lastCheck = localStorage.getItem('lastNewEpisodeCheck');
            const SIX_HOURS = 6 * 60 * 60 * 1000;

            if (!lastCheck || (now - lastCheck) > SIX_HOURS) {
                console.log("Esecuzione del controllo per nuovi episodi...");
                checkForNewEpisodes();
                localStorage.setItem('lastNewEpisodeCheck', now);
            }
        }

        function checkForNewEpisodes() {
            const lastCheckString = localStorage.getItem('lastNewEpisodeCheck');
            const lastCheckDate = lastCheckString ? new Date(parseInt(lastCheckString)) : new Date(Date.now() - 24 * 60 * 60 * 1000);
            const currentDate = new Date();

            const showsToCheck = mediaList.filter(s => s.category === 'In Corso');

            showsToCheck.forEach(show => {
                Object.values(show.seasons).forEach(season => {
                    (season.episodes || []).forEach(ep => {
                        if (ep.air_date) {
                            const airDate = new Date(ep.air_date);
                            if (airDate >= lastCheckDate && airDate <= currentDate) {
                                if (!show.progress[`${season.season_number}-${ep.episode_number}`]) {
                                    setTimeout(() => showNotification(`È uscito un nuovo episodio di ${show.title}!`, 'success'), 500);
                                }
                            }
                        }
                    });
                });
            });
        }

        async function updateAllShowsInBackground(force = false) {
            if (isUpdateInProgress) {
                if (force) {
                    showNotification("Aggiornamento già in corso.", "warning");
                }
                console.log("Tentativo di avvio aggiornamento bloccato: un altro è già in corso.");
                return;
            }

            isUpdateInProgress = true;

            try {
                const now = new Date().getTime();
                const lastUpdate = localStorage.getItem('lastBackgroundUpdate');
                const TWENTY_FOUR_HOURS = 24 * 60 * 60 * 1000;

                if (!force && lastUpdate && (now - lastUpdate) < TWENTY_FOUR_HOURS) {
                    console.log("Aggiornamento in background saltato: non ancora trascorse 24 ore.");
                    isUpdateInProgress = false;
                    return;
                }

                const today = new Date();
                today.setUTCHours(0, 0, 0, 0);
                const sevenDaysAgo = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000);
                const sevenDaysFromNow = new Date(today.getTime() + 7 * 24 * 60 * 60 * 1000);

                const showsToUpdate = mediaList.filter(show => {
                    if (!show.tmdbID) return false;

                    const ora = new Date().getTime();
                    const ultimaAttivita = new Date(show.lastActivityAt || 0).getTime();
                    const QUINDICI_GIORNI = 15 * 24 * 60 * 60 * 1000;

                    // 1. Controllo episodi vicini (±7 giorni)
                    const haEpisodiVicini = Object.values(show.seasons).some(season =>
                        (season.episodes || []).some(ep => {
                            if (!ep.air_date) return false;
                            const airDate = new Date(ep.air_date + 'T00:00:00Z');
                            return airDate >= sevenDaysAgo && airDate <= sevenDaysFromNow;
                        })
                    );

                    // 2. Controllo "Serie in Corso" ferma da troppo tempo
                    // Se la serie non è conclusa, la controlliamo comunque ogni 15 giorni 
                    // per vedere se TMDb ha aggiunto una nuova stagione o nuove date.
                    const vaControllataPerSicurezza =
                        (show.status === 'Returning Series' || show.status === 'In Production') &&
                        (ora - ultimaAttivita > QUINDICI_GIORNI);

                    return haEpisodiVicini || vaControllataPerSicurezza;
                });

                if (showsToUpdate.length === 0) {
                    if (force) showNotification("Nessuna serie con attività recente da aggiornare.", "warning");
                    localStorage.setItem('lastBackgroundUpdate', now);
                    displayLastUpdateTime();
                    isUpdateInProgress = false;
                    return;
                }

                console.log(`Avvio aggiornamento per ${showsToUpdate.length} serie...`);
                openModal(elements.updateProgressModal);
                elements.updateProgressTitle.textContent = force ? "Aggiornamento Manuale" : "Aggiornamento Giornaliero";
                let allChanges = [];

                for (let i = 0; i < showsToUpdate.length; i++) {
                    const show = showsToUpdate[i];
                    const progress = ((i + 1) / showsToUpdate.length) * 100;
                    elements.updateProgressBarFill.style.width = `${progress}%`;
                    elements.updateProgressText.textContent = `Controllo ${i + 1} di ${showsToUpdate.length}: ${show.title}...`;

                    try {
                        const showChanges = await showDetailsModal(show.id, true);
                        if (showChanges.length > 0) {
                            allChanges = allChanges.concat(showChanges);
                        }
                        await new Promise(resolve => setTimeout(resolve, 400));
                    } catch (error) {
                        console.error(`Errore aggiornando ${show.title} in background:`, error);
                    }
                }

                closeModal(elements.updateProgressModal);

                if (allChanges.length > 0) {
                    // SALVA NELLO STORICO
                    addToUpdateHistory(allChanges);
                    elements.updateSummaryList.innerHTML = allChanges.map(change => `<li>${change}</li>`).join('');
                    openModal(elements.updateSummaryModal);
                } else if (force) {
                    showNotification("Nessun aggiornamento trovato.", "success");
                }

                localStorage.setItem('lastBackgroundUpdate', now);
                displayLastUpdateTime();
            } finally {
                isUpdateInProgress = false;
            }
        }

        function setupAuthListeners() {
            elements.authToggle.addEventListener("click", () => openModal(elements.authModal));

            document.querySelectorAll(".auth-tab").forEach(tab => tab.addEventListener("click", () => {
                document.querySelectorAll(".auth-tab, .auth-form-container").forEach(el => el.classList.remove("active"));
                tab.classList.add("active");
                document.getElementById(`${tab.dataset.tab}Form`).classList.add("active");
            }));
            elements.loginBtn.addEventListener('click', () => firebase.auth().signInWithEmailAndPassword(document.getElementById('loginEmail').value, document.getElementById('loginPassword').value).catch(err => showNotification(err.message, "error")));
            elements.registerBtn.addEventListener('click', () => {
                const pass = document.getElementById('registerPassword').value;
                if (pass !== document.getElementById('registerConfirmPassword').value) { showNotification("Le password non corrispondono.", "warning"); return; }
                firebase.auth().createUserWithEmailAndPassword(document.getElementById('registerEmail').value, pass)
                    .then(cred => db.ref(`users/${cred.user.uid}/email`).set(cred.user.email))
                    .catch(err => showNotification(err.message, "error"));
            });
            elements.logoutBtn.addEventListener("click", () => {
                detachAllFriendListeners();
                firebase.auth().signOut()
            });
            firebase.auth().onAuthStateChanged(user => {
                if (isViewMode) return;
                currentUser = user;
                updateAuthUI();
                if (user) {
                    loadData();
                } else {
                    loadLocalData();
                    // --- MIGRATION LOGIC FOR DROPPED SHOWS ---
                    let migrationNeeded = false;
                    mediaList.forEach(show => {
                        if (show.category === "In Pausa / Droppata") {
                            show.isDropped = true;
                            // Move to "In Corso" unless progress is 0, then "Da Vedere"
                            const totalEpisodes = show.totalEpisodes || 0;
                            const watchedEpisodes = show.progress ? Object.values(show.progress).reduce((a, b) => a + b, 0) : 0;
                            show.category = (watchedEpisodes === 0) ? "Da Vedere" : "In Corso";
                            migrationNeeded = true;
                        }
                    });

                    // Remove "In Pausa / Droppata" from categories list if present
                    const droppedCatIndex = categories.findIndex(c => (typeof c === 'string' ? c : c.name) === "In Pausa / Droppata");
                    if (droppedCatIndex !== -1) {
                        categories.splice(droppedCatIndex, 1);
                        migrationNeeded = true;
                    }

                    if (migrationNeeded && !isViewMode) {
                        saveData();
                        console.log("Migration for Dropped shows completed.");
                    }
                    // -----------------------------------------

                    renderFullUI();
                    hideLoader();
                }
            });
        }

        function updateAuthUI() {
            const userActionBtn = elements.mobileMenuUserActionBtn.querySelector('span');
            if (currentUser) {
                elements.userInfo.style.display = "flex";
                elements.authToggle.style.display = "none";
                elements.notificationBellContainer.style.display = 'block';
                elements.updateSectionDesktop.style.display = 'block';
                if (userActionBtn) {
                    userActionBtn.textContent = 'Logout';
                    elements.mobileMenuUserActionBtn.style.color = 'var(--danger)';
                    elements.mobileMenuUserActionBtn.querySelector('i').style.color = 'var(--danger)';
                }
            } else {
                elements.userInfo.style.display = "none";
                elements.authToggle.style.display = "inline-flex";
                elements.notificationBellContainer.style.display = 'none';
                elements.updateSectionDesktop.style.display = 'none';
                if (userActionBtn) {
                    userActionBtn.textContent = 'Login / Registrati';
                    elements.mobileMenuUserActionBtn.style.color = '';
                    elements.mobileMenuUserActionBtn.querySelector('i').style.color = '';
                }
            }
        }

        function handleViewMode() {
            const viewId = new URLSearchParams(window.location.search).get("view");
            if (!viewId) { hideLoader(); return false; }
            isViewMode = true;
            document.body.style.paddingBottom = '0';
            document.getElementById('bottomNav').style.display = 'none';
            document.querySelectorAll("#mediaManagementBtn, #shareBtn, #exportBtn, #importBtn, #resetBtn, #authToggle, #userInfo, .notification-bell-container").forEach(el => el.style.display = "none");
            elements.viewModeBanner.style.display = "flex";
            db.ref(`users/${viewId}/tvShowTracker`).on("value", snapshot => {
                const data = snapshot.val();
                if (data) {
                    mediaList = (data.mediaList || []).map(item => ({ ...getDefaultShowProps(), ...item }));
                    categories = (data.categories || DEFAULT_CATEGORIES.map(name => ({ name, hideProgress: false }))).map(cat => (typeof cat === 'string') ? { name: cat, hideProgress: false } : cat);
                    renderFullUI();
                    db.ref(`users/${viewId}/email`).once("value", emailSnap => {
                        elements.viewModeUserEmail.textContent = `Stai visualizzando la libreria di ${emailSnap.val() || "un utente"}`;
                    });
                } else { showNotification("Libreria condivisa non trovata.", "error"); }
                hideLoader();
            });
            return true;
        }

        function logActivity(type, title, details) {
            if (!currentUser) return;
            const logRef = db.ref(`users/${currentUser.uid}/activityLog`);
            const activity = {
                type,
                title,
                details,
                timestamp: new Date().toISOString(),
                link: `${window.location.origin}${window.location.pathname.replace('index.html', 'serietv_tracker.html')}?view=${currentUser.uid}`
            };

            return logRef.transaction(currentLog => {
                let log = Array.isArray(currentLog) ? currentLog : [];
                log.unshift(activity);
                return log.slice(0, MAX_LOG_SIZE);
            });
        }

        function detachAllFriendListeners() {
            Object.values(friendListeners).forEach(({ ref, listener }) => ref.off('value', listener));
            friendListeners = {};
        }

        function setupFriendListeners() {
            if (!currentUser) return;
            detachAllFriendListeners();
            const friendActivityMap = new Map();
            const processAndRenderNotifications = () => {
                let allNewNotifications = Array.from(friendActivityMap.values()).flat();
                allNewNotifications.sort((a, b) => {
                    // Check if activity is related to a dropped show
                    const showA = mediaList.find(m => m.title === a.activity.title);
                    const showB = mediaList.find(m => m.title === b.activity.title);
                    const isDroppedA = showA ? showA.isDropped : false;
                    const isDroppedB = showB ? showB.isDropped : false;

                    // Sort dropped shows to the bottom
                    if (isDroppedA && !isDroppedB) return 1;
                    if (!isDroppedA && isDroppedB) return -1;

                    // Secondary sort by date (descending)
                    return new Date(b.activity.timestamp) - new Date(a.activity.timestamp);
                });
                renderNotifications(allNewNotifications.slice(0, MAX_NOTIFICATIONS));
            };

            followedFriends.forEach(friend => {
                const ref = db.ref(`users/${friend.id}/activityLog`);
                const listener = snapshot => {
                    const activities = snapshot.val() || [];
                    const lastChecked = lastCheckedTimestamps[friend.id] || new Date(0).toISOString();

                    const activityArray = Array.isArray(activities) ? activities : [];
                    const newActivities = activityArray
                        .filter(act => act && new Date(act.timestamp) > new Date(lastChecked))
                        .map(activity => ({ friendId: friend.id, friendEmail: friend.email, activity }));

                    friendActivityMap.set(friend.id, newActivities);
                    processAndRenderNotifications();
                };
                ref.on('value', listener);
                friendListeners[friend.id] = { ref, listener };
            });
        }

        function populateNotificationList(listElement, notifications) {
            listElement.innerHTML = ''; // Clear previous notifications
            if (notifications.length > 0) {
                notifications.forEach(n => {
                    if (!n.activity) return;
                    const item = document.createElement('div');
                    item.className = 'notification-item';
                    item.dataset.friendId = n.friendId;
                    const isTV = n.activity.type.includes('show') || n.activity.type.includes('season');
                    item.innerHTML = `
                    <i class="fas ${getActivityIcon(n.activity.type)} ${isTV ? 'tv-notification' : 'film-notification'}"></i>
                    <span class="notification-item-text">${getActivityText(n.friendEmail, n.activity)}</span>`;

                    item.addEventListener('click', () => {
                        const friendId = item.dataset.friendId;
                        if (friendId) {
                            const baseUrl = window.location.origin + window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/'));
                            const url = isTV
                                ? `${baseUrl}/serietv_tracker.html?view=${friendId}`
                                : `${baseUrl}/index.html?view=${friendId}`;
                            window.open(url, '_blank');
                        }
                    });
                    listElement.appendChild(item);
                });
            } else {
                const emptyState = document.createElement('div');
                emptyState.className = 'no-notifications';
                emptyState.textContent = 'Nessuna nuova notifica';
                listElement.appendChild(emptyState);
            }
        }

        function renderNotifications(notifications) {
            const count = notifications.length;

            // Desktop Dropdown
            elements.notificationBadge.textContent = count;
            elements.notificationBadge.classList.toggle('visible', count > 0);
            const desktopList = elements.notificationDropdown.querySelector('.notification-list');
            if (!desktopList) { // Initial setup for desktop dropdown
                elements.notificationDropdown.innerHTML = `
                <div class="notification-header">Notifiche Amici</div>
                <div class="notification-list"></div>
                <div class="notification-footer">
                    <button class="btn btn-primary btn-small" id="markReadAllDesktop"><i class="fas fa-check-double"></i> Segna tutte come lette</button>
                </div>`;
                document.getElementById('markReadAllDesktop').addEventListener('click', markAllNotificationsAsRead);
            }
            populateNotificationList(elements.notificationDropdown.querySelector('.notification-list'), notifications);

            // Mobile Modal
            elements.notificationBadgeMobile.textContent = count;
            elements.notificationBadgeMobile.classList.toggle('visible', count > 0);
            populateNotificationList(elements.notificationListMobile, notifications);
        }


        function markAllNotificationsAsRead() {
            if (!currentUser) return;
            followedFriends.forEach(f => lastCheckedTimestamps[f.id] = new Date().toISOString());
            saveSocialData();
            renderNotifications([]); // This will clear both desktop and mobile
            closeModal(elements.mobileNotificationsModal);
        }

        function getActivityIcon(type) {
            if (type.startsWith('add_show')) return 'fa-plus-circle';
            if (type.startsWith('move_show')) return 'fa-folder-open';
            if (type.startsWith('delete_show')) return 'fa-trash-alt';
            if (type.startsWith('complete_show') || type === 'mark_completed') return 'fa-check-double';
            if (type.startsWith('complete_season')) return 'fa-check-circle';
            if (type === 'add') return 'fa-film';
            if (type === 'move') return 'fa-folder-open';
            if (type === 'delete') return 'fa-trash-alt';
            if (type === 'rewatch') return 'fa-sync-alt';
            return 'fa-info-circle';
        }

        function getActivityText(friendEmail, activity) {
            const email = `<strong>${friendEmail || 'Utente'}</strong>`;
            const title = `<strong>${activity.title}</strong>`;
            switch (activity.type) {
                case 'add_show': return `${email} ha aggiunto la serie ${title} ${activity.details}`;
                case 'move_show': return `${email} ha spostato la serie ${title} ${activity.details}`;
                case 'delete_show': return `${email} ha eliminato la serie ${title} ${activity.details}`;
                case 'complete_show': return `${email} ha completato la serie ${title}! 🎉`;
                case 'mark_completed': return `${email} ha segnato ${title} come completato.`;
                case 'complete_season': return `${email} ha completato ${activity.details} di ${title}`;
                case 'add': return `${email} ha aggiunto il film ${title} ${activity.details}`;
                case 'move': return `${email} ha spostato il film ${title} ${activity.details}`;
                case 'delete': return `${email} ha eliminato il film ${title} ${activity.details}`;
                case 'rewatch': return `${email} ha aggiornato ${title} (${activity.details})`;
                default: return `${email} ha aggiornato ${title}`;
            }
        }

        async function addFriend() {
            const friendId = elements.friendIdInput.value.trim();
            if (!friendId || !currentUser) return;
            if (friendId === currentUser.uid) { showNotification("Non puoi aggiungere te stesso.", "warning"); return; }
            if (followedFriends.some(f => f.id === friendId)) { showNotification("Amico già presente in lista.", "warning"); return; }
            const friendEmailRef = db.ref(`users/${friendId}/email`);
            const snapshot = await friendEmailRef.once('value');
            if (snapshot.exists()) {
                followedFriends.push({ id: friendId, email: snapshot.val() });
                lastCheckedTimestamps[friendId] = new Date().toISOString();
                await saveSocialData();
                renderFriendsList();
                setupFriendListeners();
                showNotification("Amico aggiunto!", "success");
            } else {
                showNotification("ID Utente non trovato.", "error");
            }
        }

        async function removeFriend(friendId) {
            followedFriends = followedFriends.filter(f => f.id !== friendId);
            delete lastCheckedTimestamps[friendId];
            await saveSocialData();
            renderFriendsList();
            setupFriendListeners();
        }

        function renderFriendsList() {
            if (!currentUser) { elements.friendsList.innerHTML = "<p>Devi essere loggato per usare questa funzione.</p>"; document.getElementById('myIdContainer').style.display = 'none'; return; }
            document.getElementById('myIdContainer').style.display = 'block';
            elements.myIdInput.value = currentUser.uid;
            elements.friendsList.innerHTML = "";
            if (followedFriends.length === 0) { elements.friendsList.innerHTML = `<p style="text-align:center; color: var(--text-secondary);">Non stai seguendo nessun amico.</p>`; return; }
            followedFriends.forEach(friend => {
                const card = document.createElement("div"); card.className = "management-card";
                card.innerHTML = `
                <div>
                    <div>
                        <div class="friend-email">${friend.email}</div>
                        <div class="friend-id">${friend.id}</div>
                    </div>
                </div>
                <div class="management-card-actions">
                    <button class="btn visit-friend-films-btn" data-id="${friend.id}" title="Visita Libreria Film"><i class="fas fa-film"></i></button>
                    <button class="btn visit-friend-tv-btn" data-id="${friend.id}" title="Visita Libreria Serie TV"><i class="fas fa-tv"></i></button>
                    <button class="btn btn-danger remove-friend-btn" data-id="${friend.id}" title="Rimuovi Amico"><i class="fas fa-trash"></i></button>
                </div>`;
                card.querySelector('.remove-friend-btn').addEventListener('click', () => removeFriend(friend.id));
                card.querySelector('.visit-friend-films-btn').addEventListener('click', (e) => {
                    const url = `${window.location.origin}${window.location.pathname.replace('serietv_tracker.html', 'index.html')}?view=${e.currentTarget.dataset.id}`;
                    window.open(url, '_blank');
                });
                card.querySelector('.visit-friend-tv-btn').addEventListener('click', (e) => {
                    const url = `${window.location.origin}${window.location.pathname}?view=${e.currentTarget.dataset.id}`;
                    window.open(url, '_blank');
                });
                elements.friendsList.appendChild(card);
            });
        }

        async function toggleFavorite(showId) {
            if (isViewMode) return;
            const show = mediaList.find(m => m.id === showId);
            if (show) {
                show.isFavorite = !show.isFavorite;
                await saveData();

                const cardBtn = document.querySelector(`.media-card[data-id="${showId}"] .favorite-btn`);
                if (cardBtn) cardBtn.classList.toggle('is-favorite', show.isFavorite);

                const modalBtn = document.getElementById('detailsModalFavoriteBtn');
                if (modalBtn && elements.detailsModal.style.display === 'flex') {
                    modalBtn.classList.toggle('is-favorite', show.isFavorite);
                }

                if (elements.categoryFilter.value === 'favorites') {
                    renderMedia();
                }
            }
        }

        function openRewatchModal(context) {
            currentRewatchContext = context;
            const { showId, seasonNumber, episodeNumber } = context;
            const show = mediaList.find(s => s.id === showId);
            if (!show) return;

            let currentCount = 0;
            let title = "";

            if (episodeNumber) {
                const episodeKey = `${seasonNumber}-${episodeNumber}`;
                currentCount = show.rewatches?.[episodeKey] || 0;
                const episode = show.seasons?.[seasonNumber]?.episodes.find(e => e.episode_number == episodeNumber);
                title = episode ? `S${seasonNumber} E${episodeNumber} - ${episode.name}` : `Episodio S${seasonNumber}E${episodeNumber}`;
            } else {
                title = `Stagione ${seasonNumber}`;
            }

            elements.rewatchModalTitle.textContent = `Rewatch: ${title}`;
            elements.rewatchCountInput.value = currentCount;
            updateRewatchModalButtons(currentCount);

            openModal(elements.rewatchModal);
        }

        async function setRewatchCount(count) {
            const { showId, seasonNumber, episodeNumber } = currentRewatchContext;
            const show = mediaList.find(s => s.id === showId);
            if (!show) return;

            const duplicates = mediaList.filter(d => (d.imdbID && d.imdbID === show.imdbID) || (d.tmdbID && d.tmdbID === show.tmdbID));

            // 1. Aggiorna i dati in memoria (MediaList)
            duplicates.forEach(dup => {
                if (!dup.rewatches) dup.rewatches = {};

                const updateLogic = (sNum, eNum) => {
                    const key = `${sNum}-${eNum}`;
                    if (count > 0) {
                        dup.rewatches[key] = count;
                        if (!dup.progress[key]) dup.progress[key] = true; // Se rivedo, è visto
                    } else {
                        delete dup.rewatches[key];
                    }

                    // --- DOM UPDATE CHIRURGICO ---
                    // Troviamo l'elemento specifico dell'episodio nel DOM
                    const item = document.getElementById(`item-${showId}-${sNum}-${eNum}`);
                    if (item) {
                        // Aggiorna stato 'watched' visivamente (classe CSS)
                        if (count > 0) item.classList.add('watched');

                        // Trova il badge rewatch dentro questo item
                        const badge = item.querySelector('.episode-rewatch-badge');
                        if (badge) {
                            if (count > 0) {
                                badge.classList.remove('zero-count');
                                badge.innerHTML = `<i class="fas fa-sync-alt"></i> <span class="count">${count}</span>`;
                            } else {
                                badge.classList.add('zero-count');
                                badge.innerHTML = `<i class="fas fa-sync-alt"></i>`;
                            }
                        }
                    }
                };

                if (episodeNumber) {
                    // Singolo episodio
                    updateLogic(seasonNumber, episodeNumber);
                } else {
                    // Intera stagione
                    const season = dup.seasons[seasonNumber];
                    if (season && season.episodes) {
                        season.episodes.forEach(ep => updateLogic(seasonNumber, ep.episode_number));
                    }
                }
                updateShowCategoryAndTimestamps(dup);
            });

            // 2. Aggiorna icona "Stagione Rivista" nell'header (senza ricaricare)
            updateSeasonHeaderUI(showId, seasonNumber);

            // 3. Chiudi modale e salva (in background)
            closeModal(elements.rewatchModal);
            updateStats(); // Veloce, aggiorna solo i numeri in alto
            await saveData();
            showNotification("Rewatch aggiornato", "success");
        }

        // Nuova funzione helper per aggiornare l'header della stagione
        function updateSeasonHeaderUI(showId, seasonNumber) {
            const show = mediaList.find(s => s.id === showId);
            if (!show || !show.seasons[seasonNumber]) return;

            const episodes = show.seasons[seasonNumber].episodes || [];
            // Controlla se TUTTI gli episodi hanno rewatch > 0
            const isSeasonRewatched = episodes.length > 0 && episodes.every(ep => (show.rewatches[`${seasonNumber}-${ep.episode_number}`] || 0) > 0);

            const header = document.querySelector(`.season-header[data-season-target="${seasonNumber}"]`);
            if (header) {
                const titleContainer = header.querySelector('.season-title-container');
                const existingBadge = titleContainer.querySelector('.season-rewatch-badge');

                if (isSeasonRewatched) {
                    if (!existingBadge) {
                        // Aggiungi badge se non c'è
                        const badge = document.createElement('span');
                        badge.className = 'season-rewatch-badge';
                        badge.title = 'Stagione rivista';
                        badge.innerHTML = '<i class="fas fa-sync-alt"></i>';
                        // Inserisci dopo il titolo (che è il primo figlio span)
                        const titleSpan = titleContainer.querySelector('.season-title');
                        titleSpan.insertAdjacentElement('afterend', badge);
                    }
                } else {
                    if (existingBadge) {
                        // Rimuovi badge se c'è
                        existingBadge.remove();
                    }
                }

                // Aggiorna anche il testo progressi (es. 10/10)
                const progressText = header.querySelector('.season-progress-text');
                const watchedCount = Object.keys(show.progress).filter(k => k.startsWith(`${seasonNumber}-`)).length;
                if (progressText) progressText.textContent = `${watchedCount} / ${episodes.length}`;
            }
        }


        function updateRewatchModalButtons(count) {
            document.querySelectorAll('#rewatchModal .quick-rewatch-btn').forEach(btn => {
                btn.classList.toggle('active', parseInt(btn.dataset.count) === count);
            });
        }

        function displayLastUpdateTime() {
            const lastUpdate = localStorage.getItem('lastBackgroundUpdate');
            let timestampText = "Mai eseguito";
            if (lastUpdate) {
                timestampText = new Date(parseInt(lastUpdate)).toLocaleString('it-IT');
            }
            elements.lastUpdateTimestampDesktop.textContent = `Ultimo aggiornamento: ${timestampText}`;
            elements.lastUpdateTimestampMobile.textContent = `Ultimo aggiornamento: ${timestampText}`;
        }


        /* --- GESTIONE MODALI E BACK GESTURE (HISTORY API) --- */

        // 1. Nuova funzione unificata per aprire i modali
        function openModal(modal) {
            if (!modal) return;

            // Se stiamo aprendo un modale sopra un altro già aperto
            const alreadyOpen = document.querySelector('.modal.visible');
            if (alreadyOpen && alreadyOpen !== modal) {
                // Rendiamo il modale sotto leggermente più scuro o sfocato
                alreadyOpen.style.filter = "blur(2px) brightness(0.8)";
            }

            modal.style.display = 'flex';
            document.body.classList.add('modal-open');

            setTimeout(() => {
                modal.classList.add('visible');
            }, 10);

            // Registriamo lo stato nella cronologia
            history.pushState({ modalId: modal.id }, '', window.location.href);
        }

        // 2. Nuova funzione unificata per chiudere i modali (Rimosso duplicato precedente)
        // 3. Gestore dell'evento "Torna Indietro" (Swipe o Tasto fisico)
        window.addEventListener('popstate', (event) => {
            const visibleModals = Array.from(document.querySelectorAll('.modal'))
                .filter(m => m.classList.contains('visible'));

            if (visibleModals.length > 0) {
                // Ordina per z-index decrescente
                visibleModals.sort((a, b) => {
                    const zA = parseInt(window.getComputedStyle(a).zIndex) || 0;
                    const zB = parseInt(window.getComputedStyle(b).zIndex) || 0;
                    return zB - zA;
                });

                // Chiudiamo quello più in alto
                const topModal = visibleModals[0];
                topModal.classList.remove('visible');

                setTimeout(() => {
                    topModal.style.display = 'none';
                    topModal.style.filter = ""; // Resetta filtri

                    // Se è rimasto un altro modale sotto, togliamo la sfocatura
                    const nextModal = document.querySelector('.modal.visible');
                    if (nextModal) {
                        nextModal.style.filter = "";
                    }

                    if (document.querySelectorAll('.modal.visible').length === 0) {
                        document.body.classList.remove('modal-open');
                    }
                }, 300);
            }
        });

        // --- AGGIORNAMENTO LISTENERS ---
        // Aggiorna setupEventListeners per usare openModal invece di style.display='flex'

        function exportData() {
            if (isViewMode) return;
            const data = { mediaList, categories, exportedAt: new Date().toISOString() };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `serietv_tracker_export_${new Date().toISOString().split("T")[0]}.json`;
            a.click();

            // SALVA IL TIMESTAMP
            const now = new Date().toISOString();
            localStorage.setItem('lastSeriesExport', now);
            if (currentUser) db.ref(`users/${currentUser.uid}/lastExport`).set(now);

            updateBackupBadge(now);
            showNotification("Backup scaricato con successo!", "success");
        }

        function updateBackupBadge(timestamp) {
            const badge = document.querySelector('#lastBackupBadge span');
            const stored = timestamp || localStorage.getItem('lastSeriesExport');
            if (stored) {
                badge.textContent = new Date(stored).toLocaleString('it-IT', {
                    day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit'
                });
            }
        }

        function setupEventListeners() {
            // Modali principali
            elements.mediaManagementBtn.addEventListener("click", () => {
                // Sostituito style.display con openModal
                openModal(elements.mediaManagementModal);
                elements.mediaTitle.value = '';
                elements.tmdbResults.innerHTML = '';
                currentTMDbSelection = null;
                renderCategoriesList();
                renderFriendsList();
                populateAddMediaCategorySelect();
            });

            // Gestione Tabs
            document.querySelectorAll('.tab-btn').forEach(btn => btn.addEventListener('click', () => {
                document.querySelectorAll('.tab-btn, .tab-content').forEach(el => el.classList.remove('active'));
                btn.classList.add('active');
                document.getElementById(`${btn.dataset.tab}-tab`).classList.add('active');
                elements.addShowBtn.style.display = btn.dataset.tab === 'add-media' ? 'inline-flex' : 'none';
            }));

            // Chiusura Modali (Il click fuori dal modale deve chiamare history.back() se implementato, o closeModal)
            elements.closeManagementModal.addEventListener("click", () => closeModal(elements.mediaManagementModal));

            // Pulsante Aggiungi Serie
            elements.addShowBtn.addEventListener('click', () => {
                if (!currentTMDbSelection) { showNotification("Cerca e seleziona una serie.", "warning"); return; }
                addNewMedia(currentTMDbSelection.tmdbId);
            });

            // Ricerca
            elements.searchTMDbBtn.addEventListener("click", searchTMDb);
            elements.mediaTitle.addEventListener("keydown", e => { if (e.key === "Enter") searchTMDb(); });

            // Categorie
            elements.addCategoryBtn.addEventListener("click", addCategory);
            elements.newCategoryName.addEventListener("keydown", e => { if (e.key === "Enter") addCategory(); });

            // Filtri e Ricerca home
            elements.searchInput.addEventListener("input", () => { clearTimeout(debounceTimeout); debounceTimeout = setTimeout(renderMedia, 300); });
            elements.categoryFilter.addEventListener("change", renderMedia);
            elements.sortFilter.addEventListener("change", () => { localStorage.setItem("tvShowSortOrder", elements.sortFilter.value); renderMedia(); });

            // Tema
            elements.themeToggle.addEventListener("click", () => { document.body.classList.toggle("dark"); localStorage.setItem("theme", document.body.classList.contains("dark") ? "dark" : "light"); loadTheme(); });

            // Pulsanti Chiusura Modali (X)
            elements.detailsModalClose.addEventListener('click', () => closeModal(elements.detailsModal));
            elements.episodesModalClose.addEventListener('click', () => closeModal(elements.episodesModal));
            elements.actorModalClose.addEventListener('click', () => closeModal(elements.actorModal));

            // Chiusura cliccando sullo sfondo scuro (Overlay)
            // Chiusura cliccando sullo sfondo scuro (Overlay)
            document.addEventListener("click", e => {
                if (e.target.classList.contains('modal')) {
                    closeModal(e.target);
                }
                if (!e.target.closest('.notification-bell-container')) elements.notificationDropdown.classList.remove('visible');
            });

            // Poster Modal
            elements.savePosterChange.addEventListener('click', () => { const selected = document.querySelector(".poster-option.selected"); if (selected) changePoster(elements.posterModal.dataset.mediaId, selected.dataset.url); });
            elements.cancelPosterChange.addEventListener('click', () => closeModal(elements.posterModal));

            // Settings Modal
            elements.settingsBtn.addEventListener('click', () => {
                updateBackupBadge();
                openModal(document.getElementById('settingsModal'));
            });

            // Click sulle card interne
            document.getElementById('exportAction').addEventListener('click', exportData);
            document.getElementById('importAction').addEventListener('click', () => {
                if (elements.importFile) elements.importFile.click();
            });
            document.getElementById('resetAction').addEventListener('click', () => {
                // Chiudiamo il modale impostazioni PRIMA
                closeModal(document.getElementById('settingsModal'));

                // Aspettiamo che finisca l'animazione e poi chiediamo conferma
                setTimeout(() => {
                    resetApp();
                }, 350);
            });
            if (elements.importFile) {
                elements.importFile.addEventListener('change', e => {
                    const file = e.target.files[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = event => {
                        try {
                            const data = JSON.parse(event.target.result);
                            if (data && Array.isArray(data.mediaList)) {
                                // Chiudiamo il modale impostazioni PRIMA
                                closeModal(document.getElementById('settingsModal'));

                                setTimeout(() => {
                                    showConfirmModal("Importa Dati", `Sovrascrivere i dati con ${data.mediaList.length} serie?`, () => {
                                        mediaList = data.mediaList.map(item => ({ ...getDefaultShowProps(), ...item }));
                                        categories = (data.categories || DEFAULT_CATEGORIES.map(name => ({ name, hideProgress: false }))).map(cat => typeof cat === 'string' ? { name: cat, hideProgress: false } : cat);
                                        saveData();
                                        renderFullUI();
                                        showNotification("Dati importati!", "success");
                                    });
                                }, 350);
                            } else {
                                showNotification("File non valido.", "error");
                            }
                        } catch (error) {
                            showNotification("Errore lettura file.", "error");
                        }
                    };
                    reader.readAsText(file);
                    e.target.value = '';
                });
            }

            // Share
            elements.shareBtn.addEventListener('click', () => { if (!currentUser) { showNotification("Devi essere loggato per condividere.", "warning"); return; } const link = `${window.location.origin}${window.location.pathname.replace('index.html', 'serietv_tracker.html')}?view=${currentUser.uid}`; elements.shareModal.querySelector('input').value = link; openModal(elements.shareModal); }); // Usa openModal
            elements.closeShareModalBtn.addEventListener('click', () => closeModal(elements.shareModal));
            elements.copyShareLinkBtn.addEventListener('click', (e) => { navigator.clipboard.writeText(e.target.closest('.modal-content').querySelector('input').value); showNotification("Link copiato!", "success"); });

            // Social e Varie
            elements.closeViewBtn.addEventListener('click', () => { window.location.href = window.location.pathname; });
            elements.addFriendBtn.addEventListener('click', addFriend);
            elements.copyMyIdBtn.addEventListener('click', () => { navigator.clipboard.writeText(elements.myIdInput.value); showNotification("ID copiato!", "success"); });
            elements.bellIcon.addEventListener('click', (e) => { e.stopPropagation(); elements.notificationDropdown.classList.toggle('visible'); });
            elements.closeSummaryBtn.addEventListener('click', () => closeModal(elements.updateSummaryModal));

            // Rewatch Modal
            elements.confirmRewatchBtn.addEventListener('click', () => { const newCount = parseInt(elements.rewatchCountInput.value); if (!isNaN(newCount) && newCount >= 0) { setRewatchCount(newCount); } else { showNotification("Inserisci un numero valido (0 o superiore).", "warning"); } });
            elements.cancelRewatchBtn.addEventListener('click', () => closeModal(elements.rewatchModal));
            document.querySelectorAll('#rewatchModal .quick-rewatch-btn').forEach(btn => btn.addEventListener('click', () => { const count = parseInt(btn.dataset.count); elements.rewatchCountInput.value = count; updateRewatchModalButtons(count); }));
            elements.rewatchCountInput.addEventListener('input', () => { const count = parseInt(elements.rewatchCountInput.value); updateRewatchModalButtons(count); });
            document.querySelectorAll("#rewatchModal .num-spinner-btn").forEach(btn => { btn.addEventListener("click", e => { const target = document.getElementById(e.currentTarget.dataset.target); if (target) { let value = parseInt(target.value) || 0; value += e.currentTarget.classList.contains("up") ? 1 : -1; if (value < 0) value = 0; target.value = value; updateRewatchModalButtons(value); } }); });

            // --- Bottom Nav Bar Listeners ---
            elements.bottomNavHome.addEventListener('click', () => {
                populateCategoryNavModal();
                openModal(elements.categoryNavModal);
                requestAnimationFrame(() => elements.categoryNavModal.classList.add('visible'));
            });
            elements.bottomNavCalendar.addEventListener('click', () => {
                renderCalendar();
                openModal(document.getElementById('calendarModal'));
            });


            elements.bottomNavAdd.addEventListener('click', () => { elements.mediaManagementBtn.click(); document.querySelector('.tab-btn[data-tab="add-media"]').click(); });
            elements.bottomNavManage.addEventListener('click', () => { openModal(elements.mobileMenuModal); requestAnimationFrame(() => elements.mobileMenuModal.classList.add('visible')); });
            elements.bottomNavNotifications.addEventListener('click', () => { openModal(elements.mobileNotificationsModal); requestAnimationFrame(() => elements.mobileNotificationsModal.classList.add('visible')); });

            // --- Mobile Modals Listeners ---
            elements.mobileMenuCloseBtn.addEventListener('click', () => closeModal(elements.mobileMenuModal));
            elements.mobileNotificationsCloseBtn.addEventListener('click', () => closeModal(elements.mobileNotificationsModal));
            elements.markAllReadMobileBtn.addEventListener('click', markAllNotificationsAsRead);
            elements.mobileMenuUserActionBtn.addEventListener('click', () => { (currentUser) ? elements.logoutBtn.click() : elements.authToggle.click(); closeModal(elements.mobileMenuModal); });
            elements.mobileMenuShareBtn.addEventListener('click', () => {
                closeModal(elements.mobileMenuModal);
                if (!currentUser) {
                    showNotification("Devi essere loggato per condividere.", "warning");
                } else {
                    setTimeout(() => {
                        const link = `${window.location.origin}${window.location.pathname.replace('index.html', 'serietv_tracker.html')}?view=${currentUser.uid}`;
                        document.getElementById("shareLinkInput").value = link;
                        openModal(elements.shareModal);
                    }, 300);
                }
            });
            elements.mobileSettingsBtn.addEventListener('click', () => {
                closeModal(elements.mobileMenuModal);
                setTimeout(() => {
                    updateBackupBadge();
                    openModal(document.getElementById('settingsModal'));
                }, 300);
            });
            elements.mobileMenuThemeBtn.addEventListener('click', () => { elements.themeToggle.click(); });

            // --- Category Navigation Modal Listeners ---
            elements.closeCategoryNavBtn.addEventListener('click', () => closeModal(elements.categoryNavModal));

            // --- Filter Modal Listeners ---
            elements.mobileFilterBtn.addEventListener('click', () => {
                elements.mobileCategoryFilter.value = elements.categoryFilter.value;
                elements.mobileSortFilter.value = elements.sortFilter.value;
                openModal(elements.filterSortModal);
                requestAnimationFrame(() => elements.filterSortModal.classList.add('visible'));
            });
            elements.applyFiltersBtn.addEventListener('click', () => {
                elements.categoryFilter.value = elements.mobileCategoryFilter.value;
                elements.sortFilter.value = elements.mobileSortFilter.value;
                localStorage.setItem("tvShowSortOrder", elements.sortFilter.value);
                renderMedia();
                closeModal(elements.filterSortModal);
            });

            // --- Force Update Listeners ---
            const forceUpdate = () => { updateAllShowsInBackground(true); };
            elements.forceUpdateBtnDesktop.addEventListener('click', forceUpdate);
            elements.forceUpdateBtnMobile.addEventListener('click', () => { forceUpdate(); closeModal(elements.mobileMenuModal); });

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                // Chiudi modale con ESC
                if (e.key === "Escape") {
                    const visibleModal = document.querySelector('.modal[style*="flex"]');
                    if (visibleModal) closeModal(visibleModal);
                }

                // Focus sulla ricerca con il tasto "/"
                if (e.key === "/" && !["INPUT", "TEXTAREA"].includes(document.activeElement.tagName)) {
                    e.preventDefault();
                    elements.searchInput.focus();
                }
            });

            // --- Update History Listeners ---
            document.getElementById('viewHistoryBtnDesktop').addEventListener('click', () => {
                renderUpdateHistory();
                openModal(document.getElementById('historyModal'));
            });

            document.getElementById('viewHistoryBtnMobile').addEventListener('click', () => {
                // 1. Chiudiamo il menu mobile visivamente senza attivare history.back()
                elements.mobileMenuModal.classList.remove('visible');

                // 2. Aspettiamo un istante che il menu sparisca
                setTimeout(() => {
                    elements.mobileMenuModal.style.display = 'none';
                    document.body.classList.remove('modal-open');

                    // 3. Ora "puliamo" lo stato della cronologia del menu mobile 
                    // in modo che il tasto "indietro" non lo riapra
                    history.replaceState(null, '', window.location.href);

                    // 4. Infine apriamo lo storico come nuovo stato
                    renderUpdateHistory();
                    openModal(document.getElementById('historyModal'));
                }, 300);
            });

            document.getElementById('clearHistoryBtn').addEventListener('click', (e) => {
                // Evitiamo che il click si propaghi ad altri elementi sotto
                e.stopPropagation();

                // Apriamo il modale di conferma (grazie allo z-index 1300 apparirà SOPRA lo storico)
                showConfirmModal(
                    "Cancella Storico",
                    "Vuoi svuotare tutta la cronologia degli aggiornamenti?",
                    () => {
                        // Logica di cancellazione
                        updateHistory = [];
                        localStorage.removeItem('updateHistory');
                        if (currentUser) db.ref(`users/${currentUser.uid}/updateHistory`).remove();
                        renderUpdateHistory();
                        showNotification("Storico rimosso", "success");
                    }
                );
            });

            // --- Calendar Listeners ---
            document.getElementById('calendarBtn').addEventListener('click', () => {
                renderCalendar();
                openModal(document.getElementById('calendarModal'));
            });

            document.getElementById('bottomNavCalendar').addEventListener('click', () => {
                renderCalendar();
                openModal(document.getElementById('calendarModal'));
            });

            document.getElementById('calendarFilterToggle').addEventListener('change', (e) => {
                calendarOnlyInCorso = e.target.checked;
                renderCalendar(); // Ricarica la lista istantaneamente
            });
        }
    </script>
    <script>
        // Registrazione Service Worker per PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then(reg => console.log('PWA Service Worker registrato!', reg))
                    .catch(err => console.log('Errore PWA:', err));
            });
        }
    </script>
    <div class="modal" id="historyModal">
        <div class="modal-content">
            <h2 style="text-align: center; margin-top: 0;">Storico Aggiornamenti</h2>
            <div id="historyList" style="max-height: 60vh; overflow-y: auto; padding: 0.5rem;">
                <!-- Qui verranno inseriti i log -->
            </div>
            <div class="modal-footer"
                style="padding-top: 1rem; border-top: 1px solid var(--border-color); display: flex; justify-content: space-between; gap: 1rem;">
                <button id="clearHistoryBtn" class="btn btn-danger btn-small">Cancella Storico</button>
                <button onclick="closeModal(document.getElementById('historyModal'))"
                    class="btn btn-secondary">Chiudi</button>
            </div>
        </div>
    </div>

    <div class="modal" id="calendarModal">
        <div class="modal-content">
            <div
                style="display: flex; justify-content: space-between; align-items: center; padding: 1rem 1.5rem; border-bottom: 1px solid var(--border-color);">
                <h2 style="margin: 0; font-size: 1.25rem;">Calendario</h2>

                <!-- SWITCH FILTRO -->
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 0.8rem; font-weight: 600; color: var(--text-secondary);">Solo "In
                        Corso"</span>
                    <label class="switch">
                        <input type="checkbox" id="calendarFilterToggle" checked>
                        <span class="slider round"></span>
                    </label>
                </div>
            </div>

            <div id="calendarList" style="flex: 1; overflow-y: auto; padding: 1rem;">
                <!-- Gli episodi appariranno qui -->
            </div>
            <div class="modal-footer calendar-footer">
                <button onclick="closeModal(document.getElementById('calendarModal'))"
                    class="btn btn-secondary full-width-btn">Chiudi</button>
            </div>
        </div>
    </div>



</body>

</html>
