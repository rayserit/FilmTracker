<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Serie TV Tracker</title>
  <!-- PWA Configuration -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#2a9d8f">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" href="icon.svg">
  
  <link rel="icon" href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><path fill="%232a9d8f" d="M592 0H48A48 48 0 0 0 0 48v320a48 48 0 0 0 48 48h160v32a32 32 0 0 0 32 32h160a32 32 0 0 0 32-32v-32h160a48 48 0 0 0 48-48V48a48 48 0 0 0 -48-48zm-16 352H64V64h512zM272 448h96v-32h-96z"/></svg>' type="image/svg+xml">
  
  <!-- Google Fonts: Inter -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css">
  
  <!-- Firebase (Versione 8 - Stabile) -->
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
  
  <style>
    :root {
      --primary: #2a9d8f;
      --secondary: #4ecdc4;
      --danger: #ff4444;
      --success: #2a9d8f;
      --warning: #f4a261; /* Arancione */
      --bg-color: #f4f7fa;
      --card-bg: white;
      --text-color: #1a1a1a;
      --text-secondary: #666;
      --border-color: #e0e0e0;
      --section-tint: rgba(42, 157, 143, 0.05);
      --progress-bg: #e0e0e0;
      --progress-fill: #66cc00;
      --progress-fill-ended: #9c04fc;
      --film-accent: #3A86FF;
    }

    body.dark {
      --bg-color: #121212;
      --card-bg: #1e1e1e;
      --text-color: #f5f5f5;
      --text-secondary: #aaa;
      --border-color: #333;
      --section-tint: rgba(42, 157, 143, 0.08);
      --progress-bg: #444;
    }

    .tracker-switch {
        display: flex;
        background-color: rgba(128,128,128,0.1);
        border-radius: 8px;
        padding: 4px;
        border: 1px solid var(--border-color);
    }
    .tracker-switch-btn {
        padding: 0.25rem 0.75rem;
        text-decoration: none;
        color: var(--text-secondary);
        border-radius: 6px;
        transition: all 0.2s ease;
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.9rem;
    }
    .tracker-switch-btn.active {
        background: var(--primary);
        color: white;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .tracker-switch-btn:not(.active):hover {
        background-color: var(--section-tint);
        color: var(--text-color);
    }
    
    html { scroll-behavior: smooth; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes spin { to { transform: rotate(360deg); } }
    .loading-spinner { animation: spin 1s linear infinite; }
    .user-select-none { -webkit-user-select: none; user-select: none; }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      margin: 0; padding: 1rem; background: var(--bg-color); color: var(--text-color);
      transition: background 0.3s, color 0.3s;
    }
    
    #appLoader {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: var(--bg-color);
        display: flex; justify-content: center; align-items: center; z-index: 2000; transition: opacity 0.3s;
    }
    #appLoader i { font-size: 3rem; color: var(--primary); }

    .top-bar { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem; margin-bottom: 1.5rem; }
    .top-bar-left { display: flex; align-items: center; gap: 1rem; flex-wrap: wrap; }
    .top-bar-left h1 { margin: 0; font-size: 1.75rem; letter-spacing: -1px; color: var(--primary); }
    .top-bar-right { display: flex; align-items: center; gap: 0.75rem; flex-wrap: wrap; }
    .search-box { max-width: 300px; }
    .filter-select { max-width: 180px; }
    #mobileFilterBtn { display: none; }

    /* --- STATS PANEL (ICONS) --- */
    .stats-panel { background-color: var(--section-tint); padding: 1rem; border-radius: 12px; margin-bottom: 2rem; }
    .stats-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 1rem; }
    .stat-item { 
        background: var(--card-bg); 
        padding: 1rem; 
        border-radius: 8px; 
        text-align: center; 
        border: 1px solid var(--border-color); 
        transition: background 0.2s;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
    }
    .stat-item:hover { background: rgba(42, 157, 143, 0.15); }
    .stat-value { font-size: 1.8rem; font-weight: 700; color: var(--text-color); margin-bottom: 0.25rem; line-height: 1; }
    .stat-label { font-size: 0; } 
    .stat-label::after { font-family: "Font Awesome 6 Free"; font-weight: 900; font-size: 1.5rem; color: var(--text-secondary); opacity: 0.7; display: block; margin-top: 5px;}
    
    .stat-item:nth-child(1) .stat-label::after { content: "\f00a"; } /* Totale (Grid) */
    .stat-item:nth-child(2) .stat-label::after { content: "\f04b"; color: var(--success); opacity: 1; } /* In Corso (Play) */
    .stat-item:nth-child(3) .stat-label::after { content: "\f00c"; color: #9c04fc; opacity: 1; } /* Completate (Check) */
    .stat-item:nth-child(4) .stat-label::after { content: "\f02e"; color: var(--warning); opacity: 1; } /* Da Vedere (Bookmark) */
    .stat-item:nth-child(5) .stat-label::after { content: "\f04c"; color: var(--danger); opacity: 1; } /* Pausa (Pause) */
    .stat-item:nth-child(6) .stat-label::after { content: "\f06e"; color: var(--primary); opacity: 1; } /* Episodi (Eye) */
    .stat-item:nth-child(7) .stat-label::after { content: "\f017"; } /* Ore (Clock) */

    /* --- MEDIA CARD --- */
    .media-card { background: var(--card-bg); border-radius: 8px; overflow: hidden; box-shadow: 0 4px 12px rgba(0,0,0,0.08); width: 180px; transition: all 0.2s ease-out; position: relative; border: 1px solid var(--border-color); animation: fadeIn 0.5s ease-out both; cursor: pointer; display: flex; flex-direction: column; }
    .media-card:hover { transform: translateY(-3px); box-shadow: 0 6px 16px rgba(0,0,0,0.15); }
    .media-card.is-stat-contributor { border-top: 2px dashed var(--primary); }
    .media-card.is-duplicate { opacity: 0.65; }
    .media-poster { width: 100%; aspect-ratio: 2 / 3; object-fit: cover; object-position: center top; background-color: var(--border-color); display: block; }
    .media-info { padding: 0.75rem; flex-grow: 1; display: flex; flex-direction: column; }
    .media-title { font-size: 0.9rem; margin: 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-color); font-weight: 600; }
    .media-meta { font-size: 0.8rem; color: var(--text-secondary); margin-top: 0.25rem; display: flex; gap: 0.5rem; flex-wrap: wrap; }
    
    .media-ratings { display: flex; gap: 0.5rem; margin-top: 0.5rem; flex-wrap: nowrap; }
    .rating-badge { display: inline-flex; align-items: center; gap: 0.2rem; background: rgba(0,0,0,0.05); padding: 0.2rem 0.4rem; border-radius: 12px; font-size: 0.75rem; }
    
    body.dark .rating-badge { background: rgba(255,255,255,0.08); }
    .rating-icon { width: 14px; height: 14px; object-fit: contain; }
    
    .media-progress { margin-top: auto; padding-top: 0.75rem; }
    .progress-bar-container { width: 100%; background-color: var(--progress-bg); border-radius: 4px; height: 6px; overflow: hidden; margin-bottom: 0.25rem; }
    .progress-bar { height: 100%; background-color: var(--progress-fill); border-radius: 4px; transition: width 0.3s ease-out, background-color 0.3s; }
    .progress-bar.ended { background-color: var(--progress-fill-ended); }
    .progress-bar.dropped { background-color: var(--danger); }
    .progress-text { font-size: 0.75rem; color: var(--text-secondary); font-weight: 500; }
    .progress-text .media-year-compact { display: none; }
    
    .card-actions { position: absolute; top: 8px; right: 8px; display: flex; flex-direction: column; gap: 0.5rem; opacity: 0; transform: translateX(10px); transition: opacity 0.2s, transform 0.2s; pointer-events: none; }
    .media-card:hover .card-actions { opacity: 1; transform: translateX(0); pointer-events: all; }
    .card-btn { width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.6); color: white; border: none; cursor: pointer; font-size: 0.8rem; transition: background 0.2s; }
    .card-btn:hover { background: rgba(0,0,0,0.8); }

    .favorite-btn { position: absolute; top: 8px; left: 8px; width: 30px; height: 30px; background: rgba(0,0,0,0.6); color: white; border: none; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; opacity: 0; }
    .media-card:hover .favorite-btn { opacity: 1; }
    .favorite-btn.is-favorite { color: #e74c3c; background: rgba(255,255,255,0.8); opacity: 1; }
    #detailsModalFavoriteBtn { background: transparent; color: var(--text-secondary); border: 1px solid var(--border-color); }
    #detailsModalFavoriteBtn.is-favorite { background: #e74c3c; color: white; border-color: #e74c3c;}


    .media-section { background: var(--section-tint); border-radius: 12px; padding: 1.5rem; margin-bottom: 1.5rem; }
    .media-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 1.5rem; margin-top: 1rem; }
    .section-header { display: flex; justify-content: space-between; align-items: center; margin: 0 0 1rem 0; padding-bottom: 0.75rem; border-bottom: 1px solid var(--border-color); position: relative; }
    .section-header::after { content: ''; position: absolute; bottom: -1px; left: 0; width: 100px; height: 2px; background: linear-gradient(90deg, var(--primary), var(--secondary)); }
    .section-title { color: var(--text-color); margin: 0; font-size: 1.25rem; letter-spacing: -0.5px; font-weight: 700; }
    
    .btn { padding: 0.5rem 1rem; border-radius: 8px; border: none; font-weight: 600; cursor: pointer; transition: all 0.2s; display: inline-flex; align-items: center; justify-content: center; gap: 0.5rem; box-sizing: border-box; height: 38px; }
    .btn:active { transform: translateY(1px); }
    .btn-primary { background: var(--primary); color: white; }
    .btn-secondary { background: var(--secondary); color: white; }
    .btn-success { background: var(--success); color: white; }
    .btn-warning { background: var(--warning); color: #1a1a1a; }
    .btn-danger { background: var(--danger); color: white; }
    .btn-small { padding: 0.25rem 0.75rem; height: auto; font-size: 0.8rem; }

    .modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); display: none; justify-content: center; align-items: center; z-index: 1000; backdrop-filter: blur(5px); }
    .modal-open { overflow: hidden; }
    .modal-content { background: var(--card-bg); border-radius: 12px; padding: 1.5rem; width: 90%; box-shadow: 0 10px 25px rgba(0,0,0,0.2); display: flex; flex-direction: column; }
    
    #mediaManagementModal .modal-content { max-width: 800px; }
    #detailsModal .modal-content { max-width: 900px; padding: 0; }
    #episodesModal { z-index: 1001; }
    #episodesModal .modal-content { max-width: 1200px; height: 90vh; padding: 0; }
    #episodesModalContent { flex: 1; min-height: 0; overflow-y: auto; }
    #episodesModal h2 { margin: 1.5rem; }
    #actorModal { z-index: 1002; }
    #actorModal .modal-content { max-width: 700px; max-height: 80vh; overflow-y: auto; }
    #rewatchModal { z-index: 1003; }
    #rewatchModal .modal-content { max-width: 450px; text-align: center; }
    #updateProgressModal .modal-content { max-width: 500px; text-align: center; }
    #updateSummaryModal .modal-content { max-width: 500px; }
    #updateSummaryList { list-style: none; padding: 0; max-height: 40vh; overflow-y: auto; }
    #updateSummaryList li { padding: 0.5rem; border-bottom: 1px solid var(--border-color); }
    #updateSummaryList li:last-child { border-bottom: none; }


    input, select { padding: 0.5rem 0.75rem; border: 1px solid var(--border-color); border-radius: 8px; background: var(--bg-color); color: var(--text-color); font-size: 1rem; box-sizing: border-box; margin: 0; height: 38px; transition: border-color 0.2s, box-shadow 0.2s; }
    input:focus, select:focus { outline: none; border-color: var(--primary); box-shadow: 0 0 0 2px rgba(42, 157, 143, 0.2); }
    .tmdb-results-container { max-height: 250px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 8px; padding: 0.5rem; margin-top: 1rem; }
    .tmdb-result-item { display: flex; align-items: center; padding: 0.5rem; cursor: pointer; border-radius: 4px; margin-bottom: 0.25rem; }
    .tmdb-result-item:hover { background: rgba(0,0,0,0.05); }
    .tmdb-poster-small { width: 40px; height: 60px; object-fit: cover; margin-right: 0.75rem; border-radius: 4px; }

    .empty-state { text-align: center; padding: 3rem 1rem; color: var(--text-secondary); border: 2px dashed var(--border-color); border-radius: 8px; margin-top: 1rem; }
    .empty-state > i { font-size: 2.5rem; margin-bottom: 1rem; }
    
    .notification { position: fixed; bottom: 20px; right: 20px; padding: 1rem 1.5rem; border-radius: 8px; background: var(--card-bg); box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1002; display: none; }
    .notification.success { border-left: 4px solid var(--success); } .notification.error { border-left: 4px solid var(--danger); } .notification.warning { border-left: 4px solid var(--warning); }
    .modal-footer { display: flex; justify-content: center; gap: 0.5rem; margin-top: 1.5rem; padding: 1.5rem 1.5rem 0 1.5rem; border-top: 1px solid var(--border-color); }
    
    .details-backdrop { width: 100%; height: 250px; background-size: cover; background-position: center 25%; position: relative; }
    .details-backdrop::after { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(to top, var(--card-bg) 0%, rgba(0,0,0,0.5) 100%); }
    .details-header { position: relative; display: flex; padding: 1.5rem; margin-top: -100px; z-index: 2; }
    #detailsModalPoster { width: 150px; height: 225px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); flex-shrink: 0; margin-right: 1.5rem; }
    .details-title-section { padding-top: 100px; display: flex; flex-direction: column; flex-grow: 1; }
    #detailsModalTitle { margin: 0; font-size: 1.75rem; }
    .details-ratings-container { display: flex; flex-wrap: wrap; gap: 0.75rem; margin-top: 0.75rem; }
    #detailsModalHeader-main { display: flex; justify-content: space-between; align-items: flex-start; gap: 1rem; }
    #detailsModalMeta { margin-top: 0.5rem; display: flex; flex-wrap: wrap; gap: 1rem; font-size: 0.9rem; color: var(--text-secondary); }
    .details-body { padding: 0 1.5rem 1.5rem 1.5rem; }
    .details-section-title { font-weight: 600; border-bottom: 1px solid var(--border-color); padding-bottom: 0.5rem; margin-bottom: 1rem; margin-top: 1.5rem; }
    #detailsModalOverview { line-height: 1.6; }
    .modal-close-btn { position: absolute; top: 1rem; right: 1rem; z-index: 3; cursor: pointer; background: rgba(0,0,0,0.5); color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; border: none; }
    
    .cast-scroller { display: flex; overflow-x: auto; gap: 1rem; padding-bottom: 1rem; }
    .actor-card { text-align: center; width: 100px; flex-shrink: 0; cursor: pointer; }
    .actor-photo { width: 80px; height: 80px; border-radius: 50%; object-fit: cover; margin-bottom: 0.5rem; background-color: var(--border-color); }
    .actor-name, .actor-character { font-size: 0.8rem; user-select: text; }
    .actor-character { color: var(--text-secondary); }

    .seasons-container { display: flex; flex-direction: column; }
    .season-header { background-color: var(--section-tint); padding: 1rem; cursor: pointer; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--border-color); position: sticky; top: 0; z-index: 10; backdrop-filter: blur(10px); }
    .season-header:hover { background-color: rgba(42, 157, 143, 0.15); }
    .season-title-container { flex-grow: 1; display: flex; align-items: center; gap: 10px; }
    .season-title { font-weight: 700; font-size: 1.1rem; }
    
    /* New Badge for Season Rewatch */
    .season-rewatch-badge { color: var(--warning); font-size: 0.9rem; display: flex; align-items: center; gap: 4px; }
    
    .season-progress-text { font-size: 0.8rem; color: var(--text-secondary); }
    .season-actions { display: flex; align-items: center; gap: 0.5rem; }
    .season-actions .btn { width: 32px; height: 32px; padding: 0; font-size: 0.9rem; }
    
    .season-episodes { display: block; overflow: hidden; transition: max-height 0.4s ease-in-out; max-height: 0; }
    .no-episodes-info { padding: 1rem; text-align: center; font-style: italic; color: var(--text-secondary); }

    /* --- NETFLIX STYLE EPISODE LIST (UPDATED) --- */
    .episode-item { 
        display: flex; 
        gap: 1rem; 
        padding: 1rem; 
        border-bottom: 1px solid var(--border-color); 
        align-items: flex-start;
        cursor: pointer;
        transition: background 0.2s;
        position: relative;
    }
    .episode-item:hover { background: rgba(255,255,255,0.05); }
    .episode-item:last-child { border-bottom: none; }
    
    .episode-still-wrapper {
        position: relative;
        width: 160px;
        min-width: 160px;
        aspect-ratio: 16/9;
        border-radius: 6px;
        overflow: hidden;
        background-color: var(--border-color);
        flex-shrink: 0;
    }
    .episode-still { 
        width: 100%; 
        height: 100%; 
        object-fit: cover; 
        transition: filter 0.2s; 
        display: block;
    }
    
    /* Overlay Checkmark */
    .episode-status-overlay {
        position: absolute;
        top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        opacity: 0;
        transition: opacity 0.2s;
    }
    .episode-status-overlay i {
        color: var(--primary);
        font-size: 2rem;
    }
    .episode-item.watched .episode-status-overlay { opacity: 1; }
    .episode-item.watched .episode-title { color: var(--primary); }
    
    /* Blur effect for spoilers logic */
    .episode-item .episode-overview, .episode-item .episode-still { transition: filter 0.3s; }
    .episode-title.spoiler { filter: blur(5px); user-select: none; cursor: default; }
    .episode-title.spoiler:hover { filter: blur(0); transition: filter 0.3s; }
    
    /* Blur overview if not watched */
    .episode-item:not(.watched) .episode-overview, 
    .episode-item:not(.watched) .episode-still { filter: blur(4px); }
    .episode-item:not(.watched):hover .episode-overview, 
    .episode-item:not(.watched):hover .episode-still { filter: blur(0); }
    
    .episode-details { flex-grow: 1; min-width: 0; display: flex; flex-direction: column; gap: 0.3rem; }
    
    .episode-meta-row { display: flex; justify-content: space-between; align-items: center; }
    .episode-number { font-weight: 700; font-size: 0.85rem; color: var(--text-secondary); }
    
    /* New Meta Right Container (Rewatch + Date) */
    .episode-meta-right { display: flex; align-items: center; gap: 8px; }
    
    /* Styling for Badges */
    .episode-meta-badge {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 0.7rem;
        font-weight: 500;
        border: 1px solid var(--border-color);
        background: rgba(128,128,128,0.1);
        color: var(--text-secondary);
        white-space: nowrap;
    }
    
    /* Rewatch Specifics */
    .episode-rewatch-badge {
        cursor: pointer;
        border-color: var(--warning);
        background: rgba(244, 162, 97, 0.1);
    }
    .episode-rewatch-badge .count { font-weight: 700; color: var(--warning); }
    .episode-rewatch-badge i { color: var(--warning); }
    .episode-rewatch-badge:hover { background: rgba(244, 162, 97, 0.2); }

    /* Runtime Specifics */
    .episode-runtime-badge i { font-size: 0.65rem; }
    
    .episode-air-date {
        font-size: 0.75rem;
        color: var(--text-secondary);
        background: transparent; /* Clean background */
        padding: 1px 6px;
        border-radius: 4px;
        white-space: nowrap;
        border: 1px solid var(--warning); /* Thin Orange Border */
        font-weight: 500;
    }
    
    .episode-title { font-weight: 700; font-size: 1.1rem; line-height: 1.2; transition: color 0.2s; display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    .episode-overview { font-size: 0.85rem; color: var(--text-secondary); line-height: 1.4; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden; transition: filter 0.2s; }
    
    /* Hidden inputs needed for logic */
    .episode-item input[type="checkbox"] { display: none; } 
    
    
    #rewatchModal .modal-footer { margin-top: 1.5rem; }
    #rewatchModal .custom-rewatch-container { margin-top: 1.5rem; justify-content: center; display: flex; align-items: center; }
    #rewatchQuickButtons { display: flex; gap: 0.5rem; justify-content: center; margin-top: 1rem; }
    .quick-rewatch-btn { padding: 0; width: 45px; height: 45px; justify-content: center; }
    .quick-rewatch-btn.active { background: var(--primary); color: white; }
    .number-input-wrapper { position: relative; display: flex; align-items: center; border: 1px solid var(--border-color); border-radius: 8px; overflow: hidden; height: 38px; }
    .number-input-wrapper input { border: none; text-align: center; flex: 1; width: 100%; padding-right: 25px; background: var(--card-bg); -moz-appearance: textfield; }
    .number-input-wrapper input::-webkit-outer-spin-button, .number-input-wrapper input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    .number-input-controls { position: absolute; right: 1px; top: 1px; bottom: 1px; display: flex; flex-direction: column; width: 24px; }
    .num-spinner-btn { flex: 1; width: 100%; border: none; background-color: var(--bg-color); color: var(--text-color); cursor: pointer; font-size: 0.8rem; line-height: 1; padding: 0; height: 50%; }
    .num-spinner-btn:hover { background-color: var(--primary); color: white; }
    .num-spinner-btn.up { border-top-right-radius: 7px; }
    .num-spinner-btn.down { border-bottom-right-radius: 7px; }

    .management-tabs { display: flex; border-bottom: 1px solid var(--border-color); margin-bottom: 1.5rem; }
    .tab-btn { padding: 0.75rem 1.5rem; background: transparent; border: none; cursor: pointer; font-weight: 600; color: var(--text-secondary); border-bottom: 2px solid transparent; transition: all 0.2s; display: flex; align-items: center; gap: 0.5rem; }
    .tab-btn.active { color: var(--primary); border-bottom-color: var(--primary); }
    .tab-content { display: none; } .tab-content.active { display: block; }
    .management-form { display: flex; gap: 0.5rem; margin-bottom: 1rem; }
    .management-form input { flex: 1; }
    .management-list { max-height: 300px; overflow-y: auto; }
    .management-card { display: flex; align-items: center; padding: 0.75rem; border-radius: 8px; background: var(--bg-color); margin-bottom: 0.5rem; }
    .management-card > div:first-child { flex: 1; display: flex; align-items: center; }
    .management-card-actions { display: flex; gap: 0.5rem; }
    .management-card-actions .btn { padding: 0; justify-content: center; height: 32px; width: 32px; }
    #categoriesList .management-card-actions .btn { background: var(--secondary); color: white; border: none; }
    #categoriesList .management-card-actions .btn.btn-danger { background: var(--danger); }
    #categoriesList .management-card-actions .btn:hover { opacity: 0.85; }
    .category-name, .friend-email { font-weight: 600; }
    .friend-id { font-size: 0.8rem; color: var(--text-secondary); }
    .category-dot { width: 12px; height: 12px; border-radius: 50%; margin-right: 0.75rem; flex-shrink: 0; }
    .category-dot-0 { background: #2a9d8f; } .category-dot-1 { background: #e76f51; } .category-dot-2 { background: #f4a261; } 
    .category-dot-3 { background: #e9c46a; } .category-dot-4 { background: #8338ec; } .category-dot-5 { background: #3a86ff; }
    
    #friendsList .management-card-actions .btn { background: var(--card-bg); border: 1px solid var(--border-color); color: var(--text-color); }
    #friendsList .management-card-actions .btn.visit-friend-films-btn:hover { background-color: var(--film-accent); color: white; border-color: var(--film-accent); }
    #friendsList .management-card-actions .btn.visit-friend-tv-btn:hover { background-color: var(--primary); color: white; border-color: var(--primary); }
    #friendsList .management-card-actions .btn.remove-friend-btn:hover { background-color: var(--danger); color: white; border-color: var(--danger); }

    .context-menu { position: fixed; background: var(--card-bg); border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1001; min-width: 240px; padding: 0.5rem 0; border: 1px solid var(--border-color); opacity: 0; transform: translateY(-10px); transition: opacity 0.15s, transform 0.15s; }
    .context-menu.visible { opacity: 1; transform: translateY(0); }
    .context-menu-item { padding: 0.75rem 1rem; cursor: pointer; display: flex; align-items: center; gap: 0.75rem; font-size: 0.9rem; }
    .context-menu-item i.fa-fw { width: 20px; text-align: center; }
    .context-menu-item:hover { background: var(--primary); color: white; }
    .context-menu-divider { height: 1px; background: var(--border-color); margin: 0.25rem 0; }

    #posterModal .modal-content { max-width: 90vw; max-height: 90vh; display: flex; flex-direction: column; overflow-y: auto; }
    .poster-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 1rem; padding: 0.5rem; }
    .poster-option { position: relative; cursor: pointer; transition: transform 0.2s; border: 3px solid transparent; border-radius: 8px; overflow: hidden; }
    .poster-option:hover { transform: scale(1.05); }
    .poster-option.selected { border-color: var(--primary); }
    .poster-option img { width: 100%; height: auto; display: block; }
    .poster-language-badge { position: absolute; bottom: 5px; right: 5px; background: rgba(0,0,0,0.7); color: white; padding: 0.25rem 0.5rem; border-radius: 12px; font-size: 0.7rem; font-weight: 600; text-transform: uppercase; }

    .auth-container { position: relative; }
    .auth-form { position: absolute; top: calc(100% + 8px); right: 0; background: var(--card-bg); border-radius: 12px; padding: 1.5rem; width: 300px; box-shadow: 0 10px 25px rgba(0,0,0,0.2); z-index: 1001; display: none; }
    .auth-form.active { display: block; }
    .auth-tabs { display: flex; border-bottom: 1px solid var(--border-color); margin-bottom: 1rem; }
    .auth-tab { padding: 0.75rem 1rem; cursor: pointer; font-weight: 600; color: var(--text-secondary); border-bottom: 2px solid transparent; }
    .auth-tab.active { color: var(--primary); border-bottom-color: var(--primary); }
    .auth-form-container { display: none; } .auth-form-container.active { display: block; }
    .auth-form-container input { width: 100%; margin-bottom: 1rem; }
    .auth-form-buttons { display: flex; justify-content: flex-end; margin-top: 1rem; }

    .notification-bell-container { position: relative; }
    .notification-badge { position: absolute; top: -5px; right: -5px; background-color: var(--danger); color: white; border-radius: 50%; width: 18px; height: 18px; font-size: 0.7rem; font-weight: 700; display: flex; justify-content: center; align-items: center; border: 2px solid var(--bg-color); transform: scale(0); transition: transform 0.2s ease-out; }
    .notification-badge.visible { transform: scale(1); }
    .notification-dropdown { position: absolute; top: calc(100% + 8px); right: 0; background: var(--card-bg); border-radius: 12px; width: 350px; box-shadow: 0 10px 25px rgba(0,0,0,0.2); z-index: 1001; display: none; border: 1px solid var(--border-color); overflow: hidden; max-height: 400px; flex-direction: column; }
    .notification-dropdown.visible { display: flex; }
    .notification-header { padding: 0.75rem 1rem; font-weight: 600; border-bottom: 1px solid var(--border-color); flex-shrink: 0; }
    .notification-list { flex: 1; max-height: 300px; overflow-y: auto; }
    .notification-item { padding: 0.75rem 1rem; display: flex; align-items: center; gap: 0.75rem; cursor: pointer; font-size: 0.9rem; }
    .notification-item:hover { background-color: var(--section-tint); }
    .notification-item i.film-notification { color: var(--film-accent); }
    .notification-item i.tv-notification { color: var(--primary); }
    .notification-item-text { flex: 1; }
    .no-notifications { padding: 1.5rem; text-align: center; color: var(--text-secondary); }
    .notification-footer { padding: 0.5rem; text-align: center; border-top: 1px solid var(--border-color); flex-shrink: 0; }

    .view-mode-banner { display: none; align-items: center; background: var(--primary); color: white; padding: 0.75rem 1.5rem; margin-bottom: 1.5rem; border-radius: 8px; }
  
    .actor-details-header { display: flex; gap: 1.5rem; margin-bottom: 1.5rem; align-items: flex-start; }
    .actor-details-photo { width: 120px; height: 180px; object-fit: cover; border-radius: 8px; flex-shrink: 0; }
    .actor-details-info ul { list-style: none; padding: 0; margin: 0; }
    .actor-details-info li { margin-bottom: 0.5rem; }
    .btn-imdb { background: #f5c518; color: #000; margin-top: 1rem; }
    .filmography-scroller { display: flex; overflow-x: auto; gap: 1rem; padding-bottom: 1rem; }
    .film-card-small { width: 120px; flex-shrink: 0; cursor: pointer; }
    .film-card-small img { width: 100%; height: 180px; object-fit: cover; border-radius: 4px; transition: transform 0.2s, box-shadow 0.2s; }
    .film-card-small:hover img { transform: scale(1.05); box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
    .film-card-small-title { font-size: 0.8rem; margin-top: 0.5rem; white-space: normal; text-align: center; }
    .form-row { display: flex; gap: 0.75rem; align-items: center; }
    .form-row input[type="text"] { flex-grow: 1; }

    #updateProgressModal .modal-content { max-width: 500px; text-align: center; }
    #updateProgressBar { width: 100%; height: 20px; background-color: var(--border-color); border-radius: 10px; overflow: hidden; margin: 1rem 0; }
    #updateProgressBarFill { width: 0%; height: 100%; background-color: var(--primary); transition: width 0.2s; }
    #updateProgressText { font-size: 0.9rem; color: var(--text-secondary); }

    /* START: Bottom Navigation Bar Styles */
    .bottom-nav {
      display: none; /* Hidden by default, shown in media query */
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 60px;
      background-color: var(--card-bg);
      border-top: 1px solid var(--border-color);
      box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
      z-index: 999;
      justify-content: space-around;
      align-items: center;
    }
    .bottom-nav-btn {
      background: none;
      border: none;
      color: var(--text-secondary);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      flex-grow: 1;
      height: 100%;
      font-size: 0.7rem;
      cursor: pointer;
      transition: color 0.2s;
      position: relative;
    }
    .bottom-nav-btn i {
      font-size: 1.25rem;
      margin-bottom: 0.2rem;
    }
    .bottom-nav-btn.active, .bottom-nav-btn:hover {
      color: var(--primary);
    }
    .bottom-nav-btn.add-btn {
      color: white;
      background-color: var(--primary);
      width: 56px;
      height: 56px;
      border-radius: 50%;
      margin-bottom: 25px;
      box-shadow: 0 4px 12px rgba(42, 157, 143, 0.4);
      flex-grow: 0;
    }
    .bottom-nav-btn.add-btn i {
      font-size: 1.5rem;
      margin: 0;
    }
    .notification-badge-mobile {
        position: absolute;
        top: 2px;
        right: 15px;
        background-color: var(--danger);
        color: white;
        border-radius: 50%;
        width: 16px;
        height: 16px;
        font-size: 0.7rem;
        font-weight: 700;
        display: flex;
        justify-content: center;
        align-items: center;
        border: 2px solid var(--card-bg);
        transform: scale(0);
        transition: transform 0.2s ease-out;
    }
    .notification-badge-mobile.visible {
        transform: scale(1);
    }
    /* END: Bottom Navigation Bar Styles */
    
    /* START: Mobile Menu and Notifications Modals Styles */
    #mobileMenuModal .modal-content, #filterSortModal .modal-content {
      position: absolute;
      bottom: 0;
      width: 100%;
      max-width: none;
      border-radius: 16px 16px 0 0;
      margin: 0;
      box-shadow: 0 -5px 20px rgba(0,0,0,0.15);
      transform: translateY(100%);
      transition: transform 0.3s ease-out;
    }
    #mobileMenuModal, #filterSortModal {
      align-items: flex-end;
      background: rgba(0,0,0,0.4);
    }
    #mobileMenuModal.visible .modal-content, #filterSortModal.visible .modal-content {
        transform: translateY(0);
    }
    .mobile-menu-list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    .mobile-menu-list .btn {
      width: 100%;
      justify-content: flex-start;
      background-color: var(--section-tint);
      color: var(--text-color);
    }
    .mobile-menu-list .btn i {
      width: 24px;
      text-align: center;
      color: var(--primary);
    }
    .update-section {
      margin-top: 1.5rem;
      padding-top: 1rem;
      border-top: 1px solid var(--border-color);
      text-align: center;
      font-size: 0.8rem;
      color: var(--text-secondary);
    }
    .update-section .btn {
      width: 100%;
      margin-top: 0.5rem;
    }

    #mobileNotificationsModal {
      align-items: flex-end; /* Position modal at the bottom */
      background: rgba(0,0,0,0.4);
    }
    #mobileNotificationsModal .modal-content {
      width: 100%;
      max-width: none;
      height: 75vh;
      border-radius: 16px 16px 0 0;
      margin: 0;
      box-shadow: 0 -5px 20px rgba(0,0,0,0.15);
      transform: translateY(100%);
      transition: transform 0.3s ease-out;
    }
    #mobileNotificationsModal.visible .modal-content {
        transform: translateY(0);
    }

    .filter-modal-section { margin-bottom: 1rem; }
    .filter-modal-section label { display: block; margin-bottom: 0.5rem; font-weight: 600; }
    .filter-modal-section select { width: 100%; }
    /* END: Mobile Menu and Notifications Modals Styles */
  </style>
  
  <style>
    @media (max-width: 768px) {
      body {
        padding: 0.5rem;
        padding-bottom: 80px; /* Spazio per la bottom nav */
        -webkit-text-size-adjust: 100%;
      }

      /* --- TOP BAR --- */
      .top-bar { flex-direction: column; gap: 0.75rem; margin-bottom: 1rem; }
      .top-bar-left { 
        flex-direction: row; 
        flex-wrap: wrap; 
        gap: 0.75rem; 
        width: 100%; 
        justify-content: space-between; 
        align-items: center;
      }
      .top-bar-left h1, .top-bar-left #topBarTitle { display: none; }
      .top-bar-right { display: none; }
      .tracker-switch { flex-shrink: 0; }
      #mobileFilterBtn { 
        display: flex; 
        flex-shrink: 0; 
        margin-left: auto;
      }
      .search-box { 
        width: 100%; 
        max-width: none; 
        height: 40px; 
        flex-basis: 100%; 
        order: 3;
      }
      .top-bar-left > .filter-select { display: none; }

      /* --- STATS MOBILE --- */
      .stats-panel { padding: 0.75rem; margin-bottom: 1rem; }
      .stats-container { gap: 0.5rem; justify-items: center; }
      .stat-item { 
        padding: 0.5rem; 
        min-height: 60px;
      }
      .stat-value { font-size: 1.2rem; }
      .stat-label::after { font-size: 1rem; }
      /* For 7 items layout: 3+2+1+1 (bottom row centered) */
      .stat-item:nth-child(6) { grid-column: 2 / 3; } /* Episodi - center */
      .stat-item:nth-child(7) { grid-column: 3 / 4; } /* Ore - right */

      /* --- GRIGLIA SERIE --- */
      .media-section { padding: 0; background: transparent; margin-bottom: 1rem; }
      .section-header { padding: 0 0.5rem 0.5rem 0.5rem; margin-bottom: 0.5rem; }
      .media-grid {
        grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
        gap: 0.75rem;
        padding: 0 0.25rem;
      }
      .media-card { width: auto; box-shadow: 0 2px 6px rgba(0,0,0,0.1); }
      .media-title { font-size: 0.8rem; }
      .media-meta, .media-ratings { display: none; }
      .progress-text { display: none; } 
      .progress-bar-container { height: 3px; margin-top: 4px; }

      /* --- MODALE DETTAGLI SERIE (CENTRATO) --- */
      #detailsModal .modal-content { padding: 0; width: 100%; height: 100vh; border-radius: 0; }
      .details-header { 
        flex-direction: column; 
        align-items: center; 
        margin-top: -90px; 
        padding: 1rem; 
        text-align: center; 
      }
      #detailsModalPoster { width: 130px; height: 195px; margin: 0 0 1rem 0; border: 2px solid rgba(255,255,255,0.2); box-shadow: 0 8px 20px rgba(0,0,0,0.5); }
      .details-title-section { padding: 0; width: 100%; display: flex; flex-direction: column; align-items: center; }
      
      #detailsModalHeader-main { 
          flex-direction: column; 
          width: 100%; 
          gap: 0.5rem; 
          align-items: center;
      }
      
      #detailsModalTitle { 
          font-size: 1.75rem; 
          text-shadow: 0 2px 4px rgba(0,0,0,0.8); 
          text-align: center; 
          width: 100%;
          line-height: 1.2;
      }
      
      .details-ratings-container { 
          justify-content: center; 
          margin-bottom: 1rem; 
          width: 100%;
      }
      
      #detailsModalHeader-main > div:last-child {
          display: flex;
          justify-content: center;
          gap: 1rem;
          width: 100%;
          margin-top: 0.5rem;
      }
      #detailsModalHeader-main > div:last-child .btn {
          flex: 0 1 auto;
          padding: 0.6rem 1.2rem;
      }
      
      #detailsModalMeta { justify-content: center; font-size: 0.8rem; opacity: 0.8; }
      .details-body { padding: 0 1rem 2rem 1rem; }

      /* --- LISTA EPISODI --- */
      #episodesModal .modal-content { height: 100vh; width: 100%; border-radius: 0; padding: 0; display: flex; flex-direction: column; }
      #episodesModalContent { padding: 0; overflow-y: auto; flex: 1; }
      .season-header { position: sticky; top: 0; z-index: 10; border-radius: 0; margin: 0; padding: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }

      .episode-item {
        padding: 0.75rem;
        gap: 0.75rem;
      }
      .episode-still-wrapper {
          width: 130px;
          min-width: 130px;
      }
      .episode-title { font-size: 0.9rem; }
      .episode-overview { -webkit-line-clamp: 2; font-size: 0.8rem; }

      /* --- HIDE CLOSE BUTTONS ON MOBILE (USE BACK GESTURE) --- */
      #detailsModal .modal-close-btn,
      #episodesModal .modal-close-btn,
      #actorModal .modal-close-btn,
      #posterModal .modal-close-btn { display: none; }


      /* --- NOTIFICHE --- */
      #mobileNotificationsModal { justify-content: flex-end; background: rgba(0,0,0,0.6); }
      #mobileNotificationsModal .modal-content { width: 95%; margin: 0 auto 85px auto; border-radius: 16px; height: auto; max-height: 60vh; box-shadow: 0 4px 20px rgba(0,0,0,0.3); }
      .notification-list { max-height: 40vh; }
      .notification-item { padding: 1rem; border-bottom: 1px solid var(--border-color); }
      
      /* --- BOTTOM NAV --- */
      .bottom-nav { display: flex; height: 60px; background: var(--card-bg); border-top: 1px solid var(--border-color); }
      .bottom-nav-btn.add-btn { 
        transform: translateY(-15px); 
        border: 4px solid var(--bg-color); 
        width: 56px; 
        height: 56px; 
        margin-bottom: 25px;
        border-radius: 50%;
        box-shadow: 0 4px 12px rgba(42, 157, 143, 0.4);
      }
    }
  </style>
  <!-- END: Mobile-Friendly CSS Rules -->
</head>
<body class="dark user-select-none">
  
  <div id="appLoader"><i class="fas fa-spinner loading-spinner"></i></div>

  <div id="viewModeBanner" class="view-mode-banner">
    <i class="fas fa-eye" style="margin-right: 0.75rem;"></i>
    <span id="viewModeUserEmail">Stai visualizzando una libreria condivisa</span>
    <button id="closeViewBtn" class="btn btn-danger" style="margin-left:auto"><i class="fas fa-times"></i> Esci</button>
  </div>

  <div class="top-bar">
    <div class="top-bar-left">
      <h1 id="topBarTitle"><i class="fas fa-tv"></i> Serie TV</h1>
      <div class="tracker-switch">
        <a href="index.html" class="tracker-switch-btn" title="Vai a Film Tracker"><i class="fas fa-film"></i></a>
        <a href="serietv_tracker.html" class="tracker-switch-btn active" title="Vai a Serie TV Tracker"><i class="fas fa-tv"></i></a>
      </div>
      <input type="text" id="searchInput" class="search-box" placeholder="Cerca...">
      <button id="mobileFilterBtn" class="btn btn-secondary"><i class="fas fa-filter"></i></button>
      <select id="categoryFilter" class="filter-select">
          <option value="all">Tutte le categorie</option>
          <option value="favorites">Solo Preferiti</option>
      </select>
      <select id="sortFilter" class="filter-select">
        <option value="added" selected>Ultime attivit√†</option>
        <option value="alpha">Alfabetico</option>
        <option value="rating">Valutazione</option>
        <option value="year">Anno di uscita</option>
      </select>
    </div>
    <div class="top-bar-right">
        <button id="mediaManagementBtn" class="btn btn-primary" title="Gestione"><i class="fas fa-plus"></i></button>
        <div class="notification-bell-container" id="notificationBellContainer" style="display: none;">
            <button id="bellIcon" class="btn btn-secondary" title="Notifiche"><i class="fas fa-bell"></i></button>
            <div id="notificationBadge" class="notification-badge">0</div>
            <div id="notificationDropdown" class="notification-dropdown"></div>
        </div>
        <button id="shareBtn" class="btn btn-secondary" title="Condividi Libreria"><i class="fas fa-share-alt"></i></button>
        <button id="exportBtn" class="btn btn-secondary" title="Esporta Dati"><i class="fas fa-download"></i></button>
        <input type="file" id="importFile" accept=".json" style="display: none;">
        <button id="importBtn" class="btn btn-secondary" title="Importa Dati"><i class="fas fa-upload"></i></button>
        <button id="resetBtn" class="btn btn-secondary" title="Resetta Tracker"><i class="fas fa-undo"></i></button>
        <button id="themeToggle" class="btn btn-secondary" title="Cambia Tema"><i class="fas fa-moon"></i></button>
        
        <div id="userInfo" style="display:none;"><button id="logoutBtn" class="btn btn-danger" title="Logout"><i class="fas fa-sign-out-alt"></i></button></div>
        <div class="auth-container">
            <button id="authToggle" class="btn btn-secondary" title="Login"><i class="fas fa-user"></i></button>
            <div id="authForms" class="auth-form">
              <div class="auth-tabs"><div class="auth-tab active" data-tab="login">Login</div><div class="auth-tab" data-tab="register">Registrati</div></div>
              <div id="loginForm" class="auth-form-container active"><input type="email" id="loginEmail" placeholder="Email"><input type="password" id="loginPassword" placeholder="Password"><div class="auth-form-buttons"><button id="loginBtn" class="btn btn-primary"><i class="fas fa-sign-in-alt"></i> Login</button></div></div>
              <div id="registerForm" class="auth-form-container"><input type="email" id="registerEmail" placeholder="Email"><input type="password" id="registerPassword" placeholder="Password (min. 6 caratteri)"><input type="password" id="registerConfirmPassword" placeholder="Conferma Password"><div class="auth-form-buttons"><button id="registerBtn" class="btn btn-primary"><i class="fas fa-user-plus"></i> Registrati</button></div></div>
            </div>
        </div>
    </div>
  </div>

  <!-- STATS PANEL (ICONS) -->
  <div class="stats-panel">
      <div class="stats-container">
        <div class="stat-item"><div class="stat-value" id="statTotal">0</div><div class="stat-label">Totale</div></div>
        <div class="stat-item"><div class="stat-value" id="statInCorso">0</div><div class="stat-label">In Corso</div></div>
        <div class="stat-item"><div class="stat-value" id="statCompletate">0</div><div class="stat-label">Completate</div></div>
        <div class="stat-item"><div class="stat-value" id="statDaVedere">0</div><div class="stat-label">Da Vedere</div></div>
        <div class="stat-item"><div class="stat-value" id="statInPausaDroppata">0</div><div class="stat-label">In Pausa / Droppata</div></div>
        <div class="stat-item"><div class="stat-value" id="statEpisodes">0</div><div class="stat-label">Episodi Visti</div></div>
        <div class="stat-item"><div class="stat-value" id="statHours">0h 0m</div><div class="stat-label">Tempo Visto</div></div>
      </div>
  </div>

  <div id="mediaSectionsContainer"></div>
  
  <div class="modal" id="mediaManagementModal">
    <div class="modal-content">
        <div class="management-tabs">
          <button class="tab-btn active" data-tab="add-media"><i class="fas fa-plus"></i> Aggiungi Serie</button>
          <button class="tab-btn" data-tab="manage-categories"><i class="fas fa-list-ol"></i> Gestisci Categorie</button>
          <button class="tab-btn" data-tab="manage-friends"><i class="fas fa-user-friends"></i> Amici</button>
        </div>
        <div class="tab-content active" id="add-media-tab">
            <h2>Aggiungi una nuova Serie TV</h2>
            <div class="add-media-form">
                <div class="form-row">
                    <input type="text" id="mediaTitle" placeholder="Titolo serie TV...">
                    <select id="addMediaCategorySelect"></select>
                    <button id="searchTMDbBtn" class="btn btn-secondary"><i class="fas fa-search"></i> Cerca</button>
                </div>
                <div id="tmdbResults" class="tmdb-results-container"></div>
            </div>
        </div>
        <div class="tab-content" id="manage-categories-tab">
            <h2>Gestisci Categorie</h2>
            <div class="management-form">
                <input type="text" id="newCategoryName" placeholder="Nuova categoria">
                <button id="addCategoryBtn" class="btn btn-primary"><i class="fas fa-plus"></i> Aggiungi</button>
            </div>
            <div class="management-list" id="categoriesList"></div>
        </div>
         <div class="tab-content" id="manage-friends-tab">
            <div id="myIdContainer" class="management-section" style="padding: 1rem; border: 1px solid var(--border-color); border-radius: 8px; text-align: center; margin-bottom: 1.5rem;">
                <h4>Il tuo ID univoco</h4>
                <p style="font-size: 0.9rem; color: var(--text-secondary);">Condividi questo ID con i tuoi amici per permettergli di seguirti.</p>
                <div style="display: flex; gap: 0.5rem; justify-content: center;">
                    <input type="text" id="myIdInput" readonly style="text-align: center; background-color: var(--bg-color);">
                    <button id="copyMyIdBtn" class="btn btn-primary"><i class="fas fa-copy"></i> Copia</button>
                </div>
            </div>
            <div class="management-section">
                <div class="management-form">
                    <input type="text" id="friendIdInput" placeholder="Incolla l'ID di un amico">
                    <button id="addFriendBtn" class="btn btn-primary"><i class="fas fa-user-plus"></i> Aggiungi</button>
                </div>
                <div class="management-list" id="friendsList"></div>
            </div>
        </div>
        <div class="update-section" id="updateSectionDesktop" style="display: none;">
          <p id="lastUpdateTimestampDesktop"></p>
          <button id="forceUpdateBtnDesktop" class="btn btn-secondary">Forza Aggiornamento Giornaliero</button>
        </div>
        <div class="modal-footer" style="border-top: none; padding-top: 0; justify-content: flex-end;">
            <button id="closeManagementModal" class="btn btn-danger">Chiudi</button>
            <button id="addShowBtn" class="btn btn-primary"><i class="fas fa-plus"></i> Aggiungi Serie</button>
        </div>
    </div>
  </div>
  
  <div class="modal" id="detailsModal"><div class="modal-content"><button class="modal-close-btn" id="detailsModalClose"><i class="fas fa-times"></i></button><div id="detailsModalContent"></div></div></div>
  <div class="modal" id="episodesModal"><div class="modal-content"><button class="modal-close-btn" id="episodesModalClose"><i class="fas fa-times"></i></button><div id="episodesModalContent"></div></div></div>
  <div class="modal" id="actorModal"><div class="modal-content"><button class="modal-close-btn" id="actorModalClose"><i class="fas fa-times"></i></button><div id="actorModalContent"></div></div></div>
  <div class="modal" id="posterModal"><div class="modal-content"><h2 id="posterModalTitle">Cambia Copertina</h2><div class="poster-grid" id="posterGrid"></div><div class="modal-footer" style="padding: 1.5rem 0 0 0;"><button id="cancelPosterChange" class="btn btn-danger">Annulla</button><button id="savePosterChange" class="btn btn-primary">Salva Selezione</button></div></div></div>
  <div class="modal" id="confirmModal"><div class="modal-content" style="max-width: 400px;"><h2 id="confirmModalTitle"></h2><p id="confirmModalBody"></p><div id="confirmModalButtons" style="display:flex; justify-content:flex-end; gap:0.5rem; margin-top:1rem;"><button id="confirmModalCancel" class="btn btn-secondary">Annulla</button><button id="confirmModalConfirm" class="btn btn-danger">Conferma</button></div></div></div>
  <div class="modal" id="shareModal"><div class="modal-content" style="max-width: 450px;"><h2>Condividi la tua libreria</h2><p>Chiunque abbia questo link potr√† vedere la tua lista in tempo reale (sola lettura).</p><input type="text" id="shareLinkInput" readonly style="width:100%"><div style="display: flex; gap: 0.5rem; margin-top: 1rem;"><button id="copyShareLinkBtn" class="btn btn-primary">Copia Link</button><button id="closeShareModalBtn" class="btn btn-danger">Chiudi</button></div></div></div>
  
  <div class="modal" id="rewatchModal">
    <div class="modal-content">
        <h2 id="rewatchModalTitle">Modifica Rewatch</h2>
        <p>Specifica il numero di volte che hai rivisto (0 = visto una sola volta).</p>
        <div id="rewatchQuickButtons">
            <button class="btn btn-secondary quick-rewatch-btn" data-count="0">0</button>
            <button class="btn btn-secondary quick-rewatch-btn" data-count="1">1</button>
            <button class="btn btn-secondary quick-rewatch-btn" data-count="2">2</button>
            <button class="btn btn-secondary quick-rewatch-btn" data-count="3">3</button>
            <button class="btn btn-secondary quick-rewatch-btn" data-count="4">4</button>
            <button class="btn btn-secondary quick-rewatch-btn" data-count="5">5</button>
        </div>
        <div class="custom-rewatch-container">
            <label for="rewatchCountInput">Numero custom:</label>
            <div class="number-input-wrapper" style="width: 120px;">
                <input type="number" id="rewatchCountInput" min="0" value="0">
                <div class="number-input-controls">
                    <button class="num-spinner-btn up" data-target="rewatchCountInput">+</button>
                    <button class="num-spinner-btn down" data-target="rewatchCountInput">-</button>
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button id="cancelRewatchBtn" class="btn btn-danger">Annulla</button>
            <button id="confirmRewatchBtn" class="btn btn-primary">Salva</button>
        </div>
    </div>
  </div>
  
  <div class="modal" id="updateProgressModal">
    <div class="modal-content">
        <h2 id="updateProgressTitle">Aggiornamento in corso...</h2>
        <div id="updateProgressBar">
            <div id="updateProgressBarFill"></div>
        </div>
        <p id="updateProgressText">Inizializzazione...</p>
    </div>
  </div>

  <!-- Mobile "More Options" Modal -->
  <div class="modal" id="mobileMenuModal">
      <div class="modal-content">
          <h2 style="text-align: center; margin-top: 0;">Altre Opzioni</h2>
          <div class="mobile-menu-list">
              <button class="btn" id="mobileMenuUserActionBtn"><i class="fas fa-user"></i><span>Login / Registrati</span></button>
              <button class="btn" id="mobileMenuShareBtn"><i class="fas fa-share-alt"></i>Condividi Libreria</button>
              <button class="btn" id="mobileMenuExportBtn"><i class="fas fa-download"></i>Esporta Dati</button>
              <button class="btn" id="mobileMenuImportBtn"><i class="fas fa-upload"></i>Importa Dati</button>
              <button class="btn" id="mobileMenuThemeBtn"><i class="fas fa-moon"></i>Cambia Tema</button>
              <button class="btn" id="mobileMenuResetBtn" style="color: var(--danger);"><i class="fas fa-undo" style="color: var(--danger);"></i>Resetta Tracker</button>
          </div>
          <div class="update-section">
            <p id="lastUpdateTimestampMobile"></p>
            <button id="forceUpdateBtnMobile" class="btn btn-secondary">Forza Aggiornamento Giornaliero</button>
          </div>
          <div class="modal-footer" style="border: none; padding-bottom: 0;">
            <button id="mobileMenuCloseBtn" class="btn btn-danger">Chiudi</button>
          </div>
      </div>
  </div>

  <!-- Mobile Notifications Modal -->
  <div class="modal" id="mobileNotificationsModal">
      <div class="modal-content">
          <div class="notification-header" style="text-align:center; position:relative;">
              Notifiche Amici
              <button class="modal-close-btn" id="mobileNotificationsCloseBtn" style="background:none; color:var(--text-color); top:0.5rem; right:0.5rem;"><i class="fas fa-times"></i></button>
          </div>
          <div class="notification-list" id="notificationListMobile"></div>
          <div class="notification-footer">
              <button id="markAllReadMobileBtn" class="btn btn-primary btn-small"><i class="fas fa-check-double"></i> Segna tutte come lette</button>
          </div>
      </div>
  </div>
  
  <!-- Mobile Filter & Sort Modal -->
  <div class="modal" id="filterSortModal">
    <div class="modal-content">
        <h2 style="text-align: center; margin-top: 0;">Filtra e Ordina</h2>
        <div class="filter-modal-section">
            <label for="mobileCategoryFilter">Categoria</label>
            <select id="mobileCategoryFilter"></select>
        </div>
        <div class="filter-modal-section">
            <label for="mobileSortFilter">Ordina per</label>
            <select id="mobileSortFilter">
                <option value="added" selected>Ultime attivit√†</option>
                <option value="alpha">Alfabetico</option>
                <option value="rating">Valutazione</option>
                <option value="year">Anno di uscita</option>
            </select>
        </div>
        <div class="modal-footer" style="border: none; padding-bottom: 0;">
            <button id="applyFiltersBtn" class="btn btn-primary">Applica</button>
        </div>
    </div>
  </div>

  <!-- Update Summary Modal -->
  <div class="modal" id="updateSummaryModal">
    <div class="modal-content">
        <h2 style="text-align:center; margin-top: 0;">Riepilogo Aggiornamenti</h2>
        <ul id="updateSummaryList"></ul>
        <div class="modal-footer" style="padding-top: 1rem; border: none;">
          <button id="closeSummaryBtn" class="btn btn-primary">OK</button>
        </div>
    </div>
  </div>

  <div id="notification" class="notification"><span id="notificationText"></span></div>
  
  <!-- Bottom Navigation Bar for Mobile -->
  <div class="bottom-nav" id="bottomNav">
      <button class="bottom-nav-btn active" id="bottomNavHome" title="Liste">
          <i class="fas fa-list-ul"></i>
          <span>Liste</span>
      </button>
      <button class="bottom-nav-btn" id="bottomNavSearch" title="Cerca">
          <i class="fas fa-search"></i>
          <span>Cerca</span>
      </button>
      <button class="bottom-nav-btn add-btn" id="bottomNavAdd" title="Aggiungi Serie">
          <i class="fas fa-plus"></i>
      </button>
      <button class="bottom-nav-btn" id="bottomNavNotifications" title="Notifiche">
          <i class="fas fa-bell"></i>
          <span class="notification-badge-mobile" id="notificationBadgeMobile">0</span>
          <span>Notifiche</span>
      </button>
      <button class="bottom-nav-btn" id="bottomNavManage" title="Altro">
          <i class="fas fa-ellipsis-h"></i>
          <span>Altro</span>
      </button>
  </div>

  <script>
    const OMDb_API_KEY = "2526ef70";
    const TMDB_KEY = atob("MmNkOGJiNDgzYWIxMjE0ZDY2MDIwZTcwYjBhMzZmYTQ=");
    const MDBLIST_PROXY_URL = "https://serietvtracker.amrit-singh99mail-5e3.workers.dev"; 
    
    const DEFAULT_POSTER = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMDAiIGhlaWdodD0iNDUwIiB2aWV3Qm94PSIwIDAgMzAwIDQ1MCI+PHJlY3Qgd2lkdGg9IjMwMCIgaGVpZ2h0PSI0NTAiIGZpbGw9IiNkZGQiLz48dGV4dCB4PSIxNTAiIHk9IjIyNSIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjE2IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSIjNjY2Ij5OZXNzYSBpbWFnaW5lPC90ZXh0Pjwvc3ZnPg==";
    const DEFAULT_ACTOR_PHOTO = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI4MCIgaGVpZ2h0PSI4MCIgdmlld0JveD0iMCAwIDgwIDgwIj48cmVjdCB3aWR0aD0iODAiIGhlaWdodD0iODAiIGZpbGw9IiNkZGQiLz48cGF0aCBkPSJtNDAgMzZhNC44IDQuOCAwIDEgMCAwLTkuNiA0LggNC44IDAgMCAwIDAgOS42em0wIDEuNmMtNC40MiAwLTgtMy41OC04LThzMy41OC04IDgtOCA4IDMuNTggOCA4LTMuNTggOC04IDh6bS0xMy4zMyAxNC44N2ExMi4wMiAxMi4wMiAwIDAgMCAyNi42NiAwYy0uNDctMi4wMi0yLjY4LTMuNTgtNS4zMy00LjA3LTEuMy0uMjUtMi42Ny0uNS00LS43My0xLjMzLS4yMy0yLjctLjMzLTQtLjMzcy0yLjY3LjEtNCwuMzNjLTEuMzMuMjItMi43LjQ4LTQgLjczLTIuNjUuNS00Ljg2IDIuMDYtNS4zMyA0LjA3eiIgZmlsbD0iIzY2NiIvPjwvc3ZnPg==";
    const EMPTY_STILL_PLACEHOLDER = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMDAiIGhlaWdodD0iMTY5IiB2aWV3Qm94PSIwIDAgMzAwIDE2OSI+PHJlY3Qgd2lkdGg9IjMwMCIgaGVpZ2h0PSIxNjkiIGZpbGw9IiNkZGQiLz48L3N2Zz4=";
    const IMDB_STAR_ICON = "https://upload.wikimedia.org/wikipedia/commons/2/29/Gold_Star.svg";
    const ROTTEN_TOMATOES_ICONS = { certified: "https://upload.wikimedia.org/wikipedia/uk/b/b2/Certified_Fresh_2018.svg", fresh: "https://upload.wikimedia.org/wikipedia/commons/5/5b/Rotten_Tomatoes.svg", rotten: "https://upload.wikimedia.org/wikipedia/commons/5/52/Rotten_Tomatoes_rotten.svg" };
    const POPCORN_ICONS = { positive: "https://upload.wikimedia.org/wikipedia/commons/d/da/Rotten_Tomatoes_positive_audience.svg", negative: "https://upload.wikimedia.org/wikipedia/commons/6/63/Rotten_Tomatoes_negative_audience.svg" };
    const LETTERBOXD_ICON = "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTH45TgrphrMnMTlMx9wpG_Jj7JoBzrI9zAfg&s";
    const METACRITIC_ICON = "https://upload.wikimedia.org/wikipedia/commons/f/f2/Metacritic_M.png";
    const firebaseConfig = { apiKey: "AIzaSyDm946nISfZs8ugkuYPraNTzFhvgQmnMUk", authDomain: "gametrackerdb.firebaseapp.com", databaseURL: "https://gametrackerdb-default-rtdb.europe-west1.firebasedatabase.app", projectId: "gametrackerdb" };
    const MAX_LOG_SIZE = 15;
    const MAX_NOTIFICATIONS = 50;
    
    const DEFAULT_CATEGORIES = ["In Corso", "Completate", "Da Vedere", "In Pausa / Droppata"];
    let mediaList = [], categories = [], currentTMDbSelection = null, debounceTimeout, lazyLoadObserver, currentShowCache = null;
    let currentUser = null, isViewMode = false, followedFriends = [], friendListeners = {};
    let lastCheckedTimestamps = {};
    let statContributorIds = new Set();
    let ignoredDuplicateIds = new Set();
    let currentRewatchContext = {};
    let isUpdateInProgress = false; // Il nostro "semaforo" per gli aggiornamenti
    
    const getDefaultShowProps = () => ({
        category: 'Da Vedere', addedAt: new Date().toISOString(), lastActivityAt: null, poster: "", 
        year: "", imdbID: null, tmdbID: null, imdbRating: "N/A", rottenTomatoes: "N/A", popcornRating: "N/A", metacriticRating: "N/A", letterboxdRating: "N/A", status: "Unknown", 
        seasons: {}, progress: {}, rewatches: {}, isFavorite: false, italianTitle: null,
        includeSpecialsInProgress: false // Nuova propriet√† per la logica degli speciali
    });
    
    const elements = { 
        appLoader: document.getElementById("appLoader"), mediaManagementBtn: document.getElementById("mediaManagementBtn"), 
        exportBtn: document.getElementById("exportBtn"), importBtn: document.getElementById("importBtn"), importFile: document.getElementById("importFile"), 
        resetBtn: document.getElementById("resetBtn"), themeToggle: document.getElementById("themeToggle"), searchInput: document.getElementById("searchInput"), 
        categoryFilter: document.getElementById("categoryFilter"), sortFilter: document.getElementById("sortFilter"), 
        statTotal: document.getElementById("statTotal"), statFollowing: document.getElementById("statInCorso"),
        statCompleted: document.getElementById("statCompletate"), statToWatch: document.getElementById("statDaVedere"), 
        statPaused: document.getElementById("statInPausaDroppata"),
        statEpisodes: document.getElementById("statEpisodes"), statHours: document.getElementById("statHours"),
        mediaSectionsContainer: document.getElementById("mediaSectionsContainer"), mediaManagementModal: document.getElementById("mediaManagementModal"), 
        mediaTitle: document.getElementById("mediaTitle"), searchTMDbBtn: document.getElementById("searchTMDbBtn"), tmdbResults: document.getElementById("tmdbResults"), 
        addShowBtn: document.getElementById("addShowBtn"), closeManagementModal: document.getElementById("closeManagementModal"), notification: document.getElementById("notification"), notificationText: document.getElementById("notificationText"),
        detailsModal: document.getElementById('detailsModal'), detailsModalContent: document.getElementById('detailsModalContent'), detailsModalClose: document.getElementById('detailsModalClose'),
        episodesModal: document.getElementById('episodesModal'), episodesModalContent: document.getElementById('episodesModalContent'), episodesModalClose: document.getElementById('episodesModalClose'),
        actorModal: document.getElementById('actorModal'), actorModalContent: document.getElementById('actorModalContent'), actorModalClose: document.getElementById('actorModalClose'),
        posterModal: document.getElementById('posterModal'), posterGrid: document.getElementById('posterGrid'), savePosterChange: document.getElementById('savePosterChange'),
        cancelPosterChange: document.getElementById('cancelPosterChange'), confirmModal: document.getElementById("confirmModal"), confirmModalTitle: document.getElementById("confirmModalTitle"),
        confirmModalBody: document.getElementById("confirmModalBody"), confirmModalConfirm: document.getElementById("confirmModalConfirm"), confirmModalCancel: document.getElementById("confirmModalCancel"),
        categoriesList: document.getElementById("categoriesList"),
        newCategoryName: document.getElementById("newCategoryName"), addCategoryBtn: document.getElementById("addCategoryBtn"),
        addMediaCategorySelect: document.getElementById("addMediaCategorySelect"),
        authToggle: document.getElementById('authToggle'), authForms: document.getElementById('authForms'),
        loginBtn: document.getElementById('loginBtn'), registerBtn: document.getElementById('registerBtn'),
        logoutBtn: document.getElementById('logoutBtn'), userInfo: document.getElementById('userInfo'),
        shareBtn: document.getElementById('shareBtn'), shareModal: document.getElementById('shareModal'),
        copyShareLinkBtn: document.getElementById('copyShareLinkBtn'), closeShareModalBtn: document.getElementById('closeShareModalBtn'),
        viewModeBanner: document.getElementById('viewModeBanner'), viewModeUserEmail: document.getElementById('viewModeUserEmail'), closeViewBtn: document.getElementById('closeViewBtn'),
        addFriendBtn: document.getElementById('addFriendBtn'), friendsList: document.getElementById('friendsList'), friendIdInput: document.getElementById('friendIdInput'),
        myIdInput: document.getElementById('myIdInput'), copyMyIdBtn: document.getElementById('copyMyIdBtn'),
        notificationBellContainer: document.getElementById('notificationBellContainer'), bellIcon: document.getElementById('bellIcon'),
        notificationDropdown: document.getElementById('notificationDropdown'),
        notificationBadge: document.getElementById('notificationBadge'),
        rewatchModal: document.getElementById("rewatchModal"), rewatchModalTitle: document.getElementById("rewatchModalTitle"),
        rewatchCountInput: document.getElementById("rewatchCountInput"), confirmRewatchBtn: document.getElementById("confirmRewatchBtn"),
        cancelRewatchBtn: document.getElementById("cancelRewatchBtn"),
        updateProgressModal: document.getElementById('updateProgressModal'),
        updateProgressBarFill: document.getElementById('updateProgressBarFill'),
        updateProgressText: document.getElementById('updateProgressText'),
        updateProgressTitle: document.getElementById('updateProgressTitle'),
        updateSummaryModal: document.getElementById('updateSummaryModal'),
        updateSummaryList: document.getElementById('updateSummaryList'),
        closeSummaryBtn: document.getElementById('closeSummaryBtn'),
        // Bottom Nav Bar Elements
        bottomNavAdd: document.getElementById('bottomNavAdd'),
        bottomNavManage: document.getElementById('bottomNavManage'),
        bottomNavSearch: document.getElementById('bottomNavSearch'),
        bottomNavNotifications: document.getElementById('bottomNavNotifications'),
        bottomNavHome: document.getElementById('bottomNavHome'),
        notificationBadgeMobile: document.getElementById('notificationBadgeMobile'),
        // Mobile Modals and Buttons
        mobileMenuModal: document.getElementById('mobileMenuModal'),
        mobileMenuCloseBtn: document.getElementById('mobileMenuCloseBtn'),
        mobileMenuUserActionBtn: document.getElementById('mobileMenuUserActionBtn'),
        mobileMenuShareBtn: document.getElementById('mobileMenuShareBtn'),
        mobileMenuExportBtn: document.getElementById('mobileMenuExportBtn'),
        mobileMenuImportBtn: document.getElementById('mobileMenuImportBtn'),
        mobileMenuThemeBtn: document.getElementById('mobileMenuThemeBtn'),
        mobileMenuResetBtn: document.getElementById('mobileMenuResetBtn'),
        mobileNotificationsModal: document.getElementById('mobileNotificationsModal'),
        mobileNotificationsCloseBtn: document.getElementById('mobileNotificationsCloseBtn'),
        notificationListMobile: document.getElementById('notificationListMobile'),
        markAllReadMobileBtn: document.getElementById('markAllReadMobileBtn'),
        // Filter Modal
        filterSortModal: document.getElementById('filterSortModal'),
        mobileFilterBtn: document.getElementById('mobileFilterBtn'),
        mobileCategoryFilter: document.getElementById('mobileCategoryFilter'),
        mobileSortFilter: document.getElementById('mobileSortFilter'),
        applyFiltersBtn: document.getElementById('applyFiltersBtn'),
        // Update Section
        forceUpdateBtnDesktop: document.getElementById('forceUpdateBtnDesktop'),
        forceUpdateBtnMobile: document.getElementById('forceUpdateBtnMobile'),
        lastUpdateTimestampDesktop: document.getElementById('lastUpdateTimestampDesktop'),
        lastUpdateTimestampMobile: document.getElementById('lastUpdateTimestampMobile'),
        updateSectionDesktop: document.getElementById('updateSectionDesktop')
    };
    
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();
    
    document.addEventListener("DOMContentLoaded", init);

    function init() { 
        setupEventListeners(); 
        loadTheme(); 
        loadSortOrder(); 
        updateSwitcherLinksInViewMode();
        handleViewMode() || setupAuthListeners(); 
    }
    
    function updateSwitcherLinksInViewMode() {
        const params = new URLSearchParams(window.location.search);
        const viewId = params.get('view');
        if (viewId) {
            const filmTrackerLink = document.querySelector('.tracker-switch-btn[href="index.html"]');
            const tvTrackerLink = document.querySelector('.tracker-switch-btn[href="serietv_tracker.html"]');
            if (filmTrackerLink) filmTrackerLink.href = `index.html?view=${viewId}`;
            if (tvTrackerLink) tvTrackerLink.href = `serietv_tracker.html?view=${viewId}`;
        }
    }

    function hideLoader() { elements.appLoader.style.opacity = '0'; setTimeout(() => elements.appLoader.style.display = 'none', 300); }
    
    function loadData() {
        if (!currentUser) return;
        const path = `users/${currentUser.uid}`;
        db.ref(`${path}/tvShowTracker`).on("value", snapshot => {
            const data = snapshot.val() || {};
            mediaList = (data.mediaList || []).map(item => {
                const cleanItem = { ...getDefaultShowProps(), ...item };
                if (typeof cleanItem.seasons !== 'object' || cleanItem.seasons === null) {
                    cleanItem.seasons = {}; // Bonifica dati vecchi
                }
                return cleanItem;
            });
            categories = (data.categories || DEFAULT_CATEGORIES.map(name => ({ name, hideProgress: false }))).map(cat => (typeof cat === 'string') ? { name: cat, hideProgress: false } : cat);
            if (!isViewMode) {
                renderFullUI();
                triggerNewEpisodeCheck();
                updateAllShowsInBackground();
            }
        });
        db.ref(`${path}/social`).once("value", snapshot => {
            const data = snapshot.val() || {};
            followedFriends = data.followedFriends || [];
            lastCheckedTimestamps = data.lastCheckedTimestamps || {};
            if (!isViewMode) {
                setupFriendListeners();
                renderFriendsList();
            }
        });
        hideLoader();
    }

    function loadLocalData() { 
        try { 
            const localList = JSON.parse(localStorage.getItem("tvShowList") || "[]");
            mediaList = localList.map(item => {
                const cleanItem = { ...getDefaultShowProps(), ...item };
                if (typeof cleanItem.seasons !== 'object' || cleanItem.seasons === null) {
                    cleanItem.seasons = {}; // Bonifica dati vecchi
                }
                return cleanItem;
            });
            const storedCategories = JSON.parse(localStorage.getItem("tvShowCategories") || JSON.stringify(DEFAULT_CATEGORIES.map(name => ({ name, hideProgress: false }))));
            categories = storedCategories.map(cat => (typeof cat === 'string') ? { name: cat, hideProgress: false } : cat);
            renderFullUI(); 
            updateAllShowsInBackground();
        } catch (err) { 
            mediaList = []; 
            categories = DEFAULT_CATEGORIES.map(name => ({ name, hideProgress: false })); 
            renderFullUI(); 
        } 
    }
    
    async function saveData() { 
        if (isViewMode) return;
        if (currentUser) {
            return db.ref(`users/${currentUser.uid}/tvShowTracker`).set({ mediaList, categories });
        } else {
            try { 
                localStorage.setItem("tvShowList", JSON.stringify(mediaList)); 
                localStorage.setItem("tvShowCategories", JSON.stringify(categories)); 
            } catch (err) { 
                showNotification("Errore nel salvataggio dei dati", "error"); 
            } 
            return Promise.resolve();
        }
    }
    
    function saveSocialData() {
        if (isViewMode || !currentUser) return;
        return db.ref(`users/${currentUser.uid}/social`).set({ followedFriends, lastCheckedTimestamps });
    }

    function renderFullUI() { 
        renderCategorySections(); 
        updateCategoryFilter(); 
        updateStats();
        renderMedia(); 
        displayLastUpdateTime();
    }

    function calculateProgress(show) {
        const watchedEpisodes = Object.keys(show.progress || {}).length;
        
        // Se la modalit√† speciale √® attiva, calcola il totale includendo TUTTI gli speciali
        if (show.includeSpecialsInProgress) {
            return {
                watchedEpisodes,
                totalEpisodes: Object.values(show.seasons || {}).reduce((sum, season) => sum + (season.episodes || []).length, 0)
            };
        }
        
        // Altrimenti, calcola il totale standard (solo stagioni > 0)
        const totalEpisodes = Object.entries(show.seasons || {})
            .filter(([seasonNum]) => parseInt(seasonNum) > 0)
            .reduce((sum, [, season]) => sum + (season.episodes || []).length, 0);

        return { watchedEpisodes, totalEpisodes };
    }


    function getRottenTomatoesState(score) { if (!score || score === "N/A") return null; const value = parseInt(String(score).replace('%', '')); return isNaN(value) ? null : value >= 75 ? "certified" : value >= 60 ? "fresh" : "rotten"; }
    function getPopcornState(score) { if (!score || score === "N/A") return null; const value = parseInt(String(score).replace('%', '')); return isNaN(value) ? null : value >= 60 ? "positive" : "negative"; }

    function sanitizeForId(text) {
        return text.replace(/[^a-zA-Z0-9]/g, '');
    }

    function updateStats() {
        statContributorIds.clear();
        ignoredDuplicateIds.clear();
        const processed = new Set();
        mediaList.forEach(media => {
            const uniqueId = (media.imdbID || media.tmdbID) || media.title.toLowerCase().trim();
            if (!uniqueId || processed.has(uniqueId)) return;
            processed.add(uniqueId);
            const instances = mediaList.filter(m => ((m.imdbID && m.imdbID === media.imdbID) || (m.tmdbID && m.tmdbID === media.tmdbID)) || (!m.imdbID && !m.tmdbID && m.title.toLowerCase() === media.title.toLowerCase()));
            let contributor = instances.find(m => DEFAULT_CATEGORIES.includes(m.category)) || instances[0];
            if (contributor) {
                statContributorIds.add(contributor.id);
                instances.forEach(inst => {
                    if (inst.id !== contributor.id) ignoredDuplicateIds.add(inst.id);
                });
            }
        });

        const stats = { InCorso: 0, Completate: 0, DaVedere: 0, InPausaDroppata: 0, episodesWatched: 0, minutesWatched: 0 };
        statContributorIds.forEach(id => {
            const show = mediaList.find(m => m.id === id);
            if (!show) return;

            const categoryKey = sanitizeForId(show.category);
            if (stats.hasOwnProperty(categoryKey)) {
                stats[categoryKey]++;
            }
            
            // Usiamo il conteggio degli episodi visti per le statistiche generali
            const watchedEpisodes = Object.keys(show.progress || {}).length;
            stats.episodesWatched += watchedEpisodes;

            if (show.seasons) {
                Object.keys(show.progress).forEach(progressKey => {
                    const [seasonNum, episodeNum] = progressKey.split('-').map(Number);
                    const season = show.seasons[seasonNum];
                    if (season && season.episodes) {
                        const episode = season.episodes.find(e => e.episode_number == episodeNum);
                        if (episode && episode.runtime) {
                            const rewatches = show.rewatches?.[progressKey] || 0;
                            stats.minutesWatched += episode.runtime * (1 + rewatches);
                        }
                    }
                });
            }
        });
        
        elements.statTotal.textContent = statContributorIds.size;
        elements.statFollowing.textContent = stats.InCorso || 0;
        elements.statCompleted.textContent = stats.Completate || 0;
        elements.statToWatch.textContent = stats.DaVedere || 0;
        elements.statPaused.textContent = stats.InPausaDroppata || 0;
        elements.statEpisodes.textContent = stats.episodesWatched;
        
        const hours = Math.floor(stats.minutesWatched / 60);
        const minutes = stats.minutesWatched % 60;
        elements.statHours.textContent = `${hours}h ${minutes}m`;
    }

    function renderMedia() {
        const selectedCategory = elements.categoryFilter.value;
        const searchTerm = elements.searchInput.value.toLowerCase();
        const sortBy = elements.sortFilter.value;

        document.querySelectorAll(".media-section").forEach(s => s.style.display = 'block');
        document.querySelectorAll(".media-grid").forEach(g => g.innerHTML = '');

        let filteredMedia = [...mediaList];

        if (searchTerm) {
            filteredMedia = filteredMedia.filter(m => 
                m.title.toLowerCase().includes(searchTerm) ||
                (m.italianTitle && m.italianTitle.toLowerCase().includes(searchTerm))
            );
        }
        
        if (selectedCategory === 'favorites') {
            filteredMedia = filteredMedia.filter(m => m.isFavorite);
        } else if (selectedCategory !== 'all') {
            filteredMedia = filteredMedia.filter(m => m.category === selectedCategory);
        }

        filteredMedia.sort((a, b) => {
            switch (sortBy) {
                case "alpha": return a.title.localeCompare(b.title);
                case "rating": return (parseFloat(b.imdbRating) || 0) - (parseFloat(a.imdbRating) || 0);
                case "year": return (b.year.split('‚Äì')[0] || 0) - (a.year.split('‚Äì')[0] || 0);
                case "added":
                default:
                    return new Date(b.lastActivityAt || b.addedAt) - new Date(a.lastActivityAt || a.addedAt);
            }
        });

        filteredMedia.forEach(media => {
            const gridId = sanitizeForId(media.category) + "Grid";
            const grid = document.getElementById(gridId);
            if (grid) {
                grid.appendChild(createMediaCard(media));
            }
        });
        
        let hasContent = false;
        categories.forEach(catObj => {
            const categoryName = catObj.name;
            const section = document.querySelector(`.media-section[data-category="${categoryName}"]`);
            if (!section) return;

            const grid = section.querySelector('.media-grid');
            const countEl = section.querySelector('.category-count');
            
            const count = grid.children.length;
            if(countEl) countEl.textContent = count;

            if (selectedCategory !== 'all' && selectedCategory !== 'favorites' && categoryName !== selectedCategory) {
                section.style.display = 'none';
            } else if (count === 0 && selectedCategory === 'favorites') {
                 section.style.display = 'none';
            } else {
                section.style.display = 'block';
                hasContent = true;
                 if (grid.children.length === 0) {
                    grid.innerHTML = `<div class="empty-state"><i class="fas fa-tv"></i><p>Nessuna serie TV qui.</p></div>`;
                }
            }
        });
        
        if (selectedCategory === 'favorites' && !filteredMedia.length){
            renderCategorySections(); 
            elements.mediaSectionsContainer.innerHTML = `<div class="media-section"><div class="empty-state"><i class="fas fa-heart-crack"></i><p>Nessun preferito aggiunto.</p></div></div>`;
        } else if (selectedCategory === 'favorites' && filteredMedia.length > 0) {
             document.querySelectorAll('.media-section').forEach(s => {
                 if(s.querySelector('.media-grid').children.length === 0) s.style.display = 'none';
             })
        }

        setupLazyLoading();
    }


    function createMediaCard(show) {
      const card = document.createElement("div");
      card.className = "media-card";
      card.dataset.id = show.id;
      if (statContributorIds.has(show.id)) card.classList.add("is-stat-contributor");
      if (ignoredDuplicateIds.has(show.id)) card.classList.add("is-duplicate");

      card.addEventListener('click', (e) => {
          if (e.target.closest('.favorite-btn') || e.target.closest('.card-actions')) return;
          showDetailsModal(show.id)
      });
      card.addEventListener('contextmenu', e => { e.preventDefault(); showContextMenu(show, {x: e.clientX, y: e.clientY}); });
      const { watchedEpisodes, totalEpisodes } = calculateProgress(show);
      const percentage = totalEpisodes > 0 ? (watchedEpisodes / totalEpisodes) * 100 : 0;
      
      const rtState = getRottenTomatoesState(show.rottenTomatoes);
      const popcornState = getPopcornState(show.popcornRating);
      
      let progressBarClass = "progress-bar";
      if (show.status === "Ended" || show.status === "Canceled") {
          progressBarClass += " ended";
      }
      if (show.category === 'In Pausa / Droppata') {
          progressBarClass += " dropped";
      }
      
      let ratingsHTML = '';
      if (show.imdbRating && show.imdbRating !== "N/A") { ratingsHTML += `<span class="rating-badge"><img src="${IMDB_STAR_ICON}" class="rating-icon">&nbsp;${show.imdbRating}</span>`; }
      if (rtState) { ratingsHTML += `<span class="rating-badge"><img src="${ROTTEN_TOMATOES_ICONS[rtState]}" class="rating-icon">&nbsp;${show.rottenTomatoes}</span>`; }
      if (popcornState) { ratingsHTML += `<span class="rating-badge"><img src="${POPCORN_ICONS[popcornState]}" class="rating-icon">&nbsp;${show.popcornRating}</span>`; }
      
      const actionsHTML = isViewMode ? '' : `
        <div class="card-actions">
            <button class="card-btn" data-action="move" title="Sposta in..."><i class="fas fa-folder-open"></i></button>
            <button class="card-btn" data-action="delete" title="Elimina"><i class="fas fa-trash"></i></button>
        </div>`;
      
      const categoryObject = categories.find(c => c.name === show.category);
      const progressHTML = (categoryObject && categoryObject.hideProgress) ? '' : `
        <div class="media-progress">
          <div class="progress-bar-container"><div class="${progressBarClass}" style="width: ${percentage}%;"></div></div>
          <div class="progress-text">
            <span>${watchedEpisodes}/${totalEpisodes}</span>
            <span class="media-year-compact">${show.year}</span>
          </div>
        </div>`;

      card.innerHTML = `
        <div class="poster-container">
            <img data-src="${show.poster || DEFAULT_POSTER}" class="media-poster lazy" onerror="this.src='${DEFAULT_POSTER}'">
            <button class="favorite-btn ${show.isFavorite ? 'is-favorite' : ''}" title="Aggiungi ai preferiti"><i class="fas fa-heart"></i></button>
            ${actionsHTML}
        </div>
        <div class="media-info">
          <h3 class="media-title" title="${show.title}">${show.title}</h3>
          <div class="media-meta">
            <span>${show.year}</span>
          </div>
          <div class="media-ratings">${ratingsHTML}</div>
          ${progressHTML}
        </div>`;
      
      card.querySelector('.favorite-btn').addEventListener('click', (e) => { e.stopPropagation(); toggleFavorite(show.id); });
      if(!isViewMode) {
          card.querySelector('[data-action="move"]').addEventListener("click", e => { e.stopPropagation(); showContextMenu(show, { x: e.clientX, y: e.clientY }); });
          card.querySelector('[data-action="delete"]').addEventListener("click", e => { e.stopPropagation(); deleteShow(show.id); });
      }
      return card;
    }

    function refreshSingleMedia(id) { 
        const show = mediaList.find(m => m.id === id);
        if (!show) return;
        const oldCard = document.querySelector(`.media-card[data-id="${id}"]`);
        if (oldCard) {
            const oldCategory = oldCard.closest('.media-section').dataset.category;
            if (oldCategory !== show.category) {
                renderMedia();
            } else {
                const newCard = createMediaCard(show);
                oldCard.parentElement.replaceChild(newCard, oldCard);
                if (lazyLoadObserver) lazyLoadObserver.observe(newCard.querySelector(".lazy"));
            }
        } else {
            renderMedia();
        }
        updateStats();
    }
    
    async function addNewMedia(tmdbId) {
        showNotification("Recupero dettagli della serie...", "warning");
        try {
            const [enDetails, itDetails] = await Promise.all([
                fetchFullTMDbDetails(tmdbId, 'en-US'),
                fetchFullTMDbDetails(tmdbId, 'it-IT')
            ]);
            
            if (!enDetails) {
                return showNotification("Dettagli della serie non trovati su TMDb.", "error");
            }
            
            const imdbID = enDetails.external_ids.imdb_id || null;
            const category = elements.addMediaCategorySelect.value;
            localStorage.setItem("lastUsedTvShowCategory", category);

            const isDuplicateInDefaultCategory = mediaList.some(m => 
                ((imdbID && m.imdbID === imdbID) || m.tmdbID === tmdbId) && DEFAULT_CATEGORIES.includes(m.category)
            );
            if (DEFAULT_CATEGORIES.includes(category) && isDuplicateInDefaultCategory) {
                 return showNotification("Questa serie √® gi√† in una categoria principale.", "warning");
            }

            const isDuplicateInSameCategory = mediaList.some(m => 
                ((imdbID && m.imdbID === imdbID) || m.tmdbID === tmdbId) && m.category === category
            );
            if (isDuplicateInSameCategory) {
                return showNotification(`Questa serie √® gi√† in "${category}"`, "warning");
            }

            let newShow = { 
                ...getDefaultShowProps(), 
                id: Date.now().toString(), 
                title: enDetails.name,
                italianTitle: itDetails ? itDetails.name : enDetails.name,
                imdbID: imdbID,
                tmdbID: tmdbId,
                category: category,
                poster: enDetails.poster_path ? `https://image.tmdb.org/t/p/w500${enDetails.poster_path}` : DEFAULT_POSTER,
                addedAt: new Date().toISOString(), 
                lastActivityAt: new Date().toISOString() 
            };
            
            const existingShow = mediaList.find(m => (imdbID && m.imdbID === imdbID) || (m.tmdbID === tmdbId));
            if (existingShow) {
                newShow.progress = JSON.parse(JSON.stringify(existingShow.progress));
                newShow.rewatches = JSON.parse(JSON.stringify(existingShow.rewatches || {}));
            }

            let omdbDetails = null;
            let mdbListRatings = null;
            if (newShow.imdbID) {
                [omdbDetails, mdbListRatings] = await Promise.all([
                    getOMDbShowDetails(newShow.imdbID),
                    fetchMDBListRatings(newShow.imdbID)
                ]);
            }

            const firstYear = enDetails.first_air_date ? enDetails.first_air_date.split('-')[0] : '';
            const status = enDetails.status;
            const lastYear = (status === 'Ended' || status === 'Canceled') && enDetails.last_air_date ? enDetails.last_air_date.split('-')[0] : '';

            if (firstYear && lastYear && firstYear !== lastYear) {
                newShow.year = `${firstYear}‚Äì${lastYear}`;
            } else if (firstYear && (status === 'Returning Series' || status === 'In Production' || status === 'Planned')) {
                newShow.year = `${firstYear} ‚Äì In corso`;
            } else {
                newShow.year = firstYear;
            }
            
            newShow.status = status;
            newShow.imdbRating = (omdbDetails?.imdbRating && omdbDetails.imdbRating !== "N/A") ? omdbDetails.imdbRating : (enDetails.vote_average ? enDetails.vote_average.toFixed(1) : "N/A");
            
            // Per le nuove serie, scarica solo le stagioni regolari per evitare di aggiungere speciali non richiesti
            const seasonPromises = enDetails.seasons
                .filter(s => s.season_number > 0)
                .map(s => fetchTMDbSeasonDetailsWithFallback(enDetails.id, s.season_number));
            
            const seasonsData = await Promise.all(seasonPromises);
            seasonsData.forEach(season => { 
                if (season) {
                    newShow.seasons[season.season_number] = { 
                        name: season.name,
                        episodes: (season.episodes || []).map(ep => ({
                            name: ep.name,
                            overview: ep.overview,
                            episode_number: ep.episode_number,
                            runtime: ep.runtime || 0,
                            still_path: ep.still_path,
                            air_date: ep.air_date
                        }))
                    };
                }
            });

            if (category === "Completate" && !existingShow) {
                Object.keys(newShow.seasons).forEach(seasonNum => {
                    (newShow.seasons[seasonNum].episodes || []).forEach(ep => {
                        newShow.progress[`${seasonNum}-${ep.episode_number}`] = true;
                    });
                });
            }
            
            if (mdbListRatings) {
                const rtRating = mdbListRatings.find(r => r.source === 'tomatoes');
                const popcornRating = mdbListRatings.find(r => r.source === 'tomatoesaudience');
                const letterboxdRating = mdbListRatings.find(r => r.source === 'letterboxd');
                const metacriticRating = mdbListRatings.find(r => r.source === 'metacritic');

                if (rtRating) newShow.rottenTomatoes = rtRating.value;
                if (popcornRating) newShow.popcornRating = popcornRating.value;
                if (letterboxdRating) newShow.letterboxdRating = letterboxdRating.value;
                if (metacriticRating) newShow.metacriticRating = metacriticRating.value;

            } else if (omdbDetails && omdbDetails.Ratings) {
                const rt = omdbDetails.Ratings.find(r => r.Source === 'Rotten Tomatoes');
                if (rt) newShow.rottenTomatoes = rt.Value;
            }
            
            mediaList.push(newShow);
            await logActivity('add_show', newShow.title, `alla categoria '${newShow.category}'`);
            await saveData();
            
            renderFullUI();
            showNotification(`"${newShow.title}" aggiunto!`, "success");
            closeModal(elements.mediaManagementModal);
        } catch (error) { 
            console.error("Errore durante l'aggiunta della serie:", error);
            showNotification("Errore nel recuperare i dettagli della serie.", "error");
        }
    }

    async function getOMDbShowDetails(imdbId) { if (!imdbId) return null; const res = await fetch(`https://www.omdbapi.com/?apikey=${OMDb_API_KEY}&i=${imdbId}`); return res.ok ? await res.json() : null; }
    
    async function fetchTMDbDetailsWithFallback(imdbId) {
        let details = await fetchTMDbShowDetailsByIMDb(imdbId, 'it-IT');
        if (details && !details.overview) {
            const en_details = await fetchTMDbShowDetailsByIMDb(imdbId, 'en-US');
            if (en_details) details.overview = en_details.overview;
        }
        return details;
    }

    async function fetchTMDbShowDetailsByIMDb(imdbId, lang = 'it-IT') {
        if (!imdbId) return null; 
        const findRes = await fetch(`https://api.themoviedb.org/3/find/${imdbId}?api_key=${TMDB_KEY}&external_source=imdb_id`); 
        if (!findRes.ok) return null; 
        const findData = await findRes.json();
        const tmdbShow = findData.tv_results[0];
        if (!tmdbShow) return null; 
        return await fetchFullTMDbDetails(tmdbShow.id, lang);
    }
    
    async function fetchFullTMDbDetails(tmdbId, lang = 'en-US') {
        const detailsRes = await fetch(`https://api.themoviedb.org/3/tv/${tmdbId}?api_key=${TMDB_KEY}&language=${lang}&append_to_response=credits,external_ids`); 
        return detailsRes.ok ? await detailsRes.json() : null;
    }
    
    async function fetchTMDbSeasonDetailsWithFallback(tvId, seasonNumber) {
        let season = await fetchTMDbSeasonDetails(tvId, seasonNumber, 'it-IT');
        if (season && (!season.overview || (season.episodes && season.episodes.some(e => !e.name || !e.overview)))) {
            const en_season = await fetchTMDbSeasonDetails(tvId, seasonNumber, 'en-US');
            if(en_season) {
                if(!season.overview) season.overview = en_season.overview;
                if(season.episodes){
                    season.episodes.forEach((ep, index) => {
                        if(!ep.name && en_season.episodes[index]) ep.name = en_season.episodes[index].name;
                        if(!ep.overview && en_season.episodes[index]) ep.overview = en_season.episodes[index].overview;
                    });
                }
            }
        }
        return season;
    }
    async function fetchTMDbSeasonDetails(tvId, seasonNumber, lang = 'it-IT') { 
        const res = await fetch(`https://api.themoviedb.org/3/tv/${tvId}/season/${seasonNumber}?api_key=${TMDB_KEY}&language=${lang}`); 
        return res.ok ? await res.json() : null; 
    }
    
    async function fetchMDBListRatings(imdbId) {
        if (!imdbId || !MDBLIST_PROXY_URL || MDBLIST_PROXY_URL === "INCOLLA_L_URL_DEL_TUO_WORKER_QUI") return null;
        try {
            const res = await fetch(`${MDBLIST_PROXY_URL}?i=${imdbId}`);
            if (!res.ok) return null;
            const data = await res.json();
            return data.ratings || null;
        } catch (error) {
            console.error("Errore nel recupero dati da MDBList:", error);
            return null;
        }
    }

    async function fetchBestTMDbDetails(show) {
        let details = null;
        if (show.tmdbID) {
            details = await fetchFullTMDbDetails(show.tmdbID, 'it-IT');
             if (details && !details.overview) {
                const en_details = await fetchFullTMDbDetails(show.tmdbID, 'en-US');
                if (en_details) details.overview = en_details.overview;
            }
        } else if (show.imdbID) {
            details = await fetchTMDbDetailsWithFallback(show.imdbID);
        }
        return details;
    }
    
    async function forceRefreshShow(showId) {
        await showDetailsModal(showId, true);
    }
    
    async function showDetailsModal(showId, force = false) {
        const show = mediaList.find(m => m.id === showId); 
        if (!show) return;
        
        if(!force){
             elements.detailsModal.style.display = 'flex'; 
             document.body.classList.add('modal-open');
             elements.detailsModalContent.innerHTML = `<div style="text-align: center; padding: 4rem;"><i class="fas fa-spinner fa-3x loading-spinner"></i></div>`;
        }
        
        const tmdbDetails = await fetchBestTMDbDetails(show);
        if (!tmdbDetails) { 
            elements.detailsModalContent.innerHTML = "<p>Dettagli non trovati.</p>"; 
            return [];
        }

        let hasUpdates = false;
        let updateSummary = [];
        
        const firstYear = tmdbDetails.first_air_date ? tmdbDetails.first_air_date.split('-')[0] : '';
        const status = tmdbDetails.status;
        const lastYear = (status === 'Ended' || status === 'Canceled') && tmdbDetails.last_air_date ? tmdbDetails.last_air_date.split('-')[0] : '';
        let newYear = firstYear;
        if (firstYear && lastYear && firstYear !== lastYear) {
            newYear = `${firstYear}‚Äì${lastYear}`;
        } else if (firstYear && (status === 'Returning Series' || status === 'In Production' || status === 'Planned')) {
            newYear = `${firstYear} ‚Äì In corso`;
        }
        if(show.year !== newYear) {
            show.year = newYear;
            hasUpdates = true;
        }
        if(show.status !== status) {
            show.status = status;
            hasUpdates = true;
            updateSummary.push(`<strong>${show.title}</strong>: Stato aggiornato a "${status}"`);
        }

        // CORREZIONE: Filtra le stagioni da aggiornare. Aggiorna solo gli speciali (stagione 0) SE esistono gi√† nei dati locali.
        const seasonDetailPromises = tmdbDetails.seasons
            .filter(s => s.season_number > 0 || (show.seasons && show.seasons[s.season_number]))
            .map(s => fetchTMDbSeasonDetailsWithFallback(tmdbDetails.id, s.season_number));
        
        const allSeasonDetails = await Promise.all(seasonDetailPromises);
        
        allSeasonDetails.forEach(seasonDetails => {
            if (seasonDetails) {
                const seasonNumber = seasonDetails.season_number;
                const localSeason = show.seasons[seasonNumber];
                const newEpisodeCount = (seasonDetails.episodes || []).length;
                const oldEpisodeCount = (localSeason?.episodes || []).length;
                
                if (!localSeason) {
                    updateSummary.push(`<strong>${show.title}</strong>: Aggiunta Stagione ${seasonNumber}`);
                } else if (newEpisodeCount > oldEpisodeCount) {
                    updateSummary.push(`<strong>${show.title}</strong>: ${newEpisodeCount - oldEpisodeCount} nuovi episodi nella Stagione ${seasonNumber}`);
                }

                if (!localSeason || oldEpisodeCount !== newEpisodeCount || force) {
                     show.seasons[seasonNumber] = { 
                        name: seasonDetails.name, 
                        episodes: (seasonDetails.episodes || []).map(ep => ({
                            name: ep.name,
                            overview: ep.overview,
                            episode_number: ep.episode_number,
                            runtime: ep.runtime || 0,
                            still_path: ep.still_path,
                            air_date: ep.air_date
                        }))
                    };
                    hasUpdates = true;
                }
            }
        });

        if (hasUpdates) {
            await saveData();
            renderMedia();
            updateStats();
            if(force) showNotification(`Dati aggiornati per ${show.title}!`, "success");
        }
        
        currentShowCache = { show, tmdbDetails };
        if(elements.detailsModal.style.display === 'flex') {
             populateDetailsModal(tmdbDetails, show);
        }
        
        return updateSummary;
    }
    
    function populateDetailsModal(details, media) {
        const backdropUrl = details.backdrop_path ? `https://image.tmdb.org/t/p/w1280${details.backdrop_path}` : '';
        const posterUrl = media.poster || (details.poster_path ? `https://image.tmdb.org/t/p/w500${details.poster_path}` : DEFAULT_POSTER);
        const genres = details.genres.map(g => g.name).join(', ');

        const rtState = getRottenTomatoesState(media.rottenTomatoes);
        const popcornState = getPopcornState(media.popcornRating);

        let ratingsHTML = '';
        if (media.imdbRating && media.imdbRating !== "N/A") { ratingsHTML += `<span class="rating-badge"><img src="${IMDB_STAR_ICON}" class="rating-icon">&nbsp;${media.imdbRating}</span>`; }
        if (rtState) { ratingsHTML += `<span class="rating-badge"><img src="${ROTTEN_TOMATOES_ICONS[rtState]}" class="rating-icon">&nbsp;${media.rottenTomatoes}</span>`; }
        if (popcornState) { ratingsHTML += `<span class="rating-badge"><img src="${POPCORN_ICONS[popcornState]}" class="rating-icon">&nbsp;${media.popcornRating}</span>`; }
        if (media.metacriticRating && media.metacriticRating !== "N/A") { ratingsHTML += `<span class="rating-badge"><img src="${METACRITIC_ICON}" class="rating-icon">&nbsp;${media.metacriticRating}</span>`; }
        if (media.letterboxdRating && media.letterboxdRating !== "N/A") { ratingsHTML += `<span class="rating-badge"><img src="${LETTERBOXD_ICON}" class="rating-icon">&nbsp;${media.letterboxdRating}</span>`; }

        const castHTML = details.credits.cast.slice(0, 15).map(actor => `
            <div class="actor-card" data-person-id="${actor.id}">
                <img src="${actor.profile_path ? `https://image.tmdb.org/t/p/w200${actor.profile_path}` : DEFAULT_ACTOR_PHOTO}" class="actor-photo" onerror="this.src='${DEFAULT_ACTOR_PHOTO}'">
                <div class="actor-name">${actor.name}</div>
                <div class="actor-character">${actor.character}</div>
            </div>
        `).join('');

        elements.detailsModalContent.innerHTML = `
            <div class="details-backdrop" style="background-image: url(${backdropUrl})"></div>
            <div class="details-header">
                <img id="detailsModalPoster" src="${posterUrl}" onerror="this.src='${DEFAULT_POSTER}'">
                <div class="details-title-section">
                    <div id="detailsModalHeader-main">
                        <div>
                            <h2 id="detailsModalTitle">${media.title}</h2>
                            <div class="details-ratings-container">${ratingsHTML || '<span style="font-size: 0.9rem; color: var(--text-secondary);">Nessuna valutazione disponibile</span>'}</div>
                        </div>
                        <div style="display: flex; gap: 0.5rem; align-self: flex-start; flex-shrink: 0;">
                             <button id="detailsModalFavoriteBtn" class="btn ${media.isFavorite ? 'is-favorite' : ''}" title="Aggiungi ai preferiti"><i class="fas fa-heart"></i></button>
                             <button id="refreshShowBtn" class="btn btn-secondary" title="Aggiorna Dati Serie"><i class="fas fa-sync-alt"></i></button>
                             <button id="showEpisodesBtn" class="btn btn-primary" style="flex-shrink: 0;"><i class="fas fa-list-check"></i> Episodi</button>
                        </div>
                    </div>
                    <div id="detailsModalMeta">
                        <span><i class="fas fa-calendar-alt"></i> ${media.year}</span>
                        <span><i class="fas fa-satellite-dish"></i> ${details.status}</span>
                        ${genres ? `<span><i class="fas fa-film"></i> ${genres}</span>` : ''}
                    </div>
                </div>
            </div>
            <div class="details-body">
                <h3 class="details-section-title">Trama</h3>
                <p id="detailsModalOverview">${details.overview || 'Trama non disponibile.'}</p>
                <h3 class="details-section-title">Cast Principale</h3>
                <div class="cast-scroller" id="detailsModalCast">
                    ${castHTML}
                </div>
            </div>
        `;
        
        elements.detailsModalContent.querySelectorAll('.actor-card').forEach(card => {
            card.addEventListener('click', (e) => {
                e.preventDefault();
                showActorModal(card.dataset.personId);
            });
        });
        
        elements.detailsModalContent.querySelector('#refreshShowBtn').addEventListener('click', () => forceRefreshShow(media.id));
        elements.detailsModalContent.querySelector('#showEpisodesBtn').addEventListener('click', () => showEpisodesModal(media));
        elements.detailsModalContent.querySelector('#detailsModalFavoriteBtn').addEventListener('click', () => toggleFavorite(media.id));
    }

    function showEpisodesModal(show) { 
        currentShowCache = { show };
        populateEpisodesModal(); 
        elements.episodesModal.style.display = 'flex'; 
    }
    
    function populateEpisodesModal() {
        const { show } = currentShowCache;

        const sortedSeasonNumbers = Object.keys(show.seasons || {}).map(Number).sort((a, b) => {
            if (a === 0) return 1;
            if (b === 0) return -1;
            return a - b;
        });
        
        const seasonsHTML = sortedSeasonNumbers.map(seasonNum => {
            const season = show.seasons[seasonNum];
            return createSeasonBlockHTML(show, { ...season, season_number: seasonNum });
        }).join('');
        
        elements.episodesModalContent.innerHTML = `<h2>Progresso episodi: ${show.title}</h2><div class="seasons-container">${seasonsHTML}</div>`;
        
        sortedSeasonNumbers.forEach(setupSeasonEventListeners);

        // --- AUTO SCROLL LOGIC ---
        if (show.category === 'In Corso' && show.seasons) {
             setTimeout(() => {
                 let firstUnwatchedId = null;
                 let targetSeasonNum = null;

                 // Find first unwatched
                 for (const seasonNum of sortedSeasonNumbers) {
                     const season = show.seasons[seasonNum];
                     if (!season.episodes) continue;
                     for (const ep of season.episodes) {
                         if (!show.progress[`${seasonNum}-${ep.episode_number}`]) {
                             firstUnwatchedId = `item-${show.id}-${seasonNum}-${ep.episode_number}`;
                             targetSeasonNum = seasonNum;
                             break;
                         }
                     }
                     if (firstUnwatchedId) break;
                 }

                 if (firstUnwatchedId && targetSeasonNum !== null) {
                     // Expand the season block
                     const episodesContainer = document.getElementById(`season-episodes-${targetSeasonNum}`);
                     if (episodesContainer) {
                         episodesContainer.style.maxHeight = episodesContainer.scrollHeight + 'px';
                     }
                     
                     // Scroll to episode
                     const episodeEl = document.getElementById(firstUnwatchedId);
                     if (episodeEl) {
                         episodeEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                     }
                 }
             }, 300); // Slight delay for DOM rendering
        }
    }

    function formatAirDate(airDateString) {
        if (!airDateString) return '';
        const airDate = new Date(airDateString + 'T00:00:00Z');
        const options = { day: 'numeric', month: 'short', year: '2-digit' };
        return airDate.toLocaleDateString('it-IT', options);
    }


    function createSeasonBlockHTML(show, season) {
        const seasonNumber = season.season_number;
        const episodes = season.episodes || [];
        
        const watchedInSeason = Object.keys(show.progress).filter(key => key.startsWith(`${seasonNumber}-`)).length;
        const episodeCount = episodes.length;
        const isSeasonComplete = watchedInSeason === episodeCount && episodeCount > 0;
        const hasEpisodes = episodeCount > 0;
        
        // Check if WHOLE season is rewatched (all eps have rewatch > 0)
        let isSeasonRewatched = false;
        if (hasEpisodes && show.rewatches) {
             isSeasonRewatched = episodes.every(ep => (show.rewatches[`${seasonNumber}-${ep.episode_number}`] || 0) > 0);
        }

        const markAllButtonHTML = isSeasonComplete 
            ? `<button class="btn btn-warning season-toggle-all-btn" title="Segna tutti come non visti" data-show-id="${show.id}" data-season-number="${seasonNumber}" data-action="unwatch"><i class="fas fa-times"></i></button>`
            : `<button class="btn btn-success season-toggle-all-btn" title="Segna tutti come visti" data-show-id="${show.id}" data-season-number="${seasonNumber}" data-action="watch"><i class="fas fa-check-double"></i></button>`;
        
        const seasonRewatchBtnHTML = `<button class="btn btn-secondary season-rewatch-btn" title="Imposta rewatch per la stagione" data-show-id="${show.id}" data-season-number="${seasonNumber}"><i class="fas fa-sync-alt"></i></button>`;

        let firstUnwatchedFound = false;
        
        const allSeasonEpisodes = hasEpisodes ? episodes.map(ep => {
            const isWatched = show.progress[`${seasonNumber}-${ep.episode_number}`];
            const rewatchCount = show.rewatches?.[`${seasonNumber}-${ep.episode_number}`] || 0;
            let titleSpoilerClass = '';
            
            if (!isWatched) {
                if (!firstUnwatchedFound) {
                    firstUnwatchedFound = true; // This is the NEXT episode to watch, so show title
                } else {
                    titleSpoilerClass = 'spoiler'; // Future episodes are spoilers
                }
            }
            
            return `
            <div class="episode-item ${isWatched ? 'watched' : ''}" id="item-${show.id}-${seasonNumber}-${ep.episode_number}" onclick="toggleEpisodeWatched('${show.id}', '${seasonNumber}', '${ep.episode_number}')">
                <div class="episode-still-wrapper">
                     <img data-src="${ep.still_path ? `https://image.tmdb.org/t/p/w300${ep.still_path}` : EMPTY_STILL_PLACEHOLDER}" class="episode-still lazy" onerror="this.src='${EMPTY_STILL_PLACEHOLDER}'">
                     <div class="episode-status-overlay"><i class="fas fa-check"></i></div>
                </div>
                <div class="episode-details">
                    <div class="episode-meta-row">
                        <span class="episode-number">${seasonNumber > 0 ? `S${seasonNumber}` : 'SP'} E${ep.episode_number}</span>
                        <div class="episode-meta-right">
                             <div class="episode-rewatch-badge" onclick="event.stopPropagation(); openRewatchModal({showId: '${show.id}', seasonNumber: '${seasonNumber}', episodeNumber: '${ep.episode_number}'})">
                                <i class="fas fa-sync-alt"></i> 
                                ${rewatchCount > 0 ? `<span class="count">${rewatchCount}</span>` : ''}
                             </div>
                             ${ep.air_date ? `<span class="episode-air-date">${formatAirDate(ep.air_date)}</span>` : ''}
                        </div>
                    </div>
                    <div class="episode-title ${titleSpoilerClass}">
                        ${ep.name || `Episodio ${ep.episode_number}`}
                        ${ep.runtime ? `<span class="episode-meta-badge episode-runtime-badge"><i class="fas fa-clock"></i> ${ep.runtime}m</span>` : ''}
                    </div>
                    <p class="episode-overview">${ep.overview || 'Nessuna trama disponibile.'}</p>
                </div>
            </div>`;
        }).join('') : '<div class="no-episodes-info">Dettagli episodi non ancora disponibili.</div>';

        return `
        <div class="season-block" id="season-block-${seasonNumber}">
            <div class="season-header" data-season-target="${seasonNumber}">
                <div class="season-title-container">
                    <span class="season-title">${season.name}</span>
                    ${isSeasonRewatched ? '<span class="season-rewatch-badge" title="Stagione rivista"><i class="fas fa-sync-alt"></i></span>' : ''}
                    <div class="season-progress-text" style="margin-left:auto; margin-right:10px;">${watchedInSeason} / ${episodeCount}</div>
                </div>
                <div class="season-actions">${hasEpisodes ? seasonRewatchBtnHTML + markAllButtonHTML : ''}</div>
            </div>
            <div class="season-episodes" id="season-episodes-${seasonNumber}">${allSeasonEpisodes}</div>
        </div>`;
    }
    
    function setupSeasonEventListeners(seasonNumber) {
        const seasonBlock = document.getElementById(`season-block-${seasonNumber}`);
        if (!seasonBlock) return;
        
        setupLazyLoading();
        
        seasonBlock.querySelector('.season-header').addEventListener('click', e => { 
            if (!e.target.closest('.season-actions')) { 
                const target = document.getElementById(`season-episodes-${seasonNumber}`);
                const isExpanded = target.style.maxHeight && target.style.maxHeight !== '0px'; 
                if (isExpanded) {
                    target.style.maxHeight = null;
                } else {
                    target.style.maxHeight = target.scrollHeight + 'px';
                }
            } 
        });
        
        const toggleAllBtn = seasonBlock.querySelector('.season-toggle-all-btn');
        if (toggleAllBtn) {
            toggleAllBtn.addEventListener('click', e => {
                const { showId, seasonNumber, action } = e.currentTarget.dataset;
                toggleSeasonWatched(showId, seasonNumber, action === 'watch');
            });
        }

        const seasonRewatchBtn = seasonBlock.querySelector('.season-rewatch-btn');
        if(seasonRewatchBtn) {
            seasonRewatchBtn.addEventListener('click', (e) => {
                const { showId, seasonNumber } = e.currentTarget.dataset;
                openRewatchModal({ showId, seasonNumber });
            });
        }
    }
    
    async function showActorModal(personId) {
        elements.actorModal.style.display = 'flex';
        document.body.classList.add('modal-open');
        elements.actorModalContent.innerHTML = '<div style="text-align: center; padding: 4rem;"><i class="fas fa-spinner fa-3x loading-spinner"></i></div>';
        const actorDetails = await fetchTMDbActorDetailsWithFallback(personId);
        if(actorDetails) {
            populateActorModal(actorDetails);
        } else {
            elements.actorModalContent.innerHTML = '<p style="text-align: center; padding: 2rem;">Dettagli attore non trovati.</p>';
        }
    }
    
    async function fetchTMDbActorDetailsWithFallback(personId) {
        let details = await fetchTMDbActorDetails(personId, 'it-IT');
        if (details && !details.biography) {
            const en_details = await fetchTMDbActorDetails(personId, 'en-US');
            if (en_details) details.biography = en_details.biography;
        }
        return details;
    }

    async function fetchTMDbActorDetails(personId, lang = 'it-IT') {
        try {
            const [detailsRes, creditsRes] = await Promise.all([
                fetch(`https://api.themoviedb.org/3/person/${personId}?api_key=${TMDB_KEY}&language=${lang}`),
                fetch(`https://api.themoviedb.org/3/person/${personId}/tv_credits?api_key=${TMDB_KEY}&language=${lang}`)
            ]);
            if (!detailsRes.ok || !creditsRes.ok) return null;
            
            const details = await detailsRes.json();
            const credits = await creditsRes.json();
            credits.cast.sort((a,b) => (b.vote_average || 0) - (a.vote_average || 0));

            return { ...details, tv_credits: credits };
        } catch(err) {
            console.error("Error fetching actor details:", err);
            return null;
        }
    }

    function populateActorModal(details) {
        const photoUrl = details.profile_path ? `https://image.tmdb.org/t/p/w500${details.profile_path}` : DEFAULT_ACTOR_PHOTO;
        const filmographyHTML = (details.tv_credits?.cast || []).slice(0, 15).map(show => {
            if (!show.poster_path) return '';
            return `
            <div class="film-card-small" data-imdb-id="${show.id}" title="${show.name}">
                <img src="https://image.tmdb.org/t/p/w200${show.poster_path}" onerror="this.src='${DEFAULT_POSTER}'">
                <div class="film-card-small-title">${show.name}</div>
            </div>`;
        }).join('');
        
        elements.actorModalContent.innerHTML = `
            <div class="actor-details-header">
                <img src="${photoUrl}" class="actor-details-photo" onerror="this.src='${DEFAULT_ACTOR_PHOTO}'">
                <div class="actor-details-info">
                    <h2>${details.name}</h2>
                    <ul>
                        <li><strong>Nascita:</strong> ${details.birthday ? new Date(details.birthday).toLocaleDateString('it-IT') : 'N/A'}</li>
                        <li><strong>Luogo:</strong> ${details.place_of_birth || 'N/A'}</li>
                    </ul>
                    ${details.imdb_id ? `<a href="https://www.imdb.com/name/${details.imdb_id}/" target="_blank" class="btn btn-imdb"><i class="fab fa-imdb"></i> Vedi su IMDb</a>` : ''}
                </div>
            </div>
            <div>
                ${filmographyHTML ? `<h3 class="details-section-title">Filmografia Selezionata (TV)</h3><div class="filmography-scroller">${filmographyHTML}</div>` : ''}
                <h3 class="details-section-title">Biografia</h3>
                <p>${details.biography || 'Biografia non disponibile.'}</p>
            </div>
        `;
    }

    async function toggleSeasonWatched(showId, seasonNumber, watch) {
        const show = mediaList.find(m => m.id === showId);
        if (!show || !show.seasons[seasonNumber] || !show.seasons[seasonNumber].episodes) return;

        const duplicates = mediaList.filter(d => (d.imdbID && d.imdbID === show.imdbID) || (d.tmdbID && d.tmdbID === show.tmdbID));

        duplicates.forEach(dup => {
            dup.seasons[seasonNumber].episodes.forEach(ep => {
                const key = `${seasonNumber}-${ep.episode_number}`;
                if (watch) dup.progress[key] = true;
                else delete dup.progress[key];
            });
            updateShowCategoryAndTimestamps(dup, true);
        });

        if (watch) await logActivity('complete_season', show.title, `la stagione ${seasonNumber}`);
        
        await saveData();
        updateStats();
        duplicates.forEach(dup => refreshSingleMedia(dup.id));
        currentShowCache.show = show;
        
        const seasonBlock = document.getElementById(`season-block-${seasonNumber}`);
        if(seasonBlock && elements.episodesModal.style.display === 'flex') {
            const isExpanded = seasonBlock.querySelector('.season-episodes').style.maxHeight !== '0px';
            const newSeasonHTML = createSeasonBlockHTML(show, { ...show.seasons[seasonNumber], season_number: seasonNumber });
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = newSeasonHTML;
            const newBlock = tempDiv.firstChild;
            seasonBlock.parentNode.replaceChild(newBlock, seasonBlock);
            setupSeasonEventListeners(seasonNumber);
            
            if (isExpanded) {
                const episodesContainer = newBlock.querySelector('.season-episodes');
                if(episodesContainer) episodesContainer.style.maxHeight = episodesContainer.scrollHeight + 'px';
            }
        }
    }

    function toggleEpisodeWatched(showId, season, episode) {
        // Find the show
        const show = mediaList.find(m => m.id === showId); 
        if (!show) return;
        
        // Determine current state from data (not HTML)
        const key = `${season}-${episode}`;
        const wasWatched = show.progress[key] ? true : false;
        const isWatched = !wasWatched; // Toggle state

        // UI Optimistic Update (Instant Feedback)
        const item = document.getElementById(`item-${showId}-${season}-${episode}`);
        if (item) {
            if (isWatched) {
                item.classList.add('watched');
            } else {
                item.classList.remove('watched');
            }
        }

        // Update Logic for all duplicates
        const duplicates = mediaList.filter(d => (d.imdbID && d.imdbID === show.imdbID) || (d.tmdbID && d.tmdbID === show.tmdbID));

        duplicates.forEach(dup => {
            if (isWatched) dup.progress[key] = true; 
            else delete dup.progress[key];
            updateShowCategoryAndTimestamps(dup);
        });
        
        // Debounce save to avoid spamming if user clicks fast
        if (debounceTimeout) clearTimeout(debounceTimeout);
        debounceTimeout = setTimeout(() => {
            saveData(); 
            updateStats(); 
            duplicates.forEach(dup => refreshSingleMedia(dup.id));
        }, 500);
        
        currentShowCache.show = show;
        
        // Update Season Header Progress Text
        const seasonBlock = document.getElementById(`season-block-${season}`);
        if (seasonBlock) {
            const watchedInSeason = Object.keys(show.progress).filter(k => k.startsWith(`${season}-`)).length;
            const episodeCount = (show.seasons[season]?.episodes || []).length;
            seasonBlock.querySelector('.season-progress-text').textContent = `${watchedInSeason} / ${episodeCount}`;
            
            // Toggle the 'Mark All' button state
             const isSeasonComplete = watchedInSeason === episodeCount && episodeCount > 0;
             const actionButton = seasonBlock.querySelector('.season-toggle-all-btn');
             if(actionButton) {
                actionButton.className = `btn season-toggle-all-btn ${isSeasonComplete ? 'btn-warning' : 'btn-success'}`;
                actionButton.title = isSeasonComplete ? 'Segna tutti come non visti' : 'Segna tutti come visti';
                actionButton.dataset.action = isSeasonComplete ? 'unwatch' : 'watch';
                actionButton.innerHTML = `<i class="fas ${isSeasonComplete ? 'fa-times' : 'fa-check-double'}"></i>`;
            }
        }
    }


    function updateShowCategoryAndTimestamps(show, forceLog = false) {
        show.lastActivityAt = new Date().toISOString(); 
        if (show.category === 'In Pausa / Droppata') return;
        
        const isCustomCategory = !DEFAULT_CATEGORIES.includes(show.category);
        if (isCustomCategory) return;

        const { watchedEpisodes, totalEpisodes } = calculateProgress(show);
        const oldCategory = show.category;

        if (watchedEpisodes === 0) show.category = "Da Vedere";
        else if (watchedEpisodes >= totalEpisodes && totalEpisodes > 0) { 
            show.category = "Completate"; 
            if(oldCategory !== 'Completate' || forceLog) {
                showNotification(`Hai completato ${show.title}!`, "success"); 
                logActivity('complete_show', show.title, '');
            }
        }
        else show.category = "In Corso";
    }

    async function moveShowToCategory(showId, newCategory) {
        const show = mediaList.find(m => m.id === showId); 
        if (show && show.category !== newCategory) { 
            const oldCategory = show.category;
            show.category = newCategory; 
            if (newCategory === 'Completate') { 
                Object.keys(show.seasons).forEach(seasonNum => {
                    (show.seasons[seasonNum].episodes || []).forEach(ep => {
                        show.progress[`${seasonNum}-${ep.episode_number}`] = true;
                    });
                }); 
            } 
            show.lastActivityAt = new Date().toISOString(); 
            await logActivity('move_show', show.title, `da '${oldCategory}' a '${newCategory}'`);
            await saveData(); 
            renderFullUI(); 
            showNotification(`"${show.title}" spostato in ${newCategory}.`, "success"); 
        }
    }
    
    async function markAsCompleted(showId) {
        const show = mediaList.find(m => m.id === showId);
        if (show && show.category !== 'Completate') {
            const oldCategory = show.category;
            show.category = 'Completate';
            show.lastActivityAt = new Date().toISOString();
            await logActivity('mark_completed', show.title, `dalla categoria '${oldCategory}'`);
            await saveData();
            renderFullUI();
            showNotification(`"${show.title}" segnato come completato.`, "success");
        }
    }

    function showContextMenu(show, pos) {
      if (isViewMode) return;
      document.querySelectorAll(".context-menu").forEach(m => m.remove()); 
      const menu = document.createElement("div"); 
      menu.className = "context-menu"; 
      const hide = () => menu.remove(); 
      setTimeout(() => document.addEventListener("click", hide, { once: true }), 0);

      const header = document.createElement("div");
      header.className = "context-menu-item";
      header.innerHTML = '<i class="fas fa-folder-open fa-fw"></i> <strong>Sposta in...</strong>';
      header.style.cssText = "color: var(--text-secondary); cursor: default; background: rgba(128,128,128,0.1);";
      menu.appendChild(header);

      categories.map(c => c.name).filter(c => c !== show.category).forEach(cat => {
          const item = document.createElement("div");
          item.className = "context-menu-item";
          const catIndex = categories.findIndex(c => c.name === cat);
          const dotClass = `category-dot-${catIndex % 6}`;
          item.innerHTML = `<span class="category-dot ${dotClass}"></span> ${cat}`;
          item.addEventListener("click", () => { moveShowToCategory(show.id, cat); hide(); });
          menu.appendChild(item);
      });
      menu.appendChild(document.createElement("div")).className = "context-menu-divider";
      
      if (show.category !== 'Completate') {
          const markCompletedItem = document.createElement("div");
          markCompletedItem.className = "context-menu-item";
          markCompletedItem.innerHTML = '<i class="fas fa-check-double fa-fw"></i> Segna come completata';
          markCompletedItem.addEventListener("click", () => { markAsCompleted(show.id); hide(); });
          menu.appendChild(markCompletedItem);
      }
      
      const changePosterItem = document.createElement("div");
      changePosterItem.className = "context-menu-item";
      changePosterItem.innerHTML = '<i class="fas fa-image fa-fw"></i> Cambia Copertina';
      changePosterItem.addEventListener("click", () => { showPosterModal(show.id); hide(); });
      menu.appendChild(changePosterItem);

      const toggleSpecialsItem = document.createElement("div");
      toggleSpecialsItem.className = "context-menu-item";
      if (show.seasons && show.seasons[0]) {
          toggleSpecialsItem.innerHTML = '<i class="fas fa-trash-alt fa-fw"></i> Rimuovi Speciali';
          toggleSpecialsItem.addEventListener("click", () => { removeSpecials(show.id); hide(); });
      } else {
          toggleSpecialsItem.innerHTML = '<i class="fas fa-plus-circle fa-fw"></i> Aggiungi Speciali';
          toggleSpecialsItem.addEventListener("click", () => { addSpecials(show.id); hide(); });
      }
      menu.appendChild(toggleSpecialsItem);
      
      const deleteItem = document.createElement("div");
      deleteItem.className = "context-menu-item";
      deleteItem.innerHTML = '<i class="fas fa-trash fa-fw"></i> Elimina';
      deleteItem.style.color = "var(--danger)";
      deleteItem.addEventListener("click", () => { deleteShow(show.id); hide(); });
      menu.appendChild(deleteItem);

      document.body.appendChild(menu);
      const rect = menu.getBoundingClientRect();
      let x = pos.x, y = pos.y;
      if (x + rect.width > window.innerWidth) x = window.innerWidth - rect.width - 5;
      if (y + rect.height > window.innerHeight) y = window.innerHeight - rect.height - 5;
      menu.style.left = `${x}px`;
      menu.style.top = `${y}px`;
      requestAnimationFrame(() => menu.classList.add('visible'));
    }

    async function addSpecials(showId) {
        const show = mediaList.find(m => m.id === showId);
        if (!show || !show.tmdbID) return;

        showNotification("Recupero episodi speciali...", "warning");
        const specialsData = await fetchTMDbSeasonDetailsWithFallback(show.tmdbID, 0);
        if (specialsData && specialsData.episodes && specialsData.episodes.length > 0) {
            show.seasons[0] = {
                name: specialsData.name || "Speciali",
                episodes: specialsData.episodes.map(ep => ({
                    name: ep.name,
                    overview: ep.overview,
                    episode_number: ep.episode_number,
                    runtime: ep.runtime || 0,
                    still_path: ep.still_path,
                    air_date: ep.air_date
                }))
            };
            await saveData();
            refreshSingleMedia(showId);
            showNotification("Episodi speciali aggiunti!", "success");
        } else {
            showNotification("Nessun episodio speciale trovato per questa serie.", "error");
        }
    }

    async function removeSpecials(showId) {
        const show = mediaList.find(m => m.id === showId);
        if (!show || !show.seasons || !show.seasons[0]) return;

        // Rimuovi i progressi legati agli speciali
        Object.keys(show.progress).forEach(key => {
            if (key.startsWith('0-')) {
                delete show.progress[key];
            }
        });
        
        delete show.seasons[0];
        await saveData();
        refreshSingleMedia(showId);
        showNotification("Episodi speciali rimossi.", "success");
    }

    function deleteShow(showId) {
        if (isViewMode) return;
        const show = mediaList.find(m => m.id === showId);
        if (!show) return;
        showConfirmModal("Elimina Serie TV", `Sei sicuro di voler eliminare "${show.title}"?`, async () => { 
            await logActivity('delete_show', show.title, `dalla categoria '${show.category}'`);
            mediaList = mediaList.filter(m => m.id !== showId); 
            await saveData(); 
            renderFullUI(); 
        });
    }

    async function showPosterModal(id) {
        const show = mediaList.find(m => m.id === id);
        if (!show || (!show.imdbID && !show.tmdbID)) return showNotification("Nessun ID valido (TMDb/IMDb) trovato per questa serie.", "warning");
        elements.posterModal.dataset.mediaId = id;
        elements.posterGrid.innerHTML = `<div style="text-align:center;"><i class="fas fa-spinner loading-spinner"></i></div>`;
        elements.posterModal.style.display = "flex";

        const posters = await fetchPosters(show);
        if (posters.length === 0) {
            elements.posterGrid.innerHTML = "<p>Nessuna copertina alternativa trovata.</p>";
            return;
        }
        elements.posterGrid.innerHTML = posters.map(p => `
            <div class="poster-option" data-url="${p.url}">
                <img src="${p.url}" onerror="this.src='${DEFAULT_POSTER}'">
                <div class="poster-language-badge">${p.iso_639_1 || 'N/A'}</div>
            </div>`).join('');
        elements.posterGrid.querySelectorAll('.poster-option').forEach(el => 
            el.addEventListener('click', () => { 
                document.querySelectorAll(".poster-option.selected").forEach(s => s.classList.remove('selected'));
                el.classList.add('selected');
            })
        );
    }
    
    async function fetchPosters(show) {
        try {
            const tmdbId = show.tmdbID || (await fetchTMDbShowDetailsByIMDb(show.imdbID))?.id;
            if (!tmdbId) return [];

            const imagesRes = await fetch(`https://api.themoviedb.org/3/tv/${tmdbId}/images?api_key=${TMDB_KEY}`);
            const imagesData = await imagesRes.json();
            const langScore = (lang) => (lang === 'it') ? 3 : (lang === 'en') ? 2 : (lang === null) ? 1 : 0;
            return imagesData.posters
                .filter(p => ['it', 'en', null].includes(p.iso_639_1))
                .sort((a, b) => langScore(b.iso_639_1) - langScore(a.iso_639_1))
                .slice(0, 30)
                .map(p => ({ url: `https://image.tmdb.org/t/p/w500${p.file_path}`, iso_639_1: p.iso_639_1 ? p.iso_639_1.toUpperCase() : null }));
        } catch (err) {
            console.error("Error fetching posters:", err);
            return [];
        }
    }
    
    function changePoster(id, url) {
        const show = mediaList.find(m => m.id === id);
        if (show) {
            const duplicates = mediaList.filter(s => (s.imdbID && s.imdbID === show.imdbID) || (s.tmdbID && s.tmdbID === show.tmdbID));
            duplicates.forEach(dup => {
                dup.poster = url;
            });
            saveData();
            renderMedia();
            closeModal(elements.posterModal);
            showNotification("Copertina aggiornata per tutte le copie!", "success");
        }
    }
    
    function renderCategoriesList() {
        const list = elements.categoriesList;
        list.innerHTML = "";
        categories.forEach((catObj, index) => {
            const card = document.createElement("div");
            card.className = "management-card";
            const isDefault = DEFAULT_CATEGORIES.includes(catObj.name);
            const dotClass = `category-dot-${index % 6}`;
            const count = mediaList.filter(m => m.category === catObj.name).length;
            card.innerHTML = `
                <div>
                    <span class="category-dot ${dotClass}"></span>
                    <div>
                        <div class="category-name">${catObj.name}</div>
                    </div>
                </div>
                <div class="management-card-actions">
                    <button class="btn move-up-btn" ${index === 0 ? "disabled" : ""} title="Sposta su"><i class="fas fa-arrow-up"></i></button>
                    <button class="btn move-down-btn" ${index === categories.length - 1 ? "disabled" : ""} title="Sposta gi√π"><i class="fas fa-arrow-down"></i></button>
                    ${!isDefault ? `
                        <button class="btn toggle-progress-btn" title="Mostra/Nascondi progresso"><i class="fas ${catObj.hideProgress ? 'fa-eye-slash' : 'fa-eye'}"></i></button>
                        <button class="btn rename-category-btn" title="Rinomina"><i class="fas fa-pencil-alt"></i></button>
                        <button class="btn btn-danger delete-category-btn" title="Elimina"><i class="fas fa-trash"></i></button>
                    ` : ''}
                </div>`;
            card.querySelector('.move-up-btn').addEventListener('click', () => moveCategory(catObj.name, -1));
            card.querySelector('.move-down-btn').addEventListener('click', () => moveCategory(catObj.name, 1));
            if (!isDefault) {
                card.querySelector('.delete-category-btn').addEventListener('click', () => deleteCategory(catObj.name));
                card.querySelector('.rename-category-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    const nameEl = e.currentTarget.closest(".management-card").querySelector(".category-name");
                    renameCategory(catObj.name, nameEl);
                });
                card.querySelector('.toggle-progress-btn').addEventListener('click', () => toggleCategoryProgress(catObj.name));
            }
            list.appendChild(card);
        });
    }

    function toggleCategoryProgress(catName) {
        const category = categories.find(c => c.name === catName);
        if(category) {
            category.hideProgress = !category.hideProgress;
            saveData();
            renderCategoriesList();
            renderMedia();
        }
    }

    function renameCategory(oldName, nameEl) {
        const input = document.createElement("input");
        input.type = "text";
        input.value = oldName;
        input.className = "category-name-input"; 
        nameEl.parentElement.replaceChild(input, nameEl);
        input.focus();
        const save = () => {
            const newName = input.value.trim();
            const catIndex = categories.findIndex(c => c.name === oldName);
            if (newName && newName !== oldName && !categories.some(c => c.name === newName)) {
                mediaList.forEach(m => { if (m.category === oldName) m.category = newName; });
                categories[catIndex].name = newName;
                saveData();
                renderFullUI();
                renderCategoriesList();
                showNotification(`Categoria rinominata in "${newName}"`, "success");
            } else {
                renderCategoriesList(); // Revert if invalid
            }
        };
        input.addEventListener("blur", save);
        input.addEventListener("keydown", e => { if (e.key === "Enter") input.blur(); });
    }

    function addCategory() {
        const name = elements.newCategoryName.value.trim();
        if (!name) return showNotification("Inserisci un nome per la categoria", "warning");
        if (categories.some(c => c.name.toLowerCase() === name.toLowerCase())) {
            return showNotification("Questa categoria esiste gi√†.", "warning");
        }
        categories.push({ name: name, hideProgress: false });
        saveData();
        renderFullUI();
        renderCategoriesList(); 
        elements.newCategoryName.value = "";
        showNotification(`Categoria "${name}" aggiunta!`, "success");
    }

    function deleteCategory(catName) {
        if (DEFAULT_CATEGORIES.includes(catName)) return;
        showConfirmModal("Elimina Categoria", `Sei sicuro di voler eliminare la categoria "${catName}"? Le serie in questa categoria verranno spostate in "Da Vedere".`, () => {
            mediaList.forEach(m => { if (m.category === catName) m.category = "Da Vedere"; });
            categories = categories.filter(c => c.name !== catName);
            saveData();
            renderFullUI();
            renderCategoriesList();
            showNotification(`Categoria "${catName}" eliminata.`, "success");
        });
    }

    function moveCategory(catName, direction) { 
        const index = categories.findIndex(c => c.name === catName); 
        const newIndex = index + direction; 
        if (newIndex >= 0 && newIndex < categories.length) { 
            [categories[index], categories[newIndex]] = [categories[newIndex], categories[index]]; 
            saveData(); 
            renderFullUI(); 
            renderCategoriesList(); 
        } 
    }

    function resetApp() { if(isViewMode) return; showConfirmModal("Resetta Tracker", "Sei sicuro di voler resettare l'applicazione? Tutti i dati andranno persi.", () => { mediaList = []; categories = DEFAULT_CATEGORIES.map(name => ({ name, hideProgress: false })); saveData(); renderFullUI(); showNotification("Tracker resettato con successo.", "success"); }); }
    function fixPosterUrl(url) { return (url && url.startsWith("https://")) ? url : DEFAULT_POSTER; }
    
    function populateCategoryFilter(selectElement) {
        const currentVal = selectElement.value;
        selectElement.innerHTML = `<option value="all">Tutte le categorie</option><option value="favorites">Solo Preferiti</option>${categories.map(cat => `<option value="${cat.name}">${cat.name}</option>`).join("")}`;
        if (Array.from(selectElement.options).some(opt => opt.value === currentVal)) {
            selectElement.value = currentVal;
        } else {
            selectElement.value = 'all';
        }
    }

    function updateCategoryFilter() { 
        populateCategoryFilter(elements.categoryFilter);
        populateCategoryFilter(elements.mobileCategoryFilter);
    }

    function populateAddMediaCategorySelect() {
        const lastUsed = localStorage.getItem("lastUsedTvShowCategory");
        elements.addMediaCategorySelect.innerHTML = categories.map(cat => `<option value="${cat.name}">${cat.name}</option>`).join("");
        if (lastUsed && categories.some(c => c.name === lastUsed)) {
            elements.addMediaCategorySelect.value = lastUsed;
        } else if (categories.some(c => c.name === "Da Vedere")) {
            elements.addMediaCategorySelect.value = "Da Vedere";
        }
    }

    function renderCategorySections() { 
        elements.mediaSectionsContainer.innerHTML = categories.map(cat => `
            <div class="media-section" data-category="${cat.name}">
                <div class="section-header">
                    <h2 class="section-title user-select-none">${cat.name}</h2>
                    <span id="${sanitizeForId(cat.name)}Count" class="category-count"></span>
                </div>
                <div class="media-grid" id="${sanitizeForId(cat.name)}Grid"></div>
            </div>`).join(""); 
    }
    function closeModal(modal) {
      if (modal.classList.contains('visible')) {
        modal.classList.remove('visible');
        setTimeout(() => { modal.style.display = "none"; }, 300); // Match transition duration
      } else {
        modal.style.display = "none";
      }
      if (!document.querySelector('.modal[style*="flex"]')) {
        document.body.classList.remove("modal-open");
      }
    }
    function showNotification(text, type = "success") { elements.notificationText.textContent = text; elements.notification.className = `notification ${type}`; elements.notification.style.display = "block"; setTimeout(() => elements.notification.style.display = "none", 3000); }
    function showConfirmModal(title, body, onConfirm) { elements.confirmModalTitle.textContent = title; elements.confirmModalBody.textContent = body; elements.confirmModal.style.display = "flex"; const confirmHandler = () => { onConfirm(); closeModal(elements.confirmModal); cleanup(); }; const cancelHandler = () => { closeModal(elements.confirmModal); cleanup(); }; const cleanup = () => { elements.confirmModalConfirm.removeEventListener("click", confirmHandler); elements.confirmModalCancel.removeEventListener("click", cancelHandler); }; elements.confirmModalConfirm.addEventListener("click", confirmHandler); elements.confirmModalCancel.addEventListener("click", cancelHandler); }
    function setupLazyLoading() { if (lazyLoadObserver) lazyLoadObserver.disconnect(); lazyLoadObserver = new IntersectionObserver((entries, observer) => { entries.forEach(entry => { if (entry.isIntersecting) { const img = entry.target; img.src = img.dataset.src; img.classList.remove("lazy"); observer.unobserve(img); } }); }, { rootMargin: "200px" }); document.querySelectorAll(".lazy").forEach(img => lazyLoadObserver.observe(img)); }
    function loadSortOrder() { elements.sortFilter.value = localStorage.getItem("tvShowSortOrder") || "added"; }
    function loadTheme() { const theme = localStorage.getItem("theme") || "dark"; document.body.classList.toggle("dark", theme === "dark"); elements.themeToggle.innerHTML = `<i class="fas fa-${theme === "dark" ? "sun" : "moon"}"></i>`; elements.mobileMenuThemeBtn.innerHTML = `<i class="fas fa-${theme === "dark" ? "sun" : "moon"}"></i>Cambia Tema`; }
    
    async function searchTMDb() {
        const title = elements.mediaTitle.value.trim();
        if (!title) return;
        elements.tmdbResults.innerHTML = `<div style="text-align:center;"><i class="fas fa-spinner loading-spinner"></i></div>`;
        try {
            const res = await fetch(`https://api.themoviedb.org/3/search/tv?api_key=${TMDB_KEY}&query=${encodeURIComponent(title)}&language=it-IT&include_adult=false`);
            const data = await res.json();
            if (data.results && data.results.length > 0) {
                elements.tmdbResults.innerHTML = data.results.map(r => `
                    <div class="tmdb-result-item" data-tmdb-id="${r.id}" data-title="${r.name}">
                        <img src="${r.poster_path ? `https://image.tmdb.org/t/p/w200${r.poster_path}` : DEFAULT_POSTER}" class="tmdb-poster-small" onerror="this.src='${DEFAULT_POSTER}'">
                        <div>
                            <strong>${r.name}</strong> (${r.first_air_date ? r.first_air_date.split('-')[0] : 'N/D'})
                            <div style="font-size:0.8rem; color: var(--text-secondary)">${r.original_name}</div>
                        </div>
                    </div>`).join('');
                document.querySelectorAll(".tmdb-result-item").forEach(item => item.addEventListener("click", () => {
                    currentTMDbSelection = { tmdbId: item.dataset.tmdbId };
                    elements.mediaTitle.value = item.dataset.title;
                    showNotification(`"${item.dataset.title}" selezionato.`, "success");
                }));
            } else {
                elements.tmdbResults.innerHTML = `<p>Nessun risultato</p>`;
            }
        } catch (err) {
            elements.tmdbResults.innerHTML = "<p>Errore di rete</p>";
        }
    }
    
    function triggerNewEpisodeCheck() {
        const now = new Date().getTime();
        const lastCheck = localStorage.getItem('lastNewEpisodeCheck');
        const SIX_HOURS = 6 * 60 * 60 * 1000;

        if (!lastCheck || (now - lastCheck) > SIX_HOURS) {
            console.log("Esecuzione del controllo per nuovi episodi...");
            checkForNewEpisodes();
            localStorage.setItem('lastNewEpisodeCheck', now);
        }
    }
    
    function checkForNewEpisodes() {
        const lastCheckString = localStorage.getItem('lastNewEpisodeCheck');
        const lastCheckDate = lastCheckString ? new Date(parseInt(lastCheckString)) : new Date(Date.now() - 24 * 60 * 60 * 1000); 
        const currentDate = new Date();
        
        const showsToCheck = mediaList.filter(s => s.category === 'In Corso');
        
        showsToCheck.forEach(show => {
            Object.values(show.seasons).forEach(season => {
                (season.episodes || []).forEach(ep => {
                    if (ep.air_date) {
                        const airDate = new Date(ep.air_date);
                        if (airDate >= lastCheckDate && airDate <= currentDate) {
                             if (!show.progress[`${season.season_number}-${ep.episode_number}`]) {
                                setTimeout(() => showNotification(`√à uscito un nuovo episodio di ${show.title}!`, 'success'), 500);
                             }
                        }
                    }
                });
            });
        });
    }

    async function updateAllShowsInBackground(force = false) {
        if (isUpdateInProgress) {
            if (force) {
                showNotification("Aggiornamento gi√† in corso.", "warning");
            }
            console.log("Tentativo di avvio aggiornamento bloccato: un altro √® gi√† in corso.");
            return;
        }

        isUpdateInProgress = true;

        try {
            const now = new Date().getTime();
            const lastUpdate = localStorage.getItem('lastBackgroundUpdate');
            const TWENTY_FOUR_HOURS = 24 * 60 * 60 * 1000;

            if (!force && lastUpdate && (now - lastUpdate) < TWENTY_FOUR_HOURS) {
                console.log("Aggiornamento in background saltato: non ancora trascorse 24 ore.");
                isUpdateInProgress = false;
                return;
            }

            const today = new Date();
            today.setUTCHours(0, 0, 0, 0);
            const sevenDaysAgo = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000);
            const sevenDaysFromNow = new Date(today.getTime() + 7 * 24 * 60 * 60 * 1000);

            const showsToUpdate = mediaList.filter(show => {
                if (!show.tmdbID) return false;
                return Object.values(show.seasons).some(season =>
                    (season.episodes || []).some(ep => {
                        if (!ep.air_date) return false;
                        const airDate = new Date(ep.air_date + 'T00:00:00Z');
                        return airDate >= sevenDaysAgo && airDate <= sevenDaysFromNow;
                    })
                );
            });
            
            if (showsToUpdate.length === 0) {
                if (force) showNotification("Nessuna serie con attivit√† recente da aggiornare.", "warning");
                localStorage.setItem('lastBackgroundUpdate', now);
                displayLastUpdateTime();
                isUpdateInProgress = false;
                return;
            }
            
            console.log(`Avvio aggiornamento per ${showsToUpdate.length} serie...`);
            elements.updateProgressModal.style.display = 'flex';
            elements.updateProgressTitle.textContent = force ? "Aggiornamento Manuale" : "Aggiornamento Giornaliero";
            let allChanges = [];

            for (let i = 0; i < showsToUpdate.length; i++) {
                const show = showsToUpdate[i];
                const progress = ((i + 1) / showsToUpdate.length) * 100;
                elements.updateProgressBarFill.style.width = `${progress}%`;
                elements.updateProgressText.textContent = `Controllo ${i + 1} di ${showsToUpdate.length}: ${show.title}...`;
                
                try {
                    const showChanges = await showDetailsModal(show.id, true);
                    if (showChanges.length > 0) {
                        allChanges = allChanges.concat(showChanges);
                    }
                    await new Promise(resolve => setTimeout(resolve, 400));
                } catch (error) {
                    console.error(`Errore aggiornando ${show.title} in background:`, error);
                }
            }
            
            closeModal(elements.updateProgressModal);

            if (allChanges.length > 0) {
                elements.updateSummaryList.innerHTML = allChanges.map(change => `<li>${change}</li>`).join('');
                elements.updateSummaryModal.style.display = 'flex';
            } else if (force) {
                showNotification("Nessun aggiornamento trovato.", "success");
            }
            
            localStorage.setItem('lastBackgroundUpdate', now);
            displayLastUpdateTime();
        } finally {
            isUpdateInProgress = false;
        }
    }
    
    function setupAuthListeners() {
        elements.authToggle.addEventListener("click", e => { e.stopPropagation(); elements.authForms.classList.toggle("active"); });
        document.addEventListener("click", e => { if (!elements.authForms.contains(e.target) && !e.target.closest('.auth-container')) { elements.authForms.classList.remove("active"); }});
        document.querySelectorAll(".auth-tab").forEach(tab => tab.addEventListener("click", () => {
            document.querySelectorAll(".auth-tab, .auth-form-container").forEach(el => el.classList.remove("active"));
            tab.classList.add("active");
            document.getElementById(`${tab.dataset.tab}Form`).classList.add("active");
        }));
        elements.loginBtn.addEventListener('click', () => firebase.auth().signInWithEmailAndPassword(document.getElementById('loginEmail').value, document.getElementById('loginPassword').value).catch(err => showNotification(err.message, "error")));
        elements.registerBtn.addEventListener('click', () => {
            const pass = document.getElementById('registerPassword').value;
            if (pass !== document.getElementById('registerConfirmPassword').value) { showNotification("Le password non corrispondono.", "warning"); return; }
            firebase.auth().createUserWithEmailAndPassword(document.getElementById('registerEmail').value, pass)
                .then(cred => db.ref(`users/${cred.user.uid}/email`).set(cred.user.email))
                .catch(err => showNotification(err.message, "error"));
        });
        elements.logoutBtn.addEventListener("click", () => {
            detachAllFriendListeners();
            firebase.auth().signOut()
        });
        firebase.auth().onAuthStateChanged(user => {
            if (isViewMode) return;
            currentUser = user;
            updateAuthUI();
            if (user) { 
                loadData(); 
            } else { 
                loadLocalData(); 
                hideLoader(); 
            }
        });
    }
    
    function updateAuthUI() {
        const userActionBtn = elements.mobileMenuUserActionBtn.querySelector('span');
        if(currentUser) {
            elements.userInfo.style.display = "flex";
            elements.authToggle.parentElement.style.display = "none";
            elements.notificationBellContainer.style.display = 'block';
            elements.updateSectionDesktop.style.display = 'block';
            if (userActionBtn) {
              userActionBtn.textContent = 'Logout';
              elements.mobileMenuUserActionBtn.style.color = 'var(--danger)';
              elements.mobileMenuUserActionBtn.querySelector('i').style.color = 'var(--danger)';
            }
        } else {
            elements.userInfo.style.display = "none";
            elements.authToggle.parentElement.style.display = "block";
            elements.notificationBellContainer.style.display = 'none';
            elements.updateSectionDesktop.style.display = 'none';
            if (userActionBtn) {
              userActionBtn.textContent = 'Login / Registrati';
              elements.mobileMenuUserActionBtn.style.color = '';
              elements.mobileMenuUserActionBtn.querySelector('i').style.color = '';
            }
        }
    }

    function handleViewMode() {
      const viewId = new URLSearchParams(window.location.search).get("view");
      if (!viewId) { hideLoader(); return false; }
      isViewMode = true;
      document.body.style.paddingBottom = '0';
      document.getElementById('bottomNav').style.display = 'none';
      document.querySelectorAll("#mediaManagementBtn, #shareBtn, #exportBtn, #importBtn, #resetBtn, .auth-container, #userInfo, .notification-bell-container").forEach(el => el.style.display = "none");
      elements.viewModeBanner.style.display = "flex";
      db.ref(`users/${viewId}/tvShowTracker`).on("value", snapshot => {
        const data = snapshot.val();
        if (data) {
          mediaList = (data.mediaList || []).map(item => ({...getDefaultShowProps(), ...item}));
          categories = (data.categories || DEFAULT_CATEGORIES.map(name => ({ name, hideProgress: false }))).map(cat => (typeof cat === 'string') ? { name: cat, hideProgress: false } : cat);
          renderFullUI();
          db.ref(`users/${viewId}/email`).once("value", emailSnap => {
            elements.viewModeUserEmail.textContent = `Stai visualizzando la libreria di ${emailSnap.val() || "un utente"}`;
          });
        } else { showNotification("Libreria condivisa non trovata.", "error"); }
        hideLoader();
      });
      return true;
    }
    
    function logActivity(type, title, details) {
        if (!currentUser) return;
        const logRef = db.ref(`users/${currentUser.uid}/activityLog`);
        const newActivity = { type, title, details, timestamp: new Date().toISOString() };
        
        return logRef.transaction(currentLog => {
            let log = Array.isArray(currentLog) ? currentLog : [];
            log.unshift(newActivity);
            return log.slice(0, MAX_LOG_SIZE);
        });
    }

    function detachAllFriendListeners() {
        Object.values(friendListeners).forEach(({ ref, listener }) => ref.off('value', listener));
        friendListeners = {};
    }
    
    function setupFriendListeners() {
        if (!currentUser) return;
        detachAllFriendListeners();
        const friendActivityMap = new Map();
        const processAndRenderNotifications = () => {
            let allNewNotifications = Array.from(friendActivityMap.values()).flat();
            allNewNotifications.sort((a, b) => new Date(b.activity.timestamp) - new Date(a.activity.timestamp));
            renderNotifications(allNewNotifications.slice(0, MAX_NOTIFICATIONS));
        };
        
        followedFriends.forEach(friend => {
            const ref = db.ref(`users/${friend.id}/activityLog`);
            const listener = snapshot => {
                const activities = snapshot.val() || [];
                const lastChecked = lastCheckedTimestamps[friend.id] || new Date(0).toISOString();
                
                const activityArray = Array.isArray(activities) ? activities : [];
                const newActivities = activityArray
                    .filter(act => act && new Date(act.timestamp) > new Date(lastChecked))
                    .map(activity => ({ friendId: friend.id, friendEmail: friend.email, activity }));

                friendActivityMap.set(friend.id, newActivities);
                processAndRenderNotifications();
            };
            ref.on('value', listener);
            friendListeners[friend.id] = { ref, listener };
        });
    }
    
    function populateNotificationList(listElement, notifications) {
        listElement.innerHTML = ''; // Clear previous notifications
        if (notifications.length > 0) {
            notifications.forEach(n => {
                if (!n.activity) return;
                const item = document.createElement('div');
                item.className = 'notification-item';
                item.dataset.friendId = n.friendId;
                const isTV = n.activity.type.includes('show') || n.activity.type.includes('season');
                item.innerHTML = `
                    <i class="fas ${getActivityIcon(n.activity.type)} ${isTV ? 'tv-notification' : 'film-notification'}"></i>
                    <span class="notification-item-text">${getActivityText(n.friendEmail, n.activity)}</span>`;
                
                item.addEventListener('click', () => {
                    const friendId = item.dataset.friendId;
                    if (friendId) { 
                        const baseUrl = window.location.origin + window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/'));
                        const url = isTV 
                            ? `${baseUrl}/serietv_tracker.html?view=${friendId}`
                            : `${baseUrl}/index.html?view=${friendId}`;
                       window.open(url, '_blank');
                    }
                });
                listElement.appendChild(item);
            });
        } else {
            const emptyState = document.createElement('div');
            emptyState.className = 'no-notifications';
            emptyState.textContent = 'Nessuna nuova notifica';
            listElement.appendChild(emptyState);
        }
    }

    function renderNotifications(notifications) {
        const count = notifications.length;

        // Desktop Dropdown
        elements.notificationBadge.textContent = count;
        elements.notificationBadge.classList.toggle('visible', count > 0);
        const desktopList = elements.notificationDropdown.querySelector('.notification-list');
        if (!desktopList) { // Initial setup for desktop dropdown
            elements.notificationDropdown.innerHTML = `
                <div class="notification-header">Notifiche Amici</div>
                <div class="notification-list"></div>
                <div class="notification-footer">
                    <button class="btn btn-primary btn-small" id="markReadAllDesktop"><i class="fas fa-check-double"></i> Segna tutte come lette</button>
                </div>`;
            document.getElementById('markReadAllDesktop').addEventListener('click', markAllNotificationsAsRead);
        }
        populateNotificationList(elements.notificationDropdown.querySelector('.notification-list'), notifications);

        // Mobile Modal
        elements.notificationBadgeMobile.textContent = count;
        elements.notificationBadgeMobile.classList.toggle('visible', count > 0);
        populateNotificationList(elements.notificationListMobile, notifications);
    }

    
    function markAllNotificationsAsRead() {
        if (!currentUser) return;
        followedFriends.forEach(f => lastCheckedTimestamps[f.id] = new Date().toISOString());
        saveSocialData();
        renderNotifications([]); // This will clear both desktop and mobile
        closeModal(elements.mobileNotificationsModal);
    }

    function getActivityIcon(type) {
        if (type.startsWith('add_show')) return 'fa-plus-circle';
        if (type.startsWith('move_show')) return 'fa-folder-open';
        if (type.startsWith('delete_show')) return 'fa-trash-alt';
        if (type.startsWith('complete_show') || type === 'mark_completed') return 'fa-check-double';
        if (type.startsWith('complete_season')) return 'fa-check-circle';
        if (type === 'add') return 'fa-film';
        if (type === 'move') return 'fa-folder-open';
        if (type === 'delete') return 'fa-trash-alt';
        if (type === 'rewatch') return 'fa-sync-alt';
        return 'fa-info-circle';
    }

    function getActivityText(friendEmail, activity) {
        const email = `<strong>${friendEmail || 'Utente'}</strong>`;
        const title = `<strong>${activity.title}</strong>`;
        switch (activity.type) {
            case 'add_show': return `${email} ha aggiunto la serie ${title} ${activity.details}`;
            case 'move_show': return `${email} ha spostato la serie ${title} ${activity.details}`;
            case 'delete_show': return `${email} ha eliminato la serie ${title} ${activity.details}`;
            case 'complete_show': return `${email} ha completato la serie ${title}! üéâ`;
            case 'mark_completed': return `${email} ha segnato ${title} come completato.`;
            case 'complete_season': return `${email} ha completato ${activity.details} di ${title}`;
            case 'add': return `${email} ha aggiunto il film ${title} ${activity.details}`;
            case 'move': return `${email} ha spostato il film ${title} ${activity.details}`;
            case 'delete': return `${email} ha eliminato il film ${title} ${activity.details}`;
            case 'rewatch': return `${email} ha aggiornato ${title} (${activity.details})`;
            default: return `${email} ha aggiornato ${title}`;
        }
    }

    async function addFriend() {
        const friendId = elements.friendIdInput.value.trim();
        if (!friendId || !currentUser) return;
        if (friendId === currentUser.uid) { showNotification("Non puoi aggiungere te stesso.", "warning"); return; }
        if (followedFriends.some(f => f.id === friendId)) { showNotification("Amico gi√† presente in lista.", "warning"); return; }
        const friendEmailRef = db.ref(`users/${friendId}/email`);
        const snapshot = await friendEmailRef.once('value');
        if (snapshot.exists()) {
            followedFriends.push({ id: friendId, email: snapshot.val() });
            lastCheckedTimestamps[friendId] = new Date().toISOString();
            await saveSocialData();
            renderFriendsList();
            setupFriendListeners();
            showNotification("Amico aggiunto!", "success");
        } else {
            showNotification("ID Utente non trovato.", "error");
        }
    }
    
    async function removeFriend(friendId) {
        followedFriends = followedFriends.filter(f => f.id !== friendId);
        delete lastCheckedTimestamps[friendId];
        await saveSocialData();
        renderFriendsList();
        setupFriendListeners();
    }

    function renderFriendsList() {
        if (!currentUser) { elements.friendsList.innerHTML = "<p>Devi essere loggato per usare questa funzione.</p>"; document.getElementById('myIdContainer').style.display = 'none'; return; }
        document.getElementById('myIdContainer').style.display = 'block';
        elements.myIdInput.value = currentUser.uid;
        elements.friendsList.innerHTML = "";
        if (followedFriends.length === 0) { elements.friendsList.innerHTML = `<p style="text-align:center; color: var(--text-secondary);">Non stai seguendo nessun amico.</p>`; return; }
        followedFriends.forEach(friend => {
            const card = document.createElement("div"); card.className = "management-card";
            card.innerHTML = `
                <div>
                    <div>
                        <div class="friend-email">${friend.email}</div>
                        <div class="friend-id">${friend.id}</div>
                    </div>
                </div>
                <div class="management-card-actions">
                    <button class="btn visit-friend-films-btn" data-id="${friend.id}" title="Visita Libreria Film"><i class="fas fa-film"></i></button>
                    <button class="btn visit-friend-tv-btn" data-id="${friend.id}" title="Visita Libreria Serie TV"><i class="fas fa-tv"></i></button>
                    <button class="btn btn-danger remove-friend-btn" data-id="${friend.id}" title="Rimuovi Amico"><i class="fas fa-trash"></i></button>
                </div>`;
            card.querySelector('.remove-friend-btn').addEventListener('click', () => removeFriend(friend.id));
            card.querySelector('.visit-friend-films-btn').addEventListener('click', (e) => {
              const url = `${window.location.origin}${window.location.pathname.replace('serietv_tracker.html', 'index.html')}?view=${e.currentTarget.dataset.id}`;
              window.open(url, '_blank');
            });
            card.querySelector('.visit-friend-tv-btn').addEventListener('click', (e) => {
              const url = `${window.location.origin}${window.location.pathname}?view=${e.currentTarget.dataset.id}`;
              window.open(url, '_blank');
            });
            elements.friendsList.appendChild(card);
        });
    }

    async function toggleFavorite(showId) {
        if (isViewMode) return;
        const show = mediaList.find(m => m.id === showId);
        if (show) {
            show.isFavorite = !show.isFavorite;
            await saveData();
            
            const cardBtn = document.querySelector(`.media-card[data-id="${showId}"] .favorite-btn`);
            if (cardBtn) cardBtn.classList.toggle('is-favorite', show.isFavorite);
            
            const modalBtn = document.getElementById('detailsModalFavoriteBtn');
            if (modalBtn && elements.detailsModal.style.display === 'flex') {
                modalBtn.classList.toggle('is-favorite', show.isFavorite);
            }

            if (elements.categoryFilter.value === 'favorites') {
                renderMedia();
            }
        }
    }
    
    function openRewatchModal(context) {
        currentRewatchContext = context;
        const { showId, seasonNumber, episodeNumber } = context;
        const show = mediaList.find(s => s.id === showId);
        if(!show) return;

        let currentCount = 0;
        let title = "";

        if (episodeNumber) {
            const episodeKey = `${seasonNumber}-${episodeNumber}`;
            currentCount = show.rewatches?.[episodeKey] || 0;
            const episode = show.seasons?.[seasonNumber]?.episodes.find(e => e.episode_number == episodeNumber);
            title = episode ? `S${seasonNumber} E${episodeNumber} - ${episode.name}` : `Episodio S${seasonNumber}E${episodeNumber}`;
        } else {
            title = `Stagione ${seasonNumber}`;
        }
        
        elements.rewatchModalTitle.textContent = `Rewatch: ${title}`;
        elements.rewatchCountInput.value = currentCount;
        updateRewatchModalButtons(currentCount);

        elements.rewatchModal.style.display = 'flex';
        document.body.classList.add('modal-open');
    }

    async function setRewatchCount(count) {
        const { showId, seasonNumber, episodeNumber } = currentRewatchContext;
        const show = mediaList.find(s => s.id === showId);
        if (!show) return;

        const duplicates = mediaList.filter(d => (d.imdbID && d.imdbID === show.imdbID) || (d.tmdbID && d.tmdbID === show.tmdbID));

        duplicates.forEach(dup => {
            if (!dup.rewatches) dup.rewatches = {};

            if (episodeNumber) {
                const key = `${seasonNumber}-${episodeNumber}`;
                if (count > 0) {
                    dup.rewatches[key] = count;
                    if (!dup.progress[key]) dup.progress[key] = true;
                }
                else delete dup.rewatches[key];
            } else {
                const season = dup.seasons[seasonNumber];
                if (season && season.episodes) {
                    season.episodes.forEach(ep => {
                        const key = `${seasonNumber}-${ep.episode_number}`;
                        if (count > 0) {
                            dup.rewatches[key] = count;
                            if (!dup.progress[key]) dup.progress[key] = true;
                        }
                        else delete dup.rewatches[key];
                    });
                }
            }
            updateShowCategoryAndTimestamps(dup);
        });

        await saveData();
        updateStats();
        
        const seasonBlock = document.getElementById(`season-block-${seasonNumber}`);
        if(seasonBlock && elements.episodesModal.style.display === 'flex') {
            const isExpanded = seasonBlock.querySelector('.season-episodes').style.maxHeight && seasonBlock.querySelector('.season-episodes').style.maxHeight !== '0px';
            const newSeasonHTML = createSeasonBlockHTML(show, { ...show.seasons[seasonNumber], season_number: seasonNumber });
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = newSeasonHTML;
            const newBlock = tempDiv.firstChild;
            seasonBlock.parentNode.replaceChild(newBlock, seasonBlock);
            setupSeasonEventListeners(seasonNumber);
            
            if (isExpanded) {
                const episodesContainer = newBlock.querySelector('.season-episodes');
                if(episodesContainer) episodesContainer.style.maxHeight = episodesContainer.scrollHeight + 'px';
            }
        }

        closeModal(elements.rewatchModal);
        showNotification("Conteggio rewatch aggiornato!", "success");
    }


    function updateRewatchModalButtons(count) {
        document.querySelectorAll('#rewatchModal .quick-rewatch-btn').forEach(btn => {
            btn.classList.toggle('active', parseInt(btn.dataset.count) === count);
        });
    }

    function displayLastUpdateTime() {
        const lastUpdate = localStorage.getItem('lastBackgroundUpdate');
        let timestampText = "Mai eseguito";
        if (lastUpdate) {
            timestampText = new Date(parseInt(lastUpdate)).toLocaleString('it-IT');
        }
        elements.lastUpdateTimestampDesktop.textContent = `Ultimo aggiornamento: ${timestampText}`;
        elements.lastUpdateTimestampMobile.textContent = `Ultimo aggiornamento: ${timestampText}`;
    }

    function setupEventListeners() {
      elements.mediaManagementBtn.addEventListener("click", () => { elements.mediaManagementModal.style.display = 'flex'; elements.mediaTitle.value = ''; elements.tmdbResults.innerHTML = ''; currentTMDbSelection = null; renderCategoriesList(); renderFriendsList(); populateAddMediaCategorySelect();});
      document.querySelectorAll('.tab-btn').forEach(btn => btn.addEventListener('click', () => { document.querySelectorAll('.tab-btn, .tab-content').forEach(el => el.classList.remove('active')); btn.classList.add('active'); document.getElementById(`${btn.dataset.tab}-tab`).classList.add('active'); elements.addShowBtn.style.display = btn.dataset.tab === 'add-media' ? 'inline-flex' : 'none'; }));
      elements.closeManagementModal.addEventListener("click", () => closeModal(elements.mediaManagementModal));
      elements.addShowBtn.addEventListener('click', () => { if (!currentTMDbSelection) { showNotification("Cerca e seleziona una serie.", "warning"); return; } addNewMedia(currentTMDbSelection.tmdbId); });
      elements.searchTMDbBtn.addEventListener("click", searchTMDb);
      elements.mediaTitle.addEventListener("keydown", e => { if(e.key === "Enter") searchTMDb(); });
      elements.addCategoryBtn.addEventListener("click", addCategory);
      elements.newCategoryName.addEventListener("keydown", e => { if (e.key === "Enter") addCategory(); });
      elements.searchInput.addEventListener("input", () => { clearTimeout(debounceTimeout); debounceTimeout = setTimeout(renderMedia, 300); });
      elements.categoryFilter.addEventListener("change", renderMedia);
      elements.sortFilter.addEventListener("change", () => { localStorage.setItem("tvShowSortOrder", elements.sortFilter.value); renderMedia(); });
      elements.themeToggle.addEventListener("click", () => { document.body.classList.toggle("dark"); localStorage.setItem("theme", document.body.classList.contains("dark") ? "dark" : "light"); loadTheme(); });
      elements.resetBtn.addEventListener('click', resetApp);
      elements.detailsModalClose.addEventListener('click', () => closeModal(elements.detailsModal));
      elements.episodesModalClose.addEventListener('click', () => closeModal(elements.episodesModal));
      elements.actorModalClose.addEventListener('click', () => closeModal(elements.actorModal));
      document.addEventListener("click", e => { if (e.target === elements.detailsModal) closeModal(elements.detailsModal); if (e.target === elements.episodesModal) closeModal(elements.episodesModal); if (e.target === elements.actorModal) closeModal(elements.actorModal); if (e.target === elements.rewatchModal) closeModal(elements.rewatchModal); if (e.target === elements.mobileMenuModal) closeModal(elements.mobileMenuModal); if (e.target === elements.mobileNotificationsModal) closeModal(elements.mobileNotificationsModal); if (e.target === elements.filterSortModal) closeModal(elements.filterSortModal); if (e.target === elements.updateSummaryModal) closeModal(elements.updateSummaryModal); if (!e.target.closest('.notification-bell-container')) elements.notificationDropdown.classList.remove('visible'); });
      elements.savePosterChange.addEventListener('click', () => { const selected = document.querySelector(".poster-option.selected"); if (selected) changePoster(elements.posterModal.dataset.mediaId, selected.dataset.url); });
      elements.cancelPosterChange.addEventListener('click', () => closeModal(elements.posterModal));
      elements.exportBtn.addEventListener('click', () => { const a = document.createElement('a'); a.href = URL.createObjectURL(new Blob([JSON.stringify({ mediaList, categories }, null, 2)], {type: 'application/json'})); a.download = `serietv_tracker_${new Date().toISOString().split('T')[0]}.json`; a.click(); URL.revokeObjectURL(a.href); });
      elements.importBtn.addEventListener('click', () => elements.importFile.click());
      elements.importFile.addEventListener('change', e => { const file = e.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = event => { try { const data = JSON.parse(event.target.result); if (data && Array.isArray(data.mediaList)) { showConfirmModal("Importa Dati", `Sovrascrivere i dati con ${data.mediaList.length} serie?`, () => { mediaList = data.mediaList.map(item => ({...getDefaultShowProps(), ...item})); categories = (data.categories || DEFAULT_CATEGORIES.map(name => ({ name, hideProgress: false }))).map(cat => typeof cat === 'string' ? {name: cat, hideProgress: false} : cat); saveData(); renderFullUI(); showNotification("Dati importati!", "success"); }); } else { showNotification("File non valido.", "error"); } } catch (error) { showNotification("Errore lettura file.", "error"); } }; reader.readAsText(file); e.target.value = ''; });
      elements.shareBtn.addEventListener('click', () => { if (!currentUser) { showNotification("Devi essere loggato per condividere.", "warning"); return; } const link = `${window.location.origin}${window.location.pathname.replace('index.html', 'serietv_tracker.html')}?view=${currentUser.uid}`; elements.shareModal.querySelector('input').value = link; elements.shareModal.style.display = 'flex'; });
      elements.closeShareModalBtn.addEventListener('click', () => closeModal(elements.shareModal));
      elements.copyShareLinkBtn.addEventListener('click', (e) => { navigator.clipboard.writeText(e.target.closest('.modal-content').querySelector('input').value); showNotification("Link copiato!", "success"); });
      elements.closeViewBtn.addEventListener('click', () => { window.location.href = window.location.pathname; });
      elements.addFriendBtn.addEventListener('click', addFriend);
      elements.copyMyIdBtn.addEventListener('click', () => { navigator.clipboard.writeText(elements.myIdInput.value); showNotification("ID copiato!", "success"); });
      elements.bellIcon.addEventListener('click', (e) => { e.stopPropagation(); elements.notificationDropdown.classList.toggle('visible'); });
      elements.closeSummaryBtn.addEventListener('click', () => closeModal(elements.updateSummaryModal));
      
      elements.confirmRewatchBtn.addEventListener('click', () => { const newCount = parseInt(elements.rewatchCountInput.value); if (!isNaN(newCount) && newCount >= 0) { setRewatchCount(newCount); } else { showNotification("Inserisci un numero valido (0 o superiore).", "warning"); } });
      elements.cancelRewatchBtn.addEventListener('click', () => closeModal(elements.rewatchModal));
      document.querySelectorAll('#rewatchModal .quick-rewatch-btn').forEach(btn => btn.addEventListener('click', () => { const count = parseInt(btn.dataset.count); elements.rewatchCountInput.value = count; updateRewatchModalButtons(count); }));
      elements.rewatchCountInput.addEventListener('input', () => { const count = parseInt(elements.rewatchCountInput.value); updateRewatchModalButtons(count); });
      document.querySelectorAll("#rewatchModal .num-spinner-btn").forEach(btn => { btn.addEventListener("click", e => { const target = document.getElementById(e.currentTarget.dataset.target); if (target) { let value = parseInt(target.value) || 0; value += e.currentTarget.classList.contains("up") ? 1 : -1; if (value < 0) value = 0; target.value = value; updateRewatchModalButtons(value); } }); });
      
      // --- Bottom Nav Bar Listeners ---
      elements.bottomNavHome.addEventListener('click', () => window.scrollTo({ top: 0, behavior: 'smooth' }));
      elements.bottomNavSearch.addEventListener('click', () => { elements.searchInput.scrollIntoView({ behavior: 'smooth', block: 'center' }); setTimeout(() => elements.searchInput.focus(), 300); });
      elements.bottomNavAdd.addEventListener('click', () => { elements.mediaManagementBtn.click(); document.querySelector('.tab-btn[data-tab="add-media"]').click(); });
      elements.bottomNavManage.addEventListener('click', () => { elements.mobileMenuModal.style.display = 'flex'; requestAnimationFrame(() => elements.mobileMenuModal.classList.add('visible')); });
      elements.bottomNavNotifications.addEventListener('click', () => { elements.mobileNotificationsModal.style.display = 'flex'; requestAnimationFrame(() => elements.mobileNotificationsModal.classList.add('visible')); });
      
      // --- Mobile Modals Listeners ---
      elements.mobileMenuCloseBtn.addEventListener('click', () => closeModal(elements.mobileMenuModal));
      elements.mobileNotificationsCloseBtn.addEventListener('click', () => closeModal(elements.mobileNotificationsModal));
      elements.markAllReadMobileBtn.addEventListener('click', markAllNotificationsAsRead);
      elements.mobileMenuUserActionBtn.addEventListener('click', () => { (currentUser) ? elements.logoutBtn.click() : elements.authToggle.click(); closeModal(elements.mobileMenuModal); });
      elements.mobileMenuShareBtn.addEventListener('click', () => { elements.shareBtn.click(); closeModal(elements.mobileMenuModal); });
      elements.mobileMenuExportBtn.addEventListener('click', () => { elements.exportBtn.click(); closeModal(elements.mobileMenuModal); });
      elements.mobileMenuImportBtn.addEventListener('click', () => { elements.importBtn.click(); closeModal(elements.mobileMenuModal); });
      elements.mobileMenuThemeBtn.addEventListener('click', () => { elements.themeToggle.click(); });
      elements.mobileMenuResetBtn.addEventListener('click', () => { elements.resetBtn.click(); closeModal(elements.mobileMenuModal); });

      // --- Filter Modal Listeners ---
      elements.mobileFilterBtn.addEventListener('click', () => {
          elements.mobileCategoryFilter.value = elements.categoryFilter.value;
          elements.mobileSortFilter.value = elements.sortFilter.value;
          elements.filterSortModal.style.display = 'flex';
          requestAnimationFrame(() => elements.filterSortModal.classList.add('visible'));
      });
      elements.applyFiltersBtn.addEventListener('click', () => {
          elements.categoryFilter.value = elements.mobileCategoryFilter.value;
          elements.sortFilter.value = elements.mobileSortFilter.value;
          localStorage.setItem("tvShowSortOrder", elements.sortFilter.value);
          renderMedia();
          closeModal(elements.filterSortModal);
      });
      
      // --- Force Update Listeners ---
      const forceUpdate = () => {
        updateAllShowsInBackground(true);
      };
      elements.forceUpdateBtnDesktop.addEventListener('click', forceUpdate);
      elements.forceUpdateBtnMobile.addEventListener('click', () => {
        forceUpdate();
        closeModal(elements.mobileMenuModal);
      });
    }

    // --- BACK GESTURE IMPLEMENTATION FOR MOBILE MODALS ---
    let touchStartX = 0;
    let touchStartY = 0;
    let touchEndX = 0;
    let touchEndY = 0;
    let isSwipingBack = false;

    function handleTouchStart(e) {
        touchStartX = e.changedTouches[0].screenX;
        touchStartY = e.changedTouches[0].screenY;
        isSwipingBack = false;
    }

    function handleTouchMove(e) {
        if (!touchStartX || !touchStartY) return;
        
        touchEndX = e.changedTouches[0].screenX;
        touchEndY = e.changedTouches[0].screenY;
        
        const deltaX = touchEndX - touchStartX;
        const deltaY = touchEndY - touchStartY;
        
        // Check if this is a horizontal swipe to the right
        if (Math.abs(deltaX) > Math.abs(deltaY) && deltaX > 50) {
            isSwipingBack = true;
            e.preventDefault();
        }
    }

    function handleTouchEnd(e) {
        if (!touchStartX || !touchStartY) return;
        
        const deltaX = touchEndX - touchStartX;
        const deltaY = touchEndY - touchStartY;
        
        // Check if it's a valid back gesture (swipe right with minimal vertical movement)
        if (isSwipingBack && Math.abs(deltaX) > 100 && Math.abs(deltaY) < 100) {
            const modal = e.currentTarget;
            if (modal && modal.classList.contains('modal') && modal.style.display === 'flex') {
                closeModal(modal);
            }
        }
        
        // Reset values
        touchStartX = 0;
        touchStartY = 0;
        touchEndX = 0;
        touchEndY = 0;
        isSwipingBack = false;
    }

    // Add back gesture support to all modals
    function setupBackGestureSupport() {
        const modals = document.querySelectorAll('.modal');
        modals.forEach(modal => {
            // Skip modals that shouldn't be closed with back gesture
            if (modal.id === 'confirmModal') return;
            
            modal.addEventListener('touchstart', handleTouchStart, { passive: false });
            modal.addEventListener('touchmove', handleTouchMove, { passive: false });
            modal.addEventListener('touchend', handleTouchEnd, { passive: false });
        });
    }

    // Initialize back gesture support when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setupBackGestureSupport);
    } else {
        setupBackGestureSupport();
    }
  </script>
  <script>
    // Registrazione Service Worker per PWA
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js')
          .then(reg => console.log('PWA Service Worker registrato!', reg))
          .catch(err => console.log('Errore PWA:', err));
      });
    }
  </script>
</body>
</html>
